         1         2         3         4         5         6         7
1234567890123456789012345678901234567890123456789012345678901234567890123456789
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
TBDs:

? add a "parser stack" - this would allow stuff like:
  - using #ifdef to skip sections of code
  - allowing "/*" based comments to span multiple lines
  - allow easily adding user defined parsers for data definition languages

? do support for inline comments using "/* ....*/" break the "*/" operator

- document how parsing is done - put a breakpoint in ProcessToken and go from there

- add a visual debugger that displays execution of words

- switch from having a different exit opcode for ops with and without locals
  to having an epilogue at the end of an op that "exit" will branch to
  
- "forget" doesn't complain about bogus symbols

- add ops for getting current search & definition vocabularies

- a method for saving and restoring state
  -> maybe use memory mapped files for the dictionary, and only allow the restore if
     the file can be mapped at the same address

- testing
  - automated tests using outputToFile & comparison of test result file to known good file
  - test structure support

- dll support
  - a mechanism for supporting callbacks from external code to forth code
    -> the assembler somewhat minimizes the need for this
    
? fix local strings
  ? string vars are currently not using len/maxLen fields
    - change output-to-string to use the string current & max length fields

- windows support
  - gui stuff
  - graphics
  ? do this via DLL support

- help system

- faster searches

- add "subroutine"
  -> this will definitely cause problems for any simple save/restore scheme where relocation is required
  
? generalize the undefined symbol handling mechanism which is used to
 define enums
? add a way to extend parsing for user-defined literal constants
 
? forward referencing
  Problem: forward referencing breaks "forget"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
cvs checkout DIR
	fetch a project or directory from cvs

cvs commit
	recursively commit all changes
		
cvs log FILENAME
	show revision history

cvs diff FILENAME
	show difference between current file & repository
cvs diff -r REVISION FILENAME
	show difference between current file & specified revision

cvs update
	recursively update all directories from repository
	can be used to show what files are not in CVS or what files have been modified
	
cvs log FILENMAE
	show history of a file
	
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
colonOp
 ForthEngine::StartOpDefinition
  ForthVocabulary::AddSymbol
   ForthEngine::AddUserOp



-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
ForthShell::Run
  ForthShell::InterpretLine
    ForthEngine::ProcessToken

ForthShell::Run
	calls ForthShell::InterpretLine in a loop until it returns false

ForthShell::InterpretLine
	calls ForthShell::ParseToken and ForthEngine::ProcessToken in a loop until input line is empty
		
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 6 2007

I tried adding a lookup map to vocabularies to speedup loading.  Right now
it is ifded-ed out with MAP_LOOKUP.  It seems to be unnecessary, since in
the release version loading the pentium assembler is instantaneous.  The
slowness of loading in the debug version is probably mostly caused by all
the TRACE message output together with the slowness of debug code.

Removed "code" setting of top search vocab to "assembler".  With this gone,
there was no reason to have "assembler" vocab in kernel anymore, so I removed
it and added it to asm_pentium.txt.

Added a serial number to vocab stack searches to eliminate redundant failed
searches of the same vocabulary.  It worked for everything until I tested
sdl2.txt, and it looks like it failed the first time it tried to lookup
an enumerated type.
-> false alarm, sdl2.txt just wasn't adding sdl to the search order
? maybe make vocabulary stack always have at least 2 entries, and the
  bottom entry is always forth?
  
When this works I should rip out the vocabulary search chain since it is
no longer used.
-> No, the search chain is still used, but only by the structs vocabulary.
-> Move the search chain down to the structs vocabulary
  -> I should probably create a chained vocabulary type, since classes will
     probably want to be able to extend another class, like structs
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 5 2007

Added fprintf/sprintf/fscanf/sscanf - they work except that fprintf/sprintf
can't print floating point numbers - there may be some expectation that
fp numbers will be passed in fp registers, but that would seem to be a
pain for variable numbers of arguments.
One hokey thing is that you have to pass the number of variables to be
printed as the last argument.
Example: stdout "%d,%d" 5 7 2 fprintf

Eliminated precedence vocabulary - it didn't work well with the vocabulary
stack.

Starting debug of pentium assembler.

source:
	code andy dx ) ax mov,  4 # dx add, ax dx ) and, next,
generated:
	011842F8  mov         eax,edx 
	011842FA  add         edx,4 
	011842FD  and         edx,eax 
	011842FF  jmp         edi  
should have generated:
	mov	eax, [edx]
	add	edx, 4
	and	[edx], eax
	jmp	edi

-> The ")" op is never being executed - it may be getting eaten by the shell
-> changed all uses of ")" to "]"
	code andy dx ] ax mov,  4 # dx add, ax dx ] and, next,

Assembler is now generating the correct code for "andy", and the op performs
correctly with both fast & slow interpreters.

DLL support was broken, because it relied on the op for a vocab to push
its address on TOS.

I'm changing vocabularies to act like variables, where a prefix op is used
to set the operation the vocabulary will do when invoked.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 4 2007

Working on switching over to the ans forth vocabulary stack.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 3 2007

Updated CVS.

The GForth assembler is ported, it loads but it is untested.
The GForth package doesn't seem to have any examples of its usage in actual
code, but the assembler is almost identical to the assembler in BigForth,
maybe it has some examples.  The file gforth.050/doc/gforth.i9 has a
"386 Assembler" section which spells out the syntax.

One problem area was that GForth is not case sensitive.

Another was that there was a partially implemented relocation scheme which
remapped forth builtin ops which compile stuff or manipulate the DP to a set of
proxy ops which mostly did exactly the same thing - presumably this was
preparation for swapping out the proxy ops for another set which did something
like assembling to an address offset from the intended run address.

One odd thing was that "," was remapped to "c,", and it looked like "," was
being used to compile byte data, not longs.  Perhaps the intent was that in
the source for the assembler, "," was used to compile stuff that needed to
be relocated and "c," was used to compile stuff that didn't.

The next step would be to create a way to make a user-defined op in
assembler.  This could be tricky, especially if we want the fast inner
interpreter to be able to execute these ops without passing them off to
the slow inner assembler.
-> The user defined code ops would be setup to work with the fast interpreter,
   and create a piece of glue code which the slow interpreter uses to execute
   user defined code ops
   -> We could also use this for builtinOps which have no C++ version (with a small mod)
User defined code ops should live in userOps dispatch table, and therefore
share the opValue space of other user defined ops, which will make "forget"
easy to implement for them.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 30 2007

Working on adapting the GForth assembler

: within  ( u1 u2 u3 -- f )
 over - >r - r> u< ;

: t5a 5 -5 within . ;  ok
: t5b -5 5 within . ;  ok

-6 t5a -1  ok
-5 t5a 0  ok
4 t5a 0  ok
5 t5a -1  ok

-6 t5b 0  ok
-5 t5b -1  ok
4 t5b -1  ok
5 t5b 0  ok

With arguments in low,high order result is true for numbers between low & high-1
With arguments in high,low order result is false for numbers between low & high-1

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 28 2007

Initial debug of new DLL support - it works!

Integrated with old CVS system

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 26 2007

Wrote the assembly side of support for DLL via a special opcode type.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 25 2007

+ look at usage of CompileLong versus CompileOpcode
  -> replaced CompileLong with CompileOpcode where appropriate

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 24 2007

+ see if initialization of local strings works, it might not since it looks like this:
  -> 100 string myName
  The "100" compiles into a constant op, which is then removed by "string", but it
  might make string ignore the "->" and not do the initialization...
  -> added mpLastIntoOpcode to engine, to track last "->" compiled in
     current definition
     
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2007

I moved the replacement of kResultDone with kResultOk into ForthEngine::ExecuteOps.
This centralizes the fix for ops which execute an op variable from exiting
the inner interpreter prematurely.
There is one drawback to fixing this bug, it could make the "done" op useless
except as an internal to the outer interpreter.

+ if "->" has been executed before a native global or local variable declaration,
  initialize the new variable from TOS
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2007

The current state of forth output:

ops which produce output invoke CONSOLE_STRING_OUT, passing a core ptr & a char buffer ptr
CONSOLE_STRING_OUT is defined as: pCore->pThread->consoleOut( A, B )
consoleOut is set by the SET_CON_OUT_ROUTINE macro.

outToScreenOp
  sets consoleOut = consoleOutToFile
  sets output file = stdout

outToFileOp
  sets consoleOut = consoleOutToFile
  sets output file = file on TOS

outToStringOp
  sets consoleOut = consoleOutToString
  sets output file = NULL
  sets output string = string ptr on TOS

outToOpOp
  sets consoleOut = consoleOutToOp
  sets consoleOutOp = TOS

SET_CON_OUT_FILE( FILE_POINTER )
SET_CON_OUT_ROUTINE( OUTPUT_ROUTINE )
SET_CON_OUT_STRING( A )
SET_CON_OUT_OP( OUTPUT_OP )

consoleOutToString just appends the string to the end of the buffer, it should
be changed to use the string current length & max length fields.

Got outToOp working, but found an apparent bug in local variables - if I
define a local pointer variable with "ptrTo byte" I get an exception when
it tries to print what is at that address, but it works if I change that
variable to be "int".
-> the local variable defining code was ignoring the "isPointer" flag.

There is still a bug in the output code - if you use a user-defined op,
any output generating op will end the execution of a calling op.
It almost looks like the "done" flag is being set.
-> duhh, yeah, since consoleOutToOp calls ForthEngine::ExecuteOneOp,
   that does a "done" after executing the output op...
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 21 2007

One way to improve DLL support would be to dedicate an opcode to DLL calls.
The address of the DLL entry point would be held in the user defined op
dispatch table.  The op value field would hold 2 things:
1) the dispatch table index
2) the number of arguments the op takes
As mentioned yesterday, Each DLL would have a dedicated vocabulary.

+ fixed a bug in structure support - any forget was wiping out all structs,
  because it was comparing the forgotten op's value field to the structs
  entire opcode

+ added extends, sizeOf and addressOf

+ add "union" to structure definitions

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 20 2007

The SDL_LoadBMP exception happened because SDL_LoadBMP isn't one of the DLLs
exports - the real export is SDL_LoadBMP_RW.  The defining words for DLL
interface words should check for getProcAddress returning NULL.

Maybe we should create a special type of vocabulary for DLLs, where the
vocabulary would know the path to the DLL and its symbols would be the
DLLs entry points - this would allow saving the forth state and restoring
the DLL linkage on coldstart.

Before you call a C routine you push arguments right-to-left, so the first
argument is on top of the stack (lowest memory address).  When we call a
DLL routine, we push arguments left-to-right, so the last argument is on
top of the stack.  This forces us to have to copy between the parameter
stack and the PC stack to reverse the order.  If that wasn't the case we
could do a trick in assembler where we just set the PC stack pointer to the
parameter stack before the DLL call.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 19 2007

Tried to implement SDL dll interface - got an exception in SDL_LoadBMP

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 16 2007

I took the 11 forth.zip files dating back to February 2004 and entered them
into CVS.  Unfortunately, most of them didn't have the assembler inner
interpreter, just one right after I started writing it and the most
recent version.

I added a recursive search option to FindSymbol and FindSymbolByValue.
The recursive search happens if you pass an optional pointer to a pointer
to a vocab.  This is filled in with the vocab the symbol was found in.
This gets around problems caused by the format of entries being different
in different vocabularies - for example, where the name begins depends on
the number of value fields, which can vary between vocabularies.

I also changed the ForthPrecedenceVocabulary::GetNextSearchVocabulary
to return the engine's current search vocab, so you can just do a recursive
search on the precedence vocab instead of searching it and then searching
the search chain.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 15 2007

Found the "dir" exception - it was in string store code.  String store and
append were stomping multiple registers, and cleaning up by jumping to
the main interpreter entry point to reload the registers from FCore.
Unfortunately, the IP had not been saved out to FCore, so after returning
from the string store, the IP was set back to the return point after the
last user defined word executed.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 14 2007

I tried making symbolic constants forgettable by using the pEntry[1] field
to hold the next user defined op number for forgetting, but that just
doesn't work reliably - many symbolic constants can share the same op
number in this scheme, and there is no way to know which constants were
defined before other constants, since the constants could be in multiple
vocabularies.

I'm switching over to having each enum set having a user-defined op and
having forget only work on user-defined ops.  The user-defined op for an
enum set will act as a defining word that is funtionally the same as the
"int" op.

I added "describe" op which disassembles user ops.
Here is an example:

: dir
  blword -> _aa
  "dir" -> _bb
  strcmp( _aa "" )
  if
    // user specified a directory
    strcat( _bb " " )
    strcat( _bb _aa )
  endif
  _bb system drop
;

dir: type UserDefined:9 value 0x1000009 0x0
0118041c  00:00011d    blword
01180420  00:000012    ->
01180424  01:000001    _aa
01180428  0a:000001    "dir"
01180430  00:000012    ->
01180434  01:000002    _bb
01180438  01:000001    _aa
0118043c  0a:000001    ""
01180444  00:0000b6    strcmp
01180448  04:000007    BranchFalse    0x01180468
0118044c  01:000002    _bb
01180450  0a:000001    " "
01180458  00:0000b2    strcat
0118045c  01:000002    _bb
01180460  01:000001    _aa
01180464  00:0000b2    strcat
01180468  01:000002    _bb
0118046c  00:00010c    system
01180470  00:000001    drop
01180474  00:000016    _exit

There is an exception if you execute "dir" in turbo mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 13 2007

Added "enum definition" mode - this is an interpreted mode, where:
o recognized symbols including numbers are executed like normal
o unrecognized symbols become new enumerated value definitions
o stack depth is recorded at start of enum definition, when a new enumerated
  value definition is created, it will pop its value off TOS if TOS is above
  the level at the start of enum definition
o enumeration value is incremented after each definition
o if possible, enumerated value definitions are created as kOpConstant ops,
  if they are outside the possible range a user-defined constant op is
  defined instead

When testing enums, I found an interesting forget bug: if you try to
forget a kOpConstant definition, nothing appears to happen, the constant ops
still show up in vlist, but if you then forget a user op, the constant ops
will also be forgotten, even if they were defined before the user op.
? Is this a problem just for constant ops, or would if affect any ops which
  do not have an entry in the engine dispatch table ?
-> the problem is because forgetting only works for user defined ops (kOpUserDef)
-> we could make symbol constants unforgettable (this wouldn't work for
   constants which were too big for symbol constants, since they are user ops)
-> maybe there should be a dummy symbol for each enum set that is used just
   for forgetting
-> we could use the unused "struct" field, make it type kDTNone, with the
   value field holding the value of the next user op at the time the
   symbolic constant was defined...  the forget would have to be
   modified to take this into account
   
With enums and structs, I can start making an interface for the SDL DLL.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 11 2007

Got structures working, just did a few simple tests, didn't test arrays or
nested structures or anything complex
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 8 2007

Maybe the first attempt at structures should skip all optimizations, just
compile an op for each symbol in a structure access compound op

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 7 2007

Struct defining stuff is in.  Extension to outer interpreter to handle
stuff like a.b.c is not in yet.

I'm not completely sure that the handling of pointers is correct.
I got rid of ForthNativeStringType, merged it back into ForthNativeType.
I'm not convinced that was a good idea, the code is messy, I was trying to
avoid duplicating DefineInstance.  Most of the ugliness is because strings
need to get the maximum string length, and how that is done is different
in interpret mode and compile mode.

Strings and string arrays in structs is probably not a great idea anyway,
since the maximum length field is not set in that case, so it would be easy
to use an uninitialized string and get a buffer overrun.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 31 2007

Added ForthNativeType

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 26, 2007

Added initStringArrayOp

Added code for arrays to defining words

Added ptrTo support to variable/array defining words
Right now, any variable/array defined with ptrTo is the same as an int
variable/array.
When both arrayOf and ptrTo appear in the same declaration the result is
an array of ints.

Increased length of vocabulary value field for user-defined ops to 2 longs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 25, 2007

Added initString op

How should local & global arrays be supported?
Should they use varOps?  Should they be just like variables except always
doing an array indexing operation?

Simplified existing global/local variable code.  Previously there was code
for each combination of varOp and local/global/field vars.  Now local/global/field
use common code for each varOp.  This is slightly less efficient when running
with the c++ inner interpreter but cuts down the amount of code by a factor
of 2, which makes adding array support easier.

Added support code for all types of arrays

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 23, 2007

Removed remaining vars/endvars dead code
Added field action types
The c++ field action code was using the field offset as longs, changed it
to be using bytes

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 22, 2007

Added dummy entries for struct support ops, just to avoid having to add
them an op at a time to c++ and assembler versions
Added sp, s0, rp, r0, fp ops
Added tuck, pick, roll ops
Changed vocabulary stuff to use long* instead of void* for symbol entry pointers

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 20, 2007

Added byte, short, op data types

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 18, 2007

Added compilation of initLocalStringOp for local string vars

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17, 2007

Added byte & short types
Added local string support to turbo mode
Changed string store & append varOps to use max & current length fields
Added output redirection
Added ArrayOffset optype

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 16, 2007

Been working on structure stuff in ForthStructs.txt

A potential problem with using DLLs from forth ops is anything that requires
a callback.  A possible solution would be to define an interfacing DLL that
goes between the windows DLL and forth.

? could we define a generic callback into forth, and accessors on the forth
  side that gave access to the callback arguments on the stack ?
-> wait until we run into a case where we need a callback

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 15, 2007

Added varAction! and varAction@
Added memcpy and memset

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 14, 2007

Added simple help system to forth_autoload.txt
Still need to add op definitions for builtin ops

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 4, 2007

Started integrating forth into ForthGui

It is at the point where I can pass a line of text from an edit control to
the forth shell, and it processes it correctly.

The next step is to change the output system so that it can be sent back to
ForthGui for display in another edit window.

The way it currently works is that forthOps that generate output call a
local procedure named stringOut.

stringOut writes its output to the current output file if one exists,
otherwise it pushes the string address on param stack and invokes an internal
op called ConOutOpInvoke, which pops the string and appends it to the console
output string buffer.

OutToStringOp sets the current output file to NULL.
OutToScreenOp sets the current output file to stdout.
OutToFileOp sets the current output file to the specified file.

It would be good to change this so that output can be sent to:
1) a specified routine
2) a user op

printCharOp (%c) also uses ConOutOpInvoke.

? does anything currently use output to buffer?

It looks like nothing uses output to buffer, and the console output buffer
is always NULL unless the user executes the "outToString" op.

I should probably implement the changes to strings which set the current
and maximum length fields for local strings before doing the output ops.
The only ops which 
strcpy			->
strncpy			->
strcat			->+
strncat			->+
strlen    strchr    strrchr    strcmp    stricmp    strstr    strtok

I started adding maxLength/curLenth to strings, it is done for global varibles,
but it is probably broken for local variables...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 26, 2007

Added chdir (couldn't use "system" for this)

Added autoforget - just a version of "forget" that doesn't complain if
  symbol to forget doesn't exist

Added interpret - takes a string and gives it to outer interpreter

Added automatic loading at startup of forth_autoload.txt

Added a bunch of string operators (strncpy, strncat, strrchr, stricmp)

Added a bunch of tests to forthtest.txt

Added sc@ & sw@	- signed byte & word fetch
Added c2l & w2l - byte & word sign extension to long

Added ability to specify double float constants by appending a "d": 1.0d
You can specify single float constants by 1.0f, but this is the default

Fixed bug with "0 word"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 21, 2007

Broke out stuff in this file into seperate files in ForthDocs.

Tried out builds... does with:
	: plusser builds , does @ + ;
	5 plusser p5
	20 p5
Normal mode returns 25, but turbo mode returns 40.
	: minusser builds , does @ + ;
	5 minusser m5
	20 m5
Normal mode returns 15, but turbo mode returns 0.

-> got it working, but I should go through and verify that it is right
  It feels like there is another level of indirection than is correct...
-> there was a bug in @ - it wasn't doing any indirection, so it was a no-op,
   and I had added an extra level of indirection to the asm doDoes code

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 18, 2007

Fixed offset optype.

Changed local var stuff so that local vars can be declared anywhere,
vars...endvars are not needed and should be removed.
One case which was a problem was strings:

: anExample
  55 string anyName
;

In this example, the 55 which was intended to be the length param to "string"
had been compiled.  To deal with this, I added a method to the engine which
checks if the last compiled opcode was a literal constant and returns its
value if so.  The "string" implementation backs the DP over this constant.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 17, 2007

When I looked at converting the string ops into assembler, I started thinking
about string variables, in particular about detecting and avoiding string
buffer overruns.  Three main possibilities came to mind:

1) do like C does, just ignore the problem and always assign bigass buffers
2) add a max length field to string variables
  a) add a current length field to string variables
3) go to a scheme where strings are handled more abstractly
  a) suppose a string was a base pointer and a length
  b) or maybe a pointer, current length and writable length (0 means const string)

One problem with making strings more complex than simple uninitialized
buffers is that it would make implementing local strings more complicated

The max length field isn't important for ops that don't modify a string, so
stuff like strlen, strcmp. strstr and strchar could be implemented as they
are now by just calling the C library routines.

Another problem with making strings something other than a simple set of
bytes is if you want to use them in a disk record structure, you probably
don't want the extra length fields taking up space.

I went off on a tangent about eliminating the need for vars/endvars, allowing
you to declare variables anywhere in a user defined word.
  You would probably want to compile the allocLocals op at the first occurence
  of a local variable.  There are many ways that a user could shoot themself
  in the foot doing this, especially if they were manipulating the return
  stack, but it would be mostly safe.
  One consequence of this is that when a string local var is declared, it would
  have to see if a literal constant was just compiled to determine its size.
  -> maybe we could leave that literal constant op where it was compiled, and
     then compile an opcode immediately after it which would store that constant
	 in the local string vars max length field and zero its current length field.

I tried adding an offset optype, it works fine in interpret mode, but not in compile mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 16, 2007

Got most of the floating point ops defined
int, float & double global & local variables are working

- need to test builds...does

- change string variables to include a current length & max length

? make an optimized case branch, where the opcode includes the case value
  and branch offset?

+ added the ability to add 'd' or 'f' to the end of real literals to control
  generation of single or double precision constants

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 13, 2007

Assembler version of forth is mostly working.

I added a macro to allow assembly-code ops to invoke c-code ops.

I added an op "turbo" that allows switching between using c-code
and asm-code inner interpreters on the fly.

c-code is setting ForthCoreState->state @(002F4948 + 434) = 1
asm-code is checking (002F4948 + 432)
? Say huh ?

I auto-generated core.inc from core.h to define the FortheCoreState structure
for asm-code.  One problem area is enumerated types.  Maybe both the c-code
and asm-code structures should be defined strictly in terms of simple types
with a known storage size.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 4, 2007

Worked on writing assembler versions of optype dispatch routines.

Got to LocalIntAction

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 3, 2007

In preparation for switching over to using assembler for inner interpreter,
I changed the inner interpreter to use a 2-stage dispatch scheme, and broke
out the portion of the state that the assembly code will use into a new
structure, the ForthCoreState.

o There is a single ForthCoreState, which is contained in the ForthEngine.
o The ForthCoreState is associated with a single thread at any time.

I had done a similar state breakout of ForthThreadState from ForthThread a
while back.  The big difference is that ForthCoreState contains the
optype dispatch table and other ForthEngine related stuff.

One other related change which caused some bugs is that before both builtinOps
and user defined ops shared a single dispatch table, now they each have their
own table.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Assembler version

7 general purpose registers available:
eax, ebx, ecx, edx, esi, edi, ebp

Things to keep in registers:
IP
SP
optype dispatch table
? builtinOp dispatch table
inner interpreter PC
thread ptr (RP, FP ...)

this would only leave one general purpose register available for stuff...

EAX	free
EBX	free
ECX	IP
EDX	SP
ESI	builtinOp dispatch table
EDI	inner interp PC
EBP	core ptr

? maybe combine opType and builtinOp tables - have bottom 256 builtinOp codes
  be used for opType dispatchers
-> it would not be "free" to detect situation where you compile an opcode in 0..255, which
   would cause an optype handler routine to be executed as if it were a builtinOp
   -> detecting this would require an extra compare & branch instruction pair, which could
      be included in the debug version of the inner interpreter

Maybe the engine ptr should be in a register, and the engine should have a notion
of a current thread, and the threads state is stored in the engine...


Maybe EBP register should point to a new structure, which has:
  1) current thread state (RP, FP, etc)
  2) ptr to engine
  3) ptr to current thread
  4) opType dispatch table
  5) builtinOp dispatch table
forthOps can reuse ESI or EDI, but if they do they either reload them from the EBP struct
or they branch to an alternate inner interpreter entry point that reloads ESI & EDI
Some of this structure is global engine state, some of it is a copy of the current thread state.

innerInterp
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins		; numBuiltins includes the 256 opType dispatchers
	jge	notBuiltin
	mov	eax,[esi+eax*4]
	jmp	[eax]

innerInterpDebug
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins
	jge	notBuiltin
	cmp	eax,256
	jlt	badOpcode
; we should add checking of SP, RP etc. here
	mov	eax,[esi+eax*4]
	jmp	[eax]

notBuiltin
	mov	ebx,eax			; leave full opcode in ebx
	shr	eax,24			; eax is 8-bit optype
	mov	eax,[esi+eax*4]
	jmp	[eax]

;
; builtinOp code
;

addOp
	mov	eax,[edx]
	add	edx,4
	add	[edx],eax
	jmp	[edi]
	
	
+ I broke out the part of the forth machine state the inner interpreter uses
  from the ForthThread class into a structure.
- Change the dispatch table to combine the optype and builtinOp tables
- Move most of ForthThread::InnerInterpreter into a c function, get that
  working and then use the generated assembly entry and exit code
- Remove the user-defined (high level) ops from the builtin op table
- Put the pointer to the dispatch table into the inner interpreter struct
- Don't have 256 opType dispatchers, the top 128 are for method stuff...
- Change the current opType action routines from ForthEngine methods to
  standalone routines
- Move the inner interpreter and the opType action routines into their
  own source module
  -> need to disentangle the intOp/doIntOp/intActionRoutine stuff first

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 8, 2006

+ added ForthForgettable class, changed ForthVocabulary to be based off it

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 5, 2006

+ added input buffer processing ops word/blword/fillInBuffer...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 2, 2006

+ added support for loading DLLs and accessing procedures in DLLs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 30, 2006

+ fixed a bug with parenthesized expressions - the token length byte wasn't
  being set in a few places, so tokens coming off the shell stack disappeared

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 17, 2006

- definition of an interface
- definition of a structure
- definition of a class
- representation of an object on stack
- method invocation
- local objects
  - automatic constructor/destructor
- global objects
- objects as members of other objects
- constructors
- class static data members
- arrays of objects

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 3, 2006

+ added shell stack
+ converted control structures to use control stack
+ added parenthisized expressions using control stack
+ added better error messages for control structure syntax errors

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 12, 2005

I haven't done much with this project in a while.
Current things to add:

1) Shell stack - holds info used while compiling control structures and
   for error checking
2) Add ability to use parenthesized expressions like this:
   sin( x 2 * )
   When "sin(" is parsed, the "sin" token is pushed on the shell stack,
   and when ")" is parsed, the "sin" token is poped and compiled.
   This needs to support parens which have no associated function.
   This should work in interpret and compile mode.
3) Add default input and output files to a thread, and ops for doing
   binary IO with them - formatted IO will probably still use the
   existing IO operators and stream redirection
4) Add support for loading DLLs and accessing their entry points
5) Add a message passing/event system - a thread can have a chain of
   listeners that are informed when a significant event occurs
6) Add support for basic windows calls


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth Implementation Classes

ForthEngine
  tools for building forthops
  code space management
  DP
  inner interpreter
  outer interpreter (token-level interpretation)
  action routines for forthOpTypes

ForthShell
  parsing
  line-level interpretation
  input stream management

ForthVocabulary
  symbol table management
  vocabulary search

ForthThread
  storage for stacks
  SP, RP, IP

ForthInputStack
  current input stream
  pushing and popping streams
  input buffer management

ForthInputStream
  input fetching

ForthParseInfo
  setup for fast vocabulary matching
  interface between ForthShell and ForthVocabulary

ForthForgettable
  does propagation of "forget" to all vocabularies and memory cleanup after forget


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth opcode types

kOpBuiltIn          // low 24 bits is builtin opcode

kOpUserDef          // low 24 bits is opcode

kOpBranch,          // low 24 bits is signed branch offset
kOpBranchNZ,
kOpBranchZ,
kOpCaseBranch,

kOpConstant,        // low 24 bits is signed symbol value

kOpString,          // low 24 bits is immediate string length in longs

kOpAllocLocals,     // low 24 bits is frame size in longs

kOpLocalInt,        // low 24 bits is frame offset in longs
kOpLocalFloat,
kOpLocalDouble,
kOpLocalString,

kOpMethodWithThis,  // low 24 bits is method number

kOpMemberInt,       // low 24 bits is object offset
kOpMemberFloat,
kOpMemberDouble,
kOpMemberString,

kOpLocalUserDefined,             // user can add more optypes starting with this one
kOpMaxLocalUserDefined = 127,    // maximum user defined optype

kOpUserMethods  = 128
// optypes from 128...255 are used to select class methods    

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-


forth extensions for syn2k:

- operations for stating what synops are in a patch,
  and what order they are to be executed in
- operations for initializing synops - settings parameters
  and input and output buffers
- operations for getting note frequency and velocity
- operations for building up sets of patches which are
  selected by midi program number
= operations for defining envelopes and connecting them
  to synops
? is there a way to define the interface so that when
  a new synop is added to syn2k another op doesn't have
  to be added to forth?


table <TABLENAME>
endtable

<TABLENAME> tableLen    leaves number of entries in table on stack

synPatchSet <SETNAME>

synPatch <PATCHNAME>
endPatch



//       11111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890
<############################# Last Line In File ##############################>
