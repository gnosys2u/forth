         1         2         3         4         5         6         7
1234567890123456789012345678901234567890123456789012345678901234567890123456789
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
TBDs:

! document existing native ops !
! create examples/tests for all native ops !

? have "woof -> foo( blah )" compile into "woof blah -> foo"

? add properties to classes

- only allow "implements" to be used on abstract interfaces (no data members) - this
  will avoid the problem with accessing data members on secondary interface objects
  which have different data members...

- add support for iterating over files in directories

? add a debug feature where a map is maintained from IP address to file/lineNumber

? add a dynamic array (of longs/pointers

? add a string-to-long map based off CMap
  remember that a charPtr-to-long map would just map from the value of the
  charPtr, not the chars in the string, to the long

? add a "parser stack" - this would allow stuff like:
  - using #ifdef to skip sections of code
  - allowing "/*" based comments to span multiple lines
  - allow easily adding user defined parsers for data definition languages

? does support for inline comments using "/* ....*/" break the "*/" operator

- document how parsing is done - put a breakpoint in ProcessToken and go from there

- add a visual debugger that displays execution of words

- switch from having a different exit opcode for ops with and without locals
  to having an epilogue at the end of an op that "exit" will branch to
  
- "forget" doesn't complain about bogus symbols

- add ops for getting current search & definition vocabularies

- a method for saving and restoring state
  -> maybe use memory mapped files for the dictionary, and only allow the restore if
     the file can be mapped at the same address

- testing
  - automated tests using outputToFile & comparison of test result file to known good file
  - test structure support

- dll support
  - a mechanism for supporting callbacks from external code to forth code
    -> the assembler somewhat minimizes the need for this
    
? fix local strings
  ? string vars are currently not using len/maxLen fields
    - change output-to-string to use the string current & max length fields

- windows support
  - first step: create an app where all the windows stuff is in c++
    - support associating windows controls to forth ops
    - a programmable calculator might be a good first step
  - graphics
  ? do this via DLL support
  
- help system

- faster searches

- add "subroutine"
  -> this will definitely cause problems for any simple save/restore scheme where relocation is required
  
? generalize the undefined symbol handling mechanism which is used to
 define enums
? add a way to extend parsing for user-defined literal constants
 
? forward referencing
  Problem: forward referencing breaks "forget"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
In a DOS shell:

cvs checkout DIR
	fetch a project or directory from cvs

cvs commit
	recursively commit all changes
		
cvs log FILENAME
	show revision history

cvs diff FILENAME
	show difference between current file & repository
cvs diff -r REVISION FILENAME
	show difference between current file & specified revision

cvs update
	recursively update all directories from repository
	can be used to show what files are not in CVS or what files have been modified
	
cvs log FILENMAE
	show history of a file
	
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
colonOp
 ForthEngine::StartOpDefinition
  ForthVocabulary::AddSymbol
   ForthEngine::AddOp



-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Gotchas with structure and object support:

1) pointer fields are automatically dereferenced in field selectors, except
   for the final field:    "5 -> woof.pointerToInt" will set the pointerToInt
   field to 5, it will not set the int pointerToInt points at.
2) varAction ops must be the symbol just before a field selector symbol, which
   means that index calculation ops must appear before the varAction op


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 4, 2010

I added r[ and ]r, which are used for variable numbers of arguments, and I
added some definitions which use them which build tables of the basic types.

I've mainly been working on SoftSyn2 for the past 7 months.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 1, 2009

BOOL CForthGuiAppDlg::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
  nID: id of the control
  nCode: tells how to interpret pExtra
  pExtra:
  pHandlerInfo:
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 28, 2009

Did a quick look around at ways to support dynamic dialogs.  These are the
ways I found:

1) use standard GUI wizard to create a crapload of controls which are all
   initially hidden, unhide them when you need them
   + least complicated initially
2) use OnCmdMsg handler and process the command messages
   + most flexible
   - requires a lot of knowledge about control messages
3) use ON_CONTROL_RANGE in the message of a dialog class to map a range of
   control IDs to a specific handler
   + could be combined with method 1
4) dynamically build the message map at runtime (Dr. Dobb's article tells how)
   - can't easily add a control after dialog is visible
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 18, 2009

Been away for a few months.

Did some thinking about adding threads to forth, in particular how this
would affect the server, and the different forth use scenarios (standalone
console app, script support in local apps, script support in remote app/game)
and I think I know how to proceed.  The details are in ForthThreads.txt and
ForthServer.txt.

The first step will be to create a good set of backups.

o The main loop in ForthShell::Run will be removed, most of its functionality
  will go into a new method ForthEngine::Update

o ForthEngine will be responsible for managing thread lists or queues

o ForthClient will be changed to do its console fgets in a separate Windows
  thread

o ForthServer methods which send messages to the clients will be broken in two,
  with the part which waits for the client response and then process it being
  removed and put in a single common client response processing method

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 1, 2009

DOHHHHHHHHHHHHHHHHHH!
The problem with the DS server is that recv always returns SOCKET_ERROR until
it gets the requested number of bytes...
Removing that made the DS server work fine...

Can't run forthtest.txt, it uses "demo" which is defined in forth_autoload.txt,
and forth_autoload.txt won't load on the DS because it uses the "system" op.
-> See if system op can be made to run easily on the DS
? Maybe make it a shell operation, like the way file operations are?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 19, 2009

A quick overview of the windows client:

  init winsock
  create ConnectSocket  (AF_INET, SOCK_STREAM, 0)
  fill in ClientService with IP address of server, port 27015
  connect to server
  if connect worked
    create pMsgPipe    ForthPipe( ConnectSocket, valid messages are in kClientMsgDisplayText...kClientMsgLimit )
    push stdin on top of inputStack
    while !done
      get a message from server
      process message
  cleanup
  cleanup winsock
  exit

A quick look at ForthDS.txt and ForthNotes.txt shows that the last known
working version of Forth.NDS was on May 31, 2009.

The source files which have been modified after that date are:
modified						rev		revDate
jun4	ForthInner.h			10		may25
jun6	ForthInput.cpp			6		jun19
jun6	ForthInput.h			6		jun19
jun23	ForthInner.cpp			16		jun27
jun28	ForthShell.cpp			18		jun27
jun28	ForthShell.h			13		jun27
jul1	ForthMessages.h			1		jun28
jul10	ForthOps.cpp			25		jun27
jul12	ForthPipe.cpp			1		jun28
jul18	ForthPipe.h				1		jun28
jun30	ForthServer.h			2&3		jun28			1	jun19
jul1	ForthServer.cpp			2&3		jun28			1	jun19
-------------------------
jun29	ForthServerMain.cpp		2		jun28			1	jun19
-------------------------
jul1	ForthClientMain.cpp		2&3		jun28			1	jun19
jul2	main.cpp				2		jun28			1	jun19

It appears that I really only have a snapshot of June 19, but the changes between
May 31 and June 19 seem to all be related to Thumb versus Arm assembler changes,
not networking changes.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 15 2009

The current use of bracket to switch into interpret mode seems like a waste
of a potentially very valuable synctactic element for a very limited use.
I think it would be better if "[" was treated like a special character by the
outer interpreter, to help disambiguate operations on array members from
operations on the array itself.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 1, 2009

Got a lot of work done in the windows version of client/server, details are in ForthNotes.txt:

o file IO goes through the shell, and works for client/server
o fixed a bunch of existing client server bugs
o broke out client/server communication into ForthPipe

Ugh, when I brought the DS forth server up, after it connects it gets an
error back from the first recv call! DOH!

------
Server									Client

connects to access point
waits for a client to connect
										connects to server
										waits for a message from Server (forever)
accepts connection
sends SendLine("ok>") message
calls recv to get reply
recv returns error

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 30 2009

Looked at the "load blah.txt" bug - what is happening is that after trying to
load a non-existant file, there is a one line delay between when you send a
line to the server and when you get the response.  This delay increases by one
line each time you try to load a bogus file.

The problem appears to be that right after the server sends a "StartLoad"
message, it sends a "SendLine" message, since it is done processing the
line that had the bogus load command on it.

+ adding a kServerMsgStartLoadResult message fixed it

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 29 2009

+ created separate solutions for ForthClient and ForthServer - it just makes
  it easier when running multiple sessions of MSDEV to do client/server debug
  
+ fixed the disconnect problem that happened after loading forthtest.txt -
  the problem was that when a "loaddone" opcode was executed, the client was
  not told to pop its input stack, so it kept on reading forthtest.txt until
  it hit the end of file, at which point it sent a "pop input stream" to the
  server, which caused it to disconnect
  ? should server ignore "pop input stream" when the input stack depth is 1 ?
  
The bug where things get screwy after you type "load blah.txt" when blah.txt
doesn't exist is probably very similar

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 28 2009

+ finished implementing the remote file operations

+ partially tested file operations locally and remotely, they work

o I had switched numItems/itemSize in fread and fwrite ops, I switched them
  back everywhere, I think...
  
o I turned off 64-bit compatability warnings because they harped about storing
  file pointers in ints...

Known differences/problems when using server:
+ sometimes the prompt doesn't appear on its own line
- sometimes there are multiple prompts printed on a line after loading a file
- if you type "load foo.txt" and foo.txt doesn't exist, if you then type in
  the correct name, it looks like the load doesn't happen right away, it
  happens after you enter another console line... maybe...
+ sometimes after loading a file, the server shows the client as disconnected,
  while the client is permanently stuck waiting for the next 8-byte message header
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 27 2009

+ Added ForthPipe abstraction which implements message passing between client
  and server, and converted over old ForthClient/ForthServer to using it, got
  it working on Windows, need to try it out on DS

+ need to add remote file operations using ForthPipe

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 26, 2009

Started reworking server/client messages to be more regular, to make
implementing remote file access easier.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 21, 2009

DS asm inner interpreter is completely switched over to ARM mode.
Also implemented many more ops in assembler.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 19, 2009

Switching DS asm inner interpreter to ARM mode gives us registers r8-r12 to
use.  I plan to use them like this:

@	R0 - R3		scratch		(R0 is pCore at start)
@	R4			core ptr
@	R5			IP
@	R6			SP
@	R7			FP
@	R8			RP
@	R9			builtinOps table
@	R10			#builtinOps
@	R11			actionType table
@	R12			0xFFFFFF (opvalue mask)

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 13, 2009

Got Desmume built on second system, copied over to this system.
What I am doing:
- double-click E:\pat\prj\NDS\Desmume shortcut, which has " --arm9gdb=1234" param
	File\Open	Forth.nds
- double-click C:\bin\devkitPro\insight\bin\arm-eabi-insight.exe
	File\Target settings
		Target:		Remote/TCP
		Hostname:	192.168.1.150
		Port:		1234
	Run\Connect to target
	File\Open E:\pat\prj\Forth\Forth.elf
	Run\Run
	If a popup comes up saying "Make breakpoint pending on future shared library load?",
		click "No" - clicking "Yes" crashes Insight.
If you reload the file in insight, you need to reload it in desmume as well
Sometimes when insight gets stuck, doing reset on desmume unsticks it

All assembler functions need to be preceeded with ".thumb_func", or else
arm-mode instructions are generated, and the cpu misinterprets arm instructions
as thumb instructions leading to crashes.
? is there a way to tell the gnu assembler that the whole file should be thumb
? should I switch the inner interpreter to be arm mode?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 5, 2009

Tried DS Forth in the iDeaS emulator, they say SWI #FD will break into the
debugger, but it didn't work for me.

-> it looks like it only works in ARM code, not THUMB code

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 1, 2009

Looking at ARM assembly language

InnerInterpreter:
	push	{r4, r5, r6, lr}
	mov	r3, #0				// SET_STATE( kResultOk )
	ldr	r5, .L146			// r5 = 0x00FFFFFF
	mov	r4, r0				// r4 = pCore
	str	r3, [r0, #64]		// r0 = pCore
.L143:
	ldr	r3, [r4, #36]		// r3 = IP
	mov	r0, r4				// r0 = pCore
	ldmia	r3!, {r1}		// r1 = next opcode, advance IP
	str	r3, [r4, #36]		// save IP in core
	lsr	r2, r1, #24			// r2 = opType (hibyte of opcode)
	ldr	r3, [r4]			// r3 = opType action routine table address
	lsl	r2, r2, #2			// turn opType into longword offset
	and	r1, r1, r5			// r1 = low 24 bits of opcode
	ldr	r3, [r2, r3]		// r3 = action routine for this opType
	blx	r3					// dispatch to action routine
	ldr	r0, [r4, #64]		// get state from core
	lsl	r0, r0, #24			// mask off top 24 bites
	lsr	r0, r0, #24
	cmp	r0, #0				// keep looping if state is still ok (zero)
	beq	.L143
	pop	{r4, r5, r6, pc}
	
	.align	2
.L146:
	.word	16777215

	
	
eForthResult
InnerInterpreter( ForthCoreState *pCore )
{
    ulong opVal, numBuiltinOps;
    forthOpType opType;
    long *pIP;
    long op;
    numBuiltinOps = pCore->numBuiltinOps;

    SET_STATE( kResultOk );
    
    while ( GET_STATE == kResultOk ) {
        // fetch op at IP, advance IP
        pIP = GET_IP;
#ifdef TRACE_INNER_INTERPRETER
        GET_ENGINE->TraceOp();
#endif
        op = *pIP++;
        SET_IP( pIP );
        opType = FORTH_OP_TYPE( op );
        opVal = FORTH_OP_VALUE( op );
        pCore->optypeAction[ (int) opType ]( pCore, opVal );
    }

    return GET_STATE;
}


	
	
	
// A B + ... (A+B)
// forth SP points to B
//
plusOp:
	push	{r4, lr}	// save r4 and return address
	ldr	r3, [r0, #40]	// r3 = SP
	mov	r2, r3			// r2 = SP
	ldmia	r2!, {r1}   // r1 = B, r2 = SP after popping B
	ldr	r4, [r3, #4]	// r4 = A
	str	r2, [r0, #40]	// save new SP
	add	r2, r4, r1		// r2 = A + B
	str	r2, [r3, #4]	// push r2 (result of A + B)
	pop	{r4, pc}		// restore r4 & return

	
// A B - ... (A-B)
//
minusOp:
	push	{r4, lr}	// save r4 and return address
	ldr	r3, [r0, #40]	// r3 = SP
	mov	r2, r3			// r2 = SP
	ldmia	r2!, {r1}   // r1 = B, r2 = SP after popping B
	ldr	r4, [r3, #4]	// r4 = A
	str	r2, [r0, #40]	// save new SP
	sub	r2, r4, r1		// r2 = A - B
	str	r2, [r3, #4]	// push r2 (result of A + B)
	pop	{r4, pc}		// restore r4 & return

timesOp:
	push	{r4, lr}	// save r4 and return address
	ldr	r3, [r0, #40]	// r3 = SP
	mov	r2, r3			// r2 = SP
	ldmia	r2!, {r4}   // r4 = B, r2 = SP after popping B
	ldr	r1, [r3, #4]	// r1 = A
	str	r2, [r0, #40]	// save new SP
	mov	r2, r4			// r2 = B
	mul	r2, r1			// r2 = A * B
	str	r2, [r3, #4]	// push r2 (A * B)
	pop	{r4, pc}

	
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 31 2009

I switched over to the combined build with an explicit arm7 section, but it
still didn't work, then I found an error in my accept call, fixed that and
now the DS Forth server connects to the PC client and works! Woohoo!

There is a problem when an error occurs while doing a "load", the input
stream is not sent back to the console, so you get a cascade of errors.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 30 2009

I noticed that wifi_example1 and wifi_lib_test, which I got from the dswifi site
both have an arm7 source file which sets up the network.

The DSMI examples (DS midi wifi) all have an equivalent arm7 section.

The nds-examples-20090504\dswifi examples, which I got my Forth Makefile from,
do not have arm7 sections - say huh?
? are they loading an arm7 lib from somewhere
? are they out of date
I did build and run the ap_search and autoconnect examples, and they do work.

I found a website with a NDS tutorial (http://www.double.co.nz/nintendo_ds/nds_develop1.html)
that says that libnds includes boilerplate ARM7 code, and that devKitPro includes
this, but the tutorial wasn't talking about network stuff.

The dswifi forums are down, supposed to be back up June 3 (Wednesday).

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 25 2009

+ rearranged some things to make server-client split easier
+ got client-server working on PC
+ changed build target configurations - before all executables were a single target

Client takes server address as a command line argument, uses localhost if no arguments.

! right now, ForthClientMain doesn't include any Forth files, so the definitions of
  server and client command message numbers are both in ForthClientMain.cpp and in ForthServer.h,
  they are bound to get out of sync...
  
+ got Forth server to compile for DS, but it didn't do anything when I ran it...
  -> there may be more DS wifi hardware setup required
  
server    --kClientCmdSendLine(prompt)->      client
client    --kServerCmdProcessLine(text)->     server
client    --kServerCmdPopStream->             server

server    --kClientCmdStartLoad(filename)->    client

-> means server to client
<- means client to server

-> getLine( ok> )
<- data( load blah.txt )
-> pushStream( blah.txt )
-> getLine()
<- data ( ... )

... repeat previous 2 lines for each line of file ...

-> getLine()
<- endOfFile ( ... )

-> getLine( ok> )

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 24 2009

Forth on the DS will run as a server, with a command shell client running on
the PC.  The client will be responsible for sending text to the server, and
for displaying text from the server.
The first step is to make a client-server version of Forth where both client
and server run on the PC.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 23 2009

Got Forth to compile for the DS under devkitPro.  There are a few new defines
used, _WINDOWS and _ASM_INNER_INTERPRETER.

There are still a lot of warnings when building for the DS.

Replaced MFC containers with STL containers.

+ also, replaced strtime and strdate ops with time and strftime ops, this
  allows more complex formatting and also works on the DS

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 4 2009

Got the SPriG dll to work, I forgot to do SDL_UpdateRects after drawing

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 3 2009

Tried to get SPriG, an SDL based graphics library to work, couldn't get it
to draw a line, after running there was extra junk on stack.
Several params are declared as Uint16, could this be screwing things up?
I thought short params were promoted to long on the stack

Also, sdltest.txt now leaves extra junk on stack.
-> there was an enum that was defined twice - enum definitions rely on
   the new enum symbols being undefined, since during an enum definition
   any defined symbol is just executed

Some of the SPriG functions take a callback, this brings up the question of
adding a general callback mechanism - a way to have callbacks from DLLs
execute forth code.
o it wouldn't be hard to implement this
o may need to support callbacks that return a value and callbacks that don't

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 30 2009

Making vocabularies be a kind of object has some problems - for one thing,
we would probably want them to ignore the "delete" method and "->".
I'm now leaning toward having a set of "class methods", either using a
dotted syntax like "className.new" or prefix syntax like "new className".

class methods:
	new
	parent
	size
	methods
	id
	
Use "classA.id objB.queryInterface" to get the classA interface from objB - the
result is an object - if objB does not have a classA interface, the result is
the null object (double zeros).
	
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 29 2009

I changed the initialization of the builtinOp and optypeAction tables in the
forth core to only be done once in ForthEngine->Initialize.  Previously this
was being done also in ForthEngine::SetFastMode, since those tables were used
for both fast and slow modes.  SetFastMode was not filling in any builtinOps
which were not in baseDict, such as builtin classes or user-defined builtins

The next challenge is defining what appears in the builtin classes.  A lot of
functionality is hard to define without making some decisions - like how do
you specify the interface you want to a queryInterface method?  I am leaning
toward defining a classVocabulary class, parented off a vocabulary class,
parented off the object class.

object : NULL
	delete
	data
	methods
	show
	class	(returns a classVocabulary object)
	size
	queryInterface

vocabulary : object
	uses
	also
	? something to undo "also" ?
	only
	definitions
	numEntries
	find
	addEntry
	removeEntry
	* some way to iterate through entries *
		* info about entries - number of longs in data section
	
classVocabulary : vocabulary
	parent
	methods
	classId
	isAbstract
	numMethods

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 28 2009

Messed around with asm version of kernel, got it to use the static tables
opsTable and opTypesTable instead of the stuff in FCore

+ change table init routines to always fill in core optypeAction and builtinOps
  with C versions
+ replace extOp macros with a single extOp routine
+ fill in FCore.numAsmBuiltinOps with # entries in opsTable, and have
  inner interp check against that, and call extOp for entries which are past
  end of table
+ rearrange opsTable to put most routines without asm versions at end, remove
  as many at end as possible
+ change FCore to just have a pointer to opTypesTable instead of the whole table
  in the structure
+ currently assembler version of opTypesTable uses badOp for all optypes for
  which there is no assember version, replace this with something that invokes
  the C version instead - if the optype is truly unimplemented, the C version
  will signal the error
  -> until this is fixed, all optypes must have an assembler version...
+ take advantage of the fact that ESI register is no longer reserved for opsTable

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 27 2009

I started putting in support for builtin classes, then I realized I hadn't
put stuff in CVS in a while

Right now when switching in and out of turbo mode the opType dispatch table
and builtinOps tables in the forth core are re-initialized - I think it would
be better to have copies of asm and c versions of the tables in the core
that were initialized once.

+ get stuff to compile with partially done builtin class support
+ bring CVS up to date
x have asm and c modes use separate tables in forth core
+ replace the extOp macro with a single asm routine that grabs the c routine
  address from the c builtinOps table
? maybe move the majority of c-only ops to the end of the builtinOps table
  and allow the size of the asm table to be smaller
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 26 2009

More fiddling with dynamic dialog creation.

There is a fair amount of functionality in the CWnd class that would be useful
to have available to derived controls - setting position, label text, styles
and so on.  The most convenient thing to do would probably to define a set of
forth classes corresponding to CWnd and the derived controls.  This would
require creating built-in classes, something I haven't done yet.

While working on ForthEngine::AddBuiltinClass I noticed that overwriting a
method probably adds a redundant symbol to its class.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 24 2009

+ Fixed boundary cases for assembler comparison ops - this should fix "dump".

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 21 2009

Started fiddling with dynamic dialog creation.

Some simple controls could be handled by just adding a OnCmdMsg handler to the
top level generic dialog.

----------
Step 1 - Static text control
CStatic* pStatic = new CStatic;
pStatic->Create( "some text",
                 WS_CHILD | WS_VISIBLE | SS_CENTER,
                 CRect(10,100,100,130),
                 pDialogWnd,
                 controlId );

----------
Step 2 - Pushbuttons
CButton* pButton = new CButton;
pButton->Create( "button text",
                 WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                 CRect(10,100,100,130),
                 pDialogWnd,
                 controlId );
pButton->SetWindowText( "Woohoo!" );
Other button types:
	BS_PUSHBUTTON
	BS_RADIOBUTTON
	BS_AUTO3STATE
	BS_AUTOCHECKBOX
	BS_AUTORADIOBUTTON
	BS_CHECKBOX
	BS_RADIOBUTTON
	BS_3STATE 

I'm not sure what would be involved with doing radio buttons in terms of
grouping them.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17 2009

Need a way for a class to return secondary interfaces...
- implement a generic queryInterface class method
- require individual classes to implement explicit "getInterfaceX" methods

Inside secondary interface methods, how can methods from other interfaces be
accessed?  Possible approaches:

1) they can't - that is what is currently implemented - you could still do it
   manually by creating local objects with the appropriate methods/data pair

2) concatenate all interface vtables, the method number is relative
   to current interface, negative values and numbers larger than the current
   interface method count would refer to methods in other interfaces of this
   class - actually, you would only need negatives, since you could only refer
   to methods defined in previously defined interfaces
   -> that would require that all the methods for each interface are specified
      in one shot - you couldn't define some primary interface methods, then
      implement a secondary interface, then add some more primary interface methods

3) when a cross-interface method is compiled, it is compiled as code which pushes
   the object pointer pair for the target interface and then uses the MethodWithTOS
   opcode type to invoke the method
   
I decided to try out the assembler again, I found that it works, there is a
problem where some ops leave crap on stack when they are done - in particular,
the "next," op leaves 2 zeroes.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 16 2009

Methods returning an object as a non-final selector works...

Stuff to do:
- class/struct support
  - "implements" & "queryInterface"
  - class methods - new/delete/queryInterface/show/
  ? have all classes derive from a base "object" class
  - struct accessor optimizer
- testing
  - more tests of datatypes: locals, structs, classes
  - more automated tests of core forth stuff
- sample block ops
- GUI app support
- assembler documentation and test

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 14 2009

Been off doing other things...
Starting debugging methods which aren't final selectors - I really still need
to define how methods as final selectors work, in particular if the return
value is an array - should I be compiling an array accessor, and should it
use varAction?
o if you want to have varAction work on data inside an object, use an object
  data member as an accessor, not a method
o you can have methods use varAction if you want to code it that way
o when final selector is a method, do nothing about method return type
  ? it feels inconsistent/broken to allow array indexing to be done on non-final
    selectors but not on final selectors...
o a non-final method selector whose base type is byte/short/int/float/double is illegal
! maybe the right choice is to only allow "returns" to take a struct/class type,
  with no ptrTo or arrayOf modifiers.  This is actually the most flexible choice,
  since the method could take an index argument if an array is involved
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 7 2009

+ made turbo versions of most of the file operations

+ made turbo versions of doExitMOp and doExitMLOp - the rstack underflow
  checking doesn't seem to be working, though
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 5 2009

Try loading foo.txt in non-turbo mode, switch to turbo, then do "addressOf kk kookoo",
switch back to non-turbo and repeat - the namb and numb fields of kk were modified
by reading or printing them from turbo mode...

-> the problem was that the turbo version of dfetch was badly broken

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 3 2009

Bugfixing struct and class stuff.

An unrelated bug: if you do "dump" in turbo mode, it displays a different
number of rows of output - it looks like there is one extra row, as long as
the last expected row...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 2 2009

Ugh, my graphics card died yesterday, killing a day.

There is a memory trash bug, it is triggered by LocalIntArray, but I think it
is because the opVal coming in is 0x2004, when it should probably be 4.
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 28 2009

The basic class support seems to be working - I haven't tested many combinations
of member accessors, but I can access members of local and global objects,
including arrays and pointers, and I can invoke methods on objects.

There are crashes running class stuff in turbo mode.

One thing I don't think I implemented is allowing field accessors or methods
on member variables.

I added "returns" op, it doesn't work at the moment.

If you start forth, run structtest.txt, then do "bye", there is a crash
while trying to delete the parameter stack of the current thread.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 27 2009

First field code for object accessors:

+ gobj1.blah					global object
	gobj1			doObject drop
+ pgobj1.blah					global ptrTo object
	gobj1			doInt d@ drop
+ 1 gaobj1.blah					global object array
	gaobj1			doObjectArray drop
+ 1 gapobj1.blah				global ptrTo object array
	gapobj1			doIntArray d@ drop

+ lobj1.blah					local object
					LocalObject drop
+ plobj1.blah					global ptrTo object
	gobj1			LocalInt d@ drop
+ 1 laobj1.blah					local object array
	laobj1			LocalObjectArray drop
+ 1 lapobj1.blah				local ptrTo object array
	lapobj1			LocalIntArray d@ drop

Most of the broken ones are pointer types - they are all missing the d@.

If we implemented an opcode which added an offset to TOS and then did a fetch,
that could replace the "d@ drop", and could also be useful in struct accessors
whenever a pointer field was used - these usually compile into (offset(N), @).
-> But you don't know if you should use offsetFetch until you process the next
   field, since if it is a method you need both pointers on TOS
   -> There should be a final optimization step
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 26 2009

There is a problem with local and global ptrTo array implementation - an intArray
is used, and the intArray will use the varAction which is meant for the field code...
For example:
	5 -> 4 pFoo.A
compiles into
	lit 5
	->
	lit 4
	_doIntArray(pFoo)
	FieldInt(A)
and the varAction set by "->" is used by _doIntArray, not FieldInt.  The code
which compiles field accesses does handle the case where the varAction symbol
is just before the field accessor, but in array access cases the array index
calculating op(s) are usually just before the field accessor.

There is also a general problem with the varAction being consumed accidentally
if there are any variables used in calculating the array index.
The general (ugly) solution to this problem is to require that the varAction
op be placed just before the field accessor:
	"5 -> 4 pFoo.A"		is replaced with	"5 4 -> pFoo.A"

A better workaround might be to use parens:
	5 ->( 4 ) pFoo.A
This looks silly in this case, but might help with cases where the index
calculation uses variables...


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 25 2009

+ added "lsize" - number of longwords in local variables
+ added "dlocals" - displays local variables

Ran into some crashes while testing class support, writing tests to check both
struct and class support.
-> all local arrays were allocating 0 bytes because ForthEngine::SetArraySize
   wasn't being called before calling ForthEngine::AddLocalVar and ForthEngine::AddLocalArray
   
First field code for struct accessors:
+ gstr1.blah					global struct
	gstr1			doStruct
+ pgstr1.blah					global ptrTo struct
	pgstr1			doInt
+ 1 gastr1.blah					global struct array
	gastr1			doStructArray
+ 1 gapstr1.blah				global ptrTo struct array
	gapstr1			doIntArray
	
+ lstr1.blah					local struct
	lstr1			LocalRef
+ plstr1.blah					local ptrTo struct
	plstr1			LocalInt
+ 1 lastr1.blah					local struct array
	lastr1			LocalStructArray
+ 1 lapstr1.blah				local ptrTo struct array
	lapstr1			LocalIntArray
	
Here is what the rstack should look like when local variables are defined:

ok> : woo hex drstack int aa int bb int cc drstack 5 -> aa 7 -> bb 9 -> cc drstack ;
ok> woo
rstack: 12f844
rstack: 1 3 7 0 12f844
rstack: 9 7 5 0 12f844
The top 3 elements are the 3 local int variables, next is the old frame pointer,
and last is the return IP from woo.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 24 2009

? does the current structure support properly handle the case where the first
  field of an accessor is a pointer to a struct?

Ugh, some of the code assumes object variables have the native flag set,
other parts of the code require that object variables have the native flag
clear...

Why didn't I just have a typeCode bit for "array" - why is there a 2-bit
storage type field with choices none/single/array/illegal?  What does it mean
to have a storage type of none?
-> "none" had been used by enum opcodes to help with a problem with forgetting
   enums, but that had been made obsolete a while ago

I changed the typeCode around to have:
o bottom 4 bits are baseType
  o baseType are the old native types, plus struct
    o object is a baseType, but it is no longer a native
o isArray is a separate bit, there is no idea of single/none/illegal
o the top 24 bits is the stringLen/structIndex/classIndex
? Are there any changes needed in the assembler code, or is all the typeCode
  stuff always handled by the outer interpreter or C++ only code?

The field accessor stuff will need to be changed, some of it is still treating
object fields as native...

o changed ForthStructsManager to ForthTypesManager
o changed ForthStructInfo to ForthTypeInfo
o changed most uses of Native to BaseType

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 23 2009

The existing struct support handles struct accessors in 3 stages:
1) the first token, either a local or global struct (or pointer)
  -> compile opcode which pushes the address of base of struct
2) intermediate accessors
  -> compile opcodes which add offsets to TOS, or do an indirection on TOS
     for fields which are pointers
3) the final field
  -> compile fieldAction opcode based on the type of field

Things get a little messier with classes, because:
o an object field is automatically a pointer access, a ptrTo object field
  requires a double dereferencing
o a field which is an object needs to be processed differently depending on
  wether the next accessor designates a method or a member field - a method
  will require both pointers, a member will just need one of the pointers
  
Class support status:

-------
- objG.methodB						method invocation on global object objG
	objG
	OP( methodWithTOS, B )
+ methodB							method invocation on current object within method
	OP( methodWithThis, B )
- objA.methodB						method invocation on other local object
	OP( localObject, A )
	OP( methodWithTOS, B )
- objD.methodB						method invocation on other member object
	OP( memberObject, D )
	OP( methodWithTOS, B )
- stuff.objQ.methodB
	...stuff leaving addr of objQ on TOS...
	d@
	OP( methodWithTOS, B )

+ fieldC							member access within method
	OP( memberInt, C )
- objA.fieldC						(objA is local within method)
	OP( localObject, A )
	drop
	OP( fieldInt, C )
- objD.fieldC						(objD is a member variable)
	OP( memberObject, D )
	drop
	OP( fieldInt, C )
- objG.fieldC
-------
Member access and methods outside a method:
- objL.methodB						(objL is a local object)
- objL.fieldC

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 22 2009

+ Some class support is working, I can invoke methods using doMethod, the right
  vtable opcode is executed, stacks look after it is done.
+ "extends" works for classes
- currently member fields don't work in classes

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 21 2009

The next step for class support is to create "new", possible approaches:

1 - new sets a varAction
=========================
Syntax is "new blah"
o blah must be next opcode executed
o a struct/class defining word like blah is immediate, so it can define local
  instances while compiling.  doStructTypeOp/doClassTypeOp would need to be
  modified when compiling to check if the preceeding compiled op was a
  varAction setting op, and if so just compile appropriate code.
  doClassTypeOp:
  if ( state is compile )
    // either defining a local instance, or "new blah"
    if previously compiled op is a valid varAction (IE "new")
      compile blahOp (how do I know blahOp?)
    else
      DefineInstance of blah
    endif
  else
    if varAction is valid
      
    else
      DefineInstance of blah
    endif
  endif
  
  The code to be compiled can't just be the blah opcode - when it is
  executed, 
  ? what is the appropriate code

2 - new is an immediate op
==========================
Syntax is "new blah"
o blah must be next immediate token, on same line
o new grabs next token, and interprets or compiles appropriate code
o the code compiled would be:
  doNewClassOp
  <pointer to class vocab>
  ? what is the appropriate code

3 - struct manager ProcessSymbol handles new
============================================
Syntax is "blah.new"
o stuct manager ProcessSymbol recognizes blah as a class name and new
  as a special token and interprets/compiles appropriate code
  ? what is the appropriate code

In all these cases, we are stuck with the question of what should be
compiled - it can't be the blah opcode.

The minimalist in me thinks that a varAction approach is best, but varAction is
a kludge:
o varActions look like local operations, but use globals
o varActions break making methods be part of a struct accessor chain
o a varAction could be applied to the wrong object/variable
  o the same varAction value means different things for different datatypes
Also, struct/class type ops are currently defining words which eat the
next simple token, and they have precedence

- "sizeOf" and "offsetOf" will only work in interpret mode
  ? change these into varActions too
  
Currently varAction ops are implemented with non-precedence ops, should I
change them to precedence ops?
-> No, I don't think it would really fix the general varAction problems

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 18 2009

+ changed ShowVocab to use ForthVocabulary::PrintEntry

+ Changed "describe" to display the symbols of struct or class vocabularies

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 17 2009

I debugged a bunch of the simple problems with struct support.
	point p
	ptrTo point pp
	5 -> pp.x
The above currently has an exception because it compiles into:
  5 -> pp fieldInt(x)
which results in 5 being stored into pp, leaving the stack empty, then
the fieldInt(x) call tries to get the struct base address from TOS, adds
the offset of x, and then dereferences the bogus result address since
the store varaction was cleared when pp was executed.

----
How can we differentiate between setting the pointer and setting a field in
the struct the pointer references?

A structure/object accessor has the syntax
	start.end
or	start.middle.end	where middle can be many dotted ops

o start always compiles into an opcode which pushes the base address of the data
o end always compiles into an opcode which will actually affect the data, and
  which pays attention to the current varAction
o middle is a series of ops which can:
  o add an offset to TOS
  o do a fetch - replace TOS with the address it points to
  o do an array address calculation: replace a base address and index with the
    address of the indexed element
  o (someday) execute a method with a known return type
If the opcode compiled for start is a pointer var op, it can mistakenly
use the varAction which is intended for the end op.  Also, when methods
can be in the middle ops, the methods could interfere with the varAction.
On a different note, there is a potential optimization for local structs,
where the start op, middle ops and end op are combined into a single op which
is the same as a local variable op.
---

When compiling a field reference using a global pointer, look at the opcode
just previously compiled to see if it is one of (addressOf -> ->+ ->-) and if
so, swap the order of the previous opcode and the global pointer opcode.
But what if this is interpret mode? I guess in interpret mode we could save
the varAction at the start of processSymbol, clear the varAction, and compile
the appropriate varAction op after the first field opcode.

Actually, are there any ops other than the final op which use the varAction?
Not now, but when methods can be in the middle of an accessor chain, those
methods are very likely to internally modify the varAction

The first op compiled in a field accessor is always one of:
o global struct op - just leaves base address on TOS
o global ptr op - leaves ptr contents on TOS
o local struct op - just leaves base address on TOS
o local ptr op - leaves ptr contents on TOS
-> I overwrote the previously compiled varAction op with the first op of the
   field accessor code, and put the varAction op in the first element of
   the field accessor codes, it appears to work fine

I haven't tried complicated accessors where there is more than one level of
indirection.

+ I added "comparefiles" to forth_autoload.txt.

+ Added automated test file autotest.txt, which runs forthtest.txt in
  both slow and turbo mode and compares the output of both against output
  from a known good run
  
Maybe there should be a varAction-setting opcode type...
That would require that the varAction setting opcodes in the kernel be in
their own list.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 16 2009

I started cleaning up the native type support in ForthInner, making them all
do varOp range checking and use a common code style.

When doing "op" I noticed that the old IP gets stomped, and when you execute
a local or global op var it causes an unwanted return
-> these problems don't happen in turbo mode
DOH! the problem was that it was building a 2 op program, the 2nd op was OP_DONE,
and setting this flag makes the inner interpreter exit - I changed this to
use ForthEngine::ExecuteOneOp, which handles this problem.

+ if you use tick inside a colon definition, that definition shows up in the
  vlist, but if you try to interpret, it causes an undefined symbol error
-> I was misusing tick, it doesn't have precedence, I should have used ['] or lit

OP_DO_CLASS_TYPE is the first and only op in a class defining word, it is
followed by a pointer to the class vocabulary.
doClassTypeOp just calls pClassVocab->DefineInstance() and pops the return stack.
DefineInstance will create an object instance of the class type, which could
mean any of:
o creating a global or local variable/array
o adding an object or object array field to a struct or class definition
Global instances have their vtable and data pointers initialized.
OP_DO_OBJECT is the first and only op in an object instance word.

- "ptrTo" doesn't work with global structs
It looks like ptrTo just changes a var/field to act like a dumb int var

+ structs can't be used as local variables because the ops defined by "struct:"
  don't have precedence, so they are compiled and not interpreted at local var
  definition time...
-> fixed

I need to do more testing, documenting and debugging of existing struct
support before I can advance on class support.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 15 2009

What happens at the start of invocation of a method?
The pushing of this on the rstack can't happen inside the method, since the
code which invokes the method must have already overwritten the this pointer.

Let's assume that the 64-bit object is on TOS already, and the current opcode
is a "method-on-TOS" opcode with method field equal to 5.
Pseudocode for "method-on-TOS":
	rpush TP (2 longs)
	pop TP (2 longs)
	fetch opcode for 5th entry in vtable specified by TP & execute
	

NOTE: doExitMOp and doExitMLOp currently are using a single 32-bit field for
the this pointer - that will have to become 2 fields, right?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 14 2009

+ added strdate, strtime which return current date and time as strings
+ added millitime which returns # milliseconds since forth was started

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 13 2009

+ rewrote systemOp to use stdout/stderr redirection, this should allow it to
  work in ForthGUI
-> it does work, but there is a flash of black when the shell runs...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 12 2009

Chasing the "%c" problem in turbo release mode.  To debug in release mode,
create time wasting user op that takes several seconds to run, pause the
program, chances you will be able to find your way into the inner interpreter
loop pretty quickly.  After that just set breakpoints in the dissassembly
window and look at registers.
After printCharOp returns, the top item on the stack should be the saved EBP
pointer to the forth core, instead that entry has been overwritten by the
characters of the string to be written.  The pushing of EBP was done both to
preserve it and to pass it to the C routine about to be called, in release
mode the compiler feels free to reuse the stack storage of its input params
for other uses, in this case as the character buffer to be printed.  The
solution is to push EBP twice.
This change fixed %c/%bl/%nl as well as vlist in turbo release mode.
Output from forthtest.txt looks ok in all modes now.

Idea for syntax for using TOS as a struct address or object: 
classA.method1
structB.field2

One problem with the current scheme for interfaces, where any class can be
used as an interface, is that it makes it less safe to have classes which
have public fields - the programmer is responsible for keeping track if an
object variable of class blah is:
1) referencing an object which is derived from class blah, in which case it
   is okay to access member fields for class blah
2) referencing an object which is not derived from class blah, but which
   implements the blah interface, in which case it is not okay to access
   any member fields
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 11 2009

Added a "is method" bit to the type code field (pEntry[1]) for struct vocab
symbols.  In the future this will allow the existing bits of the type code
to indicate the return value for the method, so that methods don't have to
terminate a structure accessor string.

Also added a new native type, kBaseTypeObject, which will be a 64-bit field.
When I was putting it in, I found that the global array ops had never
been used, at least in non-turbo mode - their optable entries held the
ops for single variables.

Also, before I made my changes I noticed that running release in turbo mode,
there is an unhandled exception which happens when you do "vlist".
In debug mode, vlist is okay but any immediate op has a "bad opcode"
error.

-> it looks like the assembler version never could have handled immediate
   builtin ops - did the handling of precedence change after the assembler
   version of the nucleus was written?  -> yup!
There was a similar problem with immediate user defined ops, I just made
them use the same table entry as non-immediate user define ops, and I did
the same with "user code" immediate ops, but I haven't tested those yet.

Debug version in turbo mode now runs forthest.txt with no errors and what
looks like valid output.

Release version in turbo mode still breaks on vlist and fails pretty quickly
when loading forthtest.txt
-> %c, %nl, %bl cause a "No Error" failure!  They do display the character
  %nl and %bl just push a char and call %c, %c just build a two char string
  and calls %s, so why does %s work and these other ops fail?
? What does a "No Error" failure mean?
-> the exit status from InnerInterpreterFast is something other than kResultOk
   or kResultDone, but core->error was not set to an error code
The character is always printed correctly.
The problem goes away if I change printCharOp to either use a larger character
buffer or if I remove the SPOP that copies the character from the stack to
the first byte of the buffer.
The problem does not go away if I redirect output to a file.

All of this really emphasizes the need for an automated test suite - changes I
have made in the distant past have broken things, and I have no idea what
change broke what feature.  DOH!

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 10 2009

Decided to tackle a couple of problems using forth, to see what it needs to
solve real problems.  The problems were:

1) merge two equal sized files, which have missing data (zeroes), which come
   from different torrents (rock band .flac file collections)
   mergefiles.txt & mergeall.txt
2) merge guitar pro song collections - there are multiple versions of many songs,
   and the files in different collections sometimes have the same names and
   versions
   gp.txt & narf.txt

Overall, it worked out pretty well.  The main thing that stood out is that I
need to spend some time documenting the functionality that is already implemented.

One missing thing is the ability to iterate over all files in a directory tree,
I got around this by creating a list of files using the cygwin shell and then
turning the list of files into forth files.

Dropped off Xbox-360 today at UPS to fix red-ring-of-death.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 9 2009

+ changed struct/endstruct/enum/endenum to struct:/;struct/enum:/;enum

+ got incomplete class definition time stuff to compile

- there are no examples of "union" - has it ever been tested?
-> test & document its usage

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 7 2009

The ways an interface gets defined:

o the primary interface is defined two ways:
	1) when the "extends" clause is processed, the methods of the defining
	   class are copied
	2) when a method is defined, it either replaces an existing method or is
	   added as new
o secondary interfaces are defined:
	1) when the "extends" clause is processed, the secondary interfaces of
	   the defining class are copied
	2) when the implements clause is processed, if the named interface does
	   not already exist, the new interface is initialized to have the same
	   number of methods as the named interface, and all of the methods are
	   marked as virtual and filled in with a dummy (error) method
	3) when a method is defined inside an implements clause, it replaces the 
	   named method in the interface
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 4 2009

A problem with methods and also struct op fields is that there is no concept of
a return type, so they can't be followed by a dot accessor: objectA.methodZ.fieldQ
doesn't work because we don't know the struct type returned by methodZ, so we
don't know the struct vocab to lookup fieldQ.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 3 2009

One potential gotcha with just extending struct stuff to do classes: the struct
stuff currently does allow structs to be allocated as globals or on the stack.
? Is this really a problem?
We should probably leave structs as is, it would be a pain to have them always
have a dummy vtable on TOS.

Classes should be able to extend a struct, but should a struct be able to
extend a class?  If so, it should just be taking the data members.

When a local class variable is declared, should code be generated to set its vtable?
It would be redundant, except in cases where you only set the dataAddress part of
an object variable.  In those cases the vtable would have to be explicitly
initialized.

Base methods are methods which every class implements, these are methods
in class Object.

-> make a list of class methods and base methods
class.new			...		dataAddress methodsAddress
	this should be an opcode type
struct.sizeof		...		sizeofStructInstance
class.sizeof		...		sizeofClassInstance
object.sizeof		...		sizeofObject
	this should be an opcode type, or be compiled as a constant
class.methods		...		methodsAddress
object.methods		...		methodsAddress
class.numMethods	...		numberOfMethods
object.numMethods	...		numberOfMethods
object.class		...		classDescriptor
	? what should the classDescriptor be?
		1) the struct index
		2) address of something
	what can you do with a class_descriptor? is there a class class?
object.delete
class.parent
object.print
object.queryInterface

? should base methods have a single vtable entry
Note: object.methods could either be:
1) at runtime, fetch the methods field from objects
2) fetch the methods field from the declared class of object (which might be
   a superclass of the actual class of object
We probably want object.methods to fetch the actual object methods field, and
have class.methods be used to fetch the methods field of class
Maybe there are 2 predefined classes at startup, "object" and "class", with
"class" derived from "object".

object methods: delete class methods data sizeof print
class methods: new sizeof methods name parent
Ugh - class.methods doesn't returns the vtable of the class object, it returns
the vtable of objects of its class...
Maybe it should be called "vtable"?  This is bound to cause bugs...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 1 2009

Is there any reason to create a ForthClassVocabulary and manager instead of
just expanding the ForthStruct stuff by adding methods?

Every class defines:
1) an interface
2) a data structure
The interface may be empty, in which case this is an old-fashioned struct.
The data structure may be empty, in which case this is an abstract interface.

How do extends/implements work and interact?
Maybe only the primary interface can extend another class, "implements" means
that this class implements the exact interface of an existing class as a
secondary interface.
When a class extends another class:
o it inherits its implementation
o it inherits any interfaces that it implements, but it may override any or all of the
  implementations of those methods.
When a class implements the interface of another class:
o it does not inherit any implementation from that class
o it does not automatically implement interfaces that the base class implemented

What changes are needed to ForthStructVocabulary?
- add method count
- add abstract method count
- add ?list? of interfaces

Should class methods be assigned normal opcodes, and the vtable contain opcodes,
or should the vtable just hold IP addresses?
Is there a need to have class methods be native opcodes?
o this might help implement classes which are defined in the kernel
o this might be useful when calling a method from another method in the same class
-> make vtables hold opcodes instead of IP addresses

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 31 2009

A class has a primary interface, which is the set of methods which it declares.
A class may have secondary interfaces, which can be gotten by querying.

When a class doesn't have distinct methods of its own, and just implements a
previously defined interface, will that pose a problem?  IE how can the primary
interface for a class be defined using the "implements" keyword ?
-> the endclass word will handle this when the primary interface has 0 methods

When you extend a class which has secondary interfaces, can you override or
extend the secondary interfaces?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 30 2009

What about making all object references be a pair of pointers, a data pointer
and a vtable pointer?  What would this look like?
+ this would allow a simple implementation of multiple interfaces
+ arrays would not need a redundant vtable field per element
o object variables are just a pointer pair
o object reference on TOS is a pointer pair (not a pointer to a pointer pair)
o "this" in thread context is a pointer pair

Maybe all interface definitions which don't have an "extends" statement implicitly
extend the interface "object".

Maybe a class definition could be like:

interface blather1
  talk
  ramble
endinterface

interface blather2
  extends blather1
  spew
endinterface

struct sBlatherer
	...
endstruct

class blahBlah blather2 sBlatherer
 ... method definitions for
-> having "extends" at the class level would make implementation easier
-> "extends" should be available in both class and interface definitions
-> it probably is better to have the class define its data members, instead of
   requiring that its data members be defined in a seperate struct
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 18 2008

More ForthGUI work.

Noticed that the line:   "dir" system
produced no output - the problem is that the directory was sent to standard out
for the console.
? Is there a way to redirect standard out to a function ?
SetStdHandle can be used to redirect standard in/out/error.
? Is there a way to connect a handle to a function
! The easiest thing to do might be to redirect output to a temp file
  inside the "system" op, then after interpreting the string write the output
  to the thread output routine

Also "load" does not do anything.
-> The forth console app calls shell::Run, which has a loop that keeps calling
   GetLine and interpreting it, this is what does the loading.  The forth
   GUI app doesn't call shell::Run or shell::GetLine, it interprets the edit
   buffer when the edit control OnOK handler is triggered.
   Maybe the solution would be for the GUI app to check the input stack depth
   after interpreting a line, and keep doing GetLine/interpret until the input stack reaches zero.

I added the above code to ForthGUI.  forthtest.txt has an error in it, and this
was causing a crash.  I tried to fix it by adding methods to create and delete
all the forth related objects, and these were called when InterpretLine returned
a fatal error result code.  This is currently failing because the engine constructor
saves its this pointer to a global instance pointer, and it asserts if that pointer
is already not null.
At some point I decided to treat the engine as a singleton, and for some
reason I changed the GET_ENGINE macro to use the singleton, but most cases
where it is used the code already has access to the engine, for example forthops
can get the engine from the forth core state.
For now, I am just clearing the engine global instance pointer inside the engine
destructor.  I also had to do this in the ForthTypesManager, which also used
a singleton.
I think the idea was that there should only ever be one engine object.

I get a fatal error when I load sdl.txt, then sdl2.txt, and run "test".

ForthShell::Run
  ForthShell::InterpretLine
    ForthEngine::ParseToken
    ForthEngine::ProcessToken

ForthShell::Run
	calls ForthShell::InterpretLine in a loop until it returns false

ForthShell::InterpretLine
	calls ForthShell::ParseToken and ForthEngine::ProcessToken in a loop until input line is empty
		
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2008

ForthGui program now mostly works
- "bye" does not exit program
- there is no error output
  -> look at ForthShell::ReportError
  -> fixed
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2008

+ added resetting of console output routine, so app can set default output routine
+ tried to make output more simple/unified by combining user data pointer and
  file pointer
  
It might be nice to have a way of pushing/popping an output context.  There
are 3 overall types of output context, here are their data:
1) external function
  - function address
  - function data address
2) file
  - file pointer
3) user op
  - opcode
  - data address

One way to unify these would be to have an output context structure:
	void*	function address
	void*	data address
	long	opcode

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 19 2008

+ added appending to GUI output pane

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 23 2007

Haven't been working on forth since June.  I did add to help.txt.
Going to to try to:
1) add a string->long map feature, use it for help
2) maybe get the Forth GUI working.

The only problem with a map is that it would make a "save state" feature
much more complicated
-> make the map output be offsets from the DP, not absolute pointers
-> come up with a general solution for dynamic data

If I remember correctly, the hangup with doing the GUI was not knowing how to
incrementally get text output to the edit output pane, I only know how to fill
the whole edit pane at creation.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 13 2007

Not much progress over the last month:
- I took a quick look at class support, no amazing revelations occured
- I started creating the GUI for a programmable calculator
The projects I would like to wack on this summer:
- programmable calculator
- synth2k
- graphics sandbox
  ? based on sdl, or win32 ?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 6 2007

I tried adding a lookup map to vocabularies to speedup loading.  Right now
it is ifded-ed out with MAP_LOOKUP.  It seems to be unnecessary, since in
the release version loading the pentium assembler is instantaneous.  The
slowness of loading in the debug version is probably mostly caused by all
the TRACE message output together with the slowness of debug code.

Removed "code" setting of top search vocab to "assembler".  With this gone,
there was no reason to have "assembler" vocab in kernel anymore, so I removed
it and added it to asm_pentium.txt.

Added a serial number to vocab stack searches to eliminate redundant failed
searches of the same vocabulary.  It worked for everything until I tested
sdl2.txt, and it looks like it failed the first time it tried to lookup
an enumerated type.
-> false alarm, sdl2.txt just wasn't adding sdl to the search order
? maybe make vocabulary stack always have at least 2 entries, and the
  bottom entry is always forth?
  
When this works I should rip out the vocabulary search chain since it is
no longer used.
-> No, the search chain is still used, but only by the structs vocabulary.
-> Move the search chain down to the structs vocabulary
  -> I should probably create a chained vocabulary type, since classes will
     probably want to be able to extend another class, like structs
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 5 2007

Added fprintf/sprintf/fscanf/sscanf - they work except that fprintf/sprintf
can't print floating point numbers - there may be some expectation that
fp numbers will be passed in fp registers, but that would seem to be a
pain for variable numbers of arguments.
One hokey thing is that you have to pass the number of variables to be
printed as the last argument.
Example: stdout "%d,%d" 5 7 2 fprintf

Eliminated precedence vocabulary - it didn't work well with the vocabulary
stack.

Starting debug of pentium assembler.

source:
	code andy dx ) ax mov,  4 # dx add, ax dx ) and, next,
generated:
	011842F8  mov         eax,edx 
	011842FA  add         edx,4 
	011842FD  and         edx,eax 
	011842FF  jmp         edi  
should have generated:
	mov	eax, [edx]
	add	edx, 4
	and	[edx], eax
	jmp	edi

-> The ")" op is never being executed - it may be getting eaten by the shell
-> changed all uses of ")" to "]"
	code andy dx ] ax mov,  4 # dx add, ax dx ] and, next,

Assembler is now generating the correct code for "andy", and the op performs
correctly with both fast & slow interpreters.

DLL support was broken, because it relied on the op for a vocab to push
its address on TOS.

I'm changing vocabularies to act like variables, where a prefix op is used
to set the operation the vocabulary will do when invoked.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 4 2007

Working on switching over to the ans forth vocabulary stack.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 3 2007

Updated CVS.

The GForth assembler is ported, it loads but it is untested.
The GForth package doesn't seem to have any examples of its usage in actual
code, but the assembler is almost identical to the assembler in BigForth,
maybe it has some examples.  The file gforth.050/doc/gforth.i9 has a
"386 Assembler" section which spells out the syntax.

One problem area was that GForth is not case sensitive.

Another was that there was a partially implemented relocation scheme which
remapped forth builtin ops which compile stuff or manipulate the DP to a set of
proxy ops which mostly did exactly the same thing - presumably this was
preparation for swapping out the proxy ops for another set which did something
like assembling to an address offset from the intended run address.

One odd thing was that "," was remapped to "c,", and it looked like "," was
being used to compile byte data, not longs.  Perhaps the intent was that in
the source for the assembler, "," was used to compile stuff that needed to
be relocated and "c," was used to compile stuff that didn't.

The next step would be to create a way to make a user-defined op in
assembler.  This could be tricky, especially if we want the fast inner
interpreter to be able to execute these ops without passing them off to
the slow inner assembler.
-> The user defined code ops would be setup to work with the fast interpreter,
   and create a piece of glue code which the slow interpreter uses to execute
   user defined code ops
   -> We could also use this for builtinOps which have no C++ version (with a small mod)
User defined code ops should live in userOps dispatch table, and therefore
share the opValue space of other user defined ops, which will make "forget"
easy to implement for them.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 30 2007

Working on adapting the GForth assembler

: within  ( u1 u2 u3 -- f )
 over - >r - r> u< ;

: t5a 5 -5 within . ;  ok
: t5b -5 5 within . ;  ok

-6 t5a -1  ok
-5 t5a 0  ok
4 t5a 0  ok
5 t5a -1  ok

-6 t5b 0  ok
-5 t5b -1  ok
4 t5b -1  ok
5 t5b 0  ok

With arguments in low,high order result is true for numbers between low & high-1
With arguments in high,low order result is false for numbers between low & high-1

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 28 2007

Initial debug of new DLL support - it works!

Integrated with old CVS system

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 26 2007

Wrote the assembly side of support for DLL via a special opcode type.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 25 2007

+ look at usage of CompileLong versus CompileOpcode
  -> replaced CompileLong with CompileOpcode where appropriate

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 24 2007

+ see if initialization of local strings works, it might not since it looks like this:
  -> 100 string myName
  The "100" compiles into a constant op, which is then removed by "string", but it
  might make string ignore the "->" and not do the initialization...
  -> added mpLastIntoOpcode to engine, to track last "->" compiled in
     current definition
     
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2007

I moved the replacement of kResultDone with kResultOk into ForthEngine::ExecuteOps.
This centralizes the fix for ops which execute an op variable from exiting
the inner interpreter prematurely.
There is one drawback to fixing this bug, it could make the "done" op useless
except as an internal to the outer interpreter.

+ if "->" has been executed before a native global or local variable declaration,
  initialize the new variable from TOS
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2007

The current state of forth output:

ops which produce output invoke CONSOLE_STRING_OUT, passing a core ptr & a char buffer ptr
CONSOLE_STRING_OUT is defined as: pCore->pThread->consoleOut( A, B )
consoleOut is set by the SET_CON_OUT_ROUTINE macro.

outToScreenOp
  sets consoleOut = consoleOutToFile
  sets output file = stdout

outToFileOp
  sets consoleOut = consoleOutToFile
  sets output file = file on TOS

outToStringOp
  sets consoleOut = consoleOutToString
  sets output file = NULL
  sets output string = string ptr on TOS

outToOpOp
  sets consoleOut = consoleOutToOp
  sets consoleOutOp = TOS

SET_CON_OUT_FILE( FILE_POINTER )
SET_CON_OUT_ROUTINE( OUTPUT_ROUTINE )
SET_CON_OUT_STRING( A )
SET_CON_OUT_OP( OUTPUT_OP )

consoleOutToString just appends the string to the end of the buffer, it should
be changed to use the string current length & max length fields.

Got outToOp working, but found an apparent bug in local variables - if I
define a local pointer variable with "ptrTo byte" I get an exception when
it tries to print what is at that address, but it works if I change that
variable to be "int".
-> the local variable defining code was ignoring the "isPointer" flag.

There is still a bug in the output code - if you use a user-defined op,
any output generating op will end the execution of a calling op.
It almost looks like the "done" flag is being set.
-> duhh, yeah, since consoleOutToOp calls ForthEngine::ExecuteOneOp,
   that does a "done" after executing the output op...
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 21 2007

One way to improve DLL support would be to dedicate an opcode to DLL calls.
The address of the DLL entry point would be held in the user defined op
dispatch table.  The op value field would hold 2 things:
1) the dispatch table index
2) the number of arguments the op takes
As mentioned yesterday, Each DLL would have a dedicated vocabulary.

+ fixed a bug in structure support - any forget was wiping out all structs,
  because it was comparing the forgotten op's value field to the structs
  entire opcode

+ added extends, sizeOf and addressOf

+ add "union" to structure definitions

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 20 2007

The SDL_LoadBMP exception happened because SDL_LoadBMP isn't one of the DLLs
exports - the real export is SDL_LoadBMP_RW.  The defining words for DLL
interface words should check for getProcAddress returning NULL.

Maybe we should create a special type of vocabulary for DLLs, where the
vocabulary would know the path to the DLL and its symbols would be the
DLLs entry points - this would allow saving the forth state and restoring
the DLL linkage on coldstart.

Before you call a C routine you push arguments right-to-left, so the first
argument is on top of the stack (lowest memory address).  When we call a
DLL routine, we push arguments left-to-right, so the last argument is on
top of the stack.  This forces us to have to copy between the parameter
stack and the PC stack to reverse the order.  If that wasn't the case we
could do a trick in assembler where we just set the PC stack pointer to the
parameter stack before the DLL call.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 19 2007

Tried to implement SDL dll interface - got an exception in SDL_LoadBMP

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 16 2007

I took the 11 forth.zip files dating back to February 2004 and entered them
into CVS.  Unfortunately, most of them didn't have the assembler inner
interpreter, just one right after I started writing it and the most
recent version.

I added a recursive search option to FindSymbol and FindSymbolByValue.
The recursive search happens if you pass an optional pointer to a pointer
to a vocab.  This is filled in with the vocab the symbol was found in.
This gets around problems caused by the format of entries being different
in different vocabularies - for example, where the name begins depends on
the number of value fields, which can vary between vocabularies.

I also changed the ForthPrecedenceVocabulary::GetNextSearchVocabulary
to return the engine's current search vocab, so you can just do a recursive
search on the precedence vocab instead of searching it and then searching
the search chain.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 15 2007

Found the "dir" exception - it was in string store code.  String store and
append were stomping multiple registers, and cleaning up by jumping to
the main interpreter entry point to reload the registers from FCore.
Unfortunately, the IP had not been saved out to FCore, so after returning
from the string store, the IP was set back to the return point after the
last user defined word executed.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 14 2007

I tried making symbolic constants forgettable by using the pEntry[1] field
to hold the next user defined op number for forgetting, but that just
doesn't work reliably - many symbolic constants can share the same op
number in this scheme, and there is no way to know which constants were
defined before other constants, since the constants could be in multiple
vocabularies.

I'm switching over to having each enum set having a user-defined op and
having forget only work on user-defined ops.  The user-defined op for an
enum set will act as a defining word that is funtionally the same as the
"int" op.

I added "describe" op which disassembles user ops.
Here is an example:

: dir
  blword -> _aa
  "dir" -> _bb
  strcmp( _aa "" )
  if
    // user specified a directory
    strcat( _bb " " )
    strcat( _bb _aa )
  endif
  _bb system drop
;

dir: type UserDefined:9 value 0x1000009 0x0
0118041c  00:00011d    blword
01180420  00:000012    ->
01180424  01:000001    _aa
01180428  0a:000001    "dir"
01180430  00:000012    ->
01180434  01:000002    _bb
01180438  01:000001    _aa
0118043c  0a:000001    ""
01180444  00:0000b6    strcmp
01180448  04:000007    BranchFalse    0x01180468
0118044c  01:000002    _bb
01180450  0a:000001    " "
01180458  00:0000b2    strcat
0118045c  01:000002    _bb
01180460  01:000001    _aa
01180464  00:0000b2    strcat
01180468  01:000002    _bb
0118046c  00:00010c    system
01180470  00:000001    drop
01180474  00:000016    _exit

There is an exception if you execute "dir" in turbo mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 13 2007

Added "enum definition" mode - this is an interpreted mode, where:
o recognized symbols including numbers are executed like normal
o unrecognized symbols become new enumerated value definitions
o stack depth is recorded at start of enum definition, when a new enumerated
  value definition is created, it will pop its value off TOS if TOS is above
  the level at the start of enum definition
o enumeration value is incremented after each definition
o if possible, enumerated value definitions are created as kOpConstant ops,
  if they are outside the possible range a user-defined constant op is
  defined instead

When testing enums, I found an interesting forget bug: if you try to
forget a kOpConstant definition, nothing appears to happen, the constant ops
still show up in vlist, but if you then forget a user op, the constant ops
will also be forgotten, even if they were defined before the user op.
? Is this a problem just for constant ops, or would if affect any ops which
  do not have an entry in the engine dispatch table ?
-> the problem is because forgetting only works for user defined ops (kOpUserDef)
-> we could make symbol constants unforgettable (this wouldn't work for
   constants which were too big for symbol constants, since they are user ops)
-> maybe there should be a dummy symbol for each enum set that is used just
   for forgetting
-> we could use the unused "struct" field, make it type kDTNone, with the
   value field holding the value of the next user op at the time the
   symbolic constant was defined...  the forget would have to be
   modified to take this into account
   
With enums and structs, I can start making an interface for the SDL DLL.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 11 2007

Got structures working, just did a few simple tests, didn't test arrays or
nested structures or anything complex
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 8 2007

Maybe the first attempt at structures should skip all optimizations, just
compile an op for each symbol in a structure access compound op

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 7 2007

Struct defining stuff is in.  Extension to outer interpreter to handle
stuff like a.b.c is not in yet.

I'm not completely sure that the handling of pointers is correct.
I got rid of ForthNativeStringType, merged it back into ForthBaseType.
I'm not convinced that was a good idea, the code is messy, I was trying to
avoid duplicating DefineInstance.  Most of the ugliness is because strings
need to get the maximum string length, and how that is done is different
in interpret mode and compile mode.

Strings and string arrays in structs is probably not a great idea anyway,
since the maximum length field is not set in that case, so it would be easy
to use an uninitialized string and get a buffer overrun.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 31 2007

Added ForthBaseType

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 26, 2007

Added initStringArrayOp

Added code for arrays to defining words

Added ptrTo support to variable/array defining words
Right now, any variable/array defined with ptrTo is the same as an int
variable/array.
When both arrayOf and ptrTo appear in the same declaration the result is
an array of ints.

Increased length of vocabulary value field for user-defined ops to 2 longs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 25, 2007

Added initString op

How should local & global arrays be supported?
Should they use varOps?  Should they be just like variables except always
doing an array indexing operation?

Simplified existing global/local variable code.  Previously there was code
for each combination of varOp and local/global/field vars.  Now local/global/field
use common code for each varOp.  This is slightly less efficient when running
with the c++ inner interpreter but cuts down the amount of code by a factor
of 2, which makes adding array support easier.

Added support code for all types of arrays

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 23, 2007

Removed remaining vars/endvars dead code
Added field action types
The c++ field action code was using the field offset as longs, changed it
to be using bytes

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 22, 2007

Added dummy entries for struct support ops, just to avoid having to add
them an op at a time to c++ and assembler versions
Added sp, s0, rp, r0, fp ops
Added tuck, pick, roll ops
Changed vocabulary stuff to use long* instead of void* for symbol entry pointers

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 20, 2007

Added byte, short, op data types

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 18, 2007

Added compilation of initLocalStringOp for local string vars

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17, 2007

Added byte & short types
Added local string support to turbo mode
Changed string store & append varOps to use max & current length fields
Added output redirection
Added ArrayOffset optype

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 16, 2007

Been working on structure stuff in ForthStructs.txt

A potential problem with using DLLs from forth ops is anything that requires
a callback.  A possible solution would be to define an interfacing DLL that
goes between the windows DLL and forth.

? could we define a generic callback into forth, and accessors on the forth
  side that gave access to the callback arguments on the stack ?
-> wait until we run into a case where we need a callback

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 15, 2007

Added varAction! and varAction@
Added memcpy and memset

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 14, 2007

Added simple help system to forth_autoload.txt
Still need to add op definitions for builtin ops

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 4, 2007

Started integrating forth into ForthGui

It is at the point where I can pass a line of text from an edit control to
the forth shell, and it processes it correctly.

The next step is to change the output system so that it can be sent back to
ForthGui for display in another edit window.

The way it currently works is that forthOps that generate output call a
local procedure named stringOut.

stringOut writes its output to the current output file if one exists,
otherwise it pushes the string address on param stack and invokes an internal
op called ConOutOpInvoke, which pops the string and appends it to the console
output string buffer.

OutToStringOp sets the current output file to NULL.
OutToScreenOp sets the current output file to stdout.
OutToFileOp sets the current output file to the specified file.

It would be good to change this so that output can be sent to:
1) a specified routine
2) a user op

printCharOp (%c) also uses ConOutOpInvoke.

? does anything currently use output to buffer?

It looks like nothing uses output to buffer, and the console output buffer
is always NULL unless the user executes the "outToString" op.

I should probably implement the changes to strings which set the current
and maximum length fields for local strings before doing the output ops.
The only ops which 
strcpy			->
strncpy			->
strcat			->+
strncat			->+
strlen    strchr    strrchr    strcmp    stricmp    strstr    strtok

I started adding maxLength/curLenth to strings, it is done for global varibles,
but it is probably broken for local variables...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 26, 2007

Added chdir (couldn't use "system" for this)

Added autoforget - just a version of "forget" that doesn't complain if
  symbol to forget doesn't exist

Added interpret - takes a string and gives it to outer interpreter

Added automatic loading at startup of forth_autoload.txt

Added a bunch of string operators (strncpy, strncat, strrchr, stricmp)

Added a bunch of tests to forthtest.txt

Added sc@ & sw@	- signed byte & word fetch
Added c2l & w2l - byte & word sign extension to long

Added ability to specify double float constants by appending a "d": 1.0d
You can specify single float constants by 1.0f, but this is the default

Fixed bug with "0 word"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 21, 2007

Broke out stuff in this file into seperate files in ForthDocs.

Tried out builds... does with:
	: plusser builds , does @ + ;
	5 plusser p5
	20 p5
Normal mode returns 25, but turbo mode returns 40.
	: minusser builds , does @ + ;
	5 minusser m5
	20 m5
Normal mode returns 15, but turbo mode returns 0.

-> got it working, but I should go through and verify that it is right
  It feels like there is another level of indirection than is correct...
-> there was a bug in @ - it wasn't doing any indirection, so it was a no-op,
   and I had added an extra level of indirection to the asm doDoes code

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 18, 2007

Fixed offset optype.

Changed local var stuff so that local vars can be declared anywhere,
vars...endvars are not needed and should be removed.
One case which was a problem was strings:

: anExample
  55 string anyName
;

In this example, the 55 which was intended to be the length param to "string"
had been compiled.  To deal with this, I added a method to the engine which
checks if the last compiled opcode was a literal constant and returns its
value if so.  The "string" implementation backs the DP over this constant.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 17, 2007

When I looked at converting the string ops into assembler, I started thinking
about string variables, in particular about detecting and avoiding string
buffer overruns.  Three main possibilities came to mind:

1) do like C does, just ignore the problem and always assign bigass buffers
2) add a max length field to string variables
  a) add a current length field to string variables
3) go to a scheme where strings are handled more abstractly
  a) suppose a string was a base pointer and a length
  b) or maybe a pointer, current length and writable length (0 means const string)

One problem with making strings more complex than simple uninitialized
buffers is that it would make implementing local strings more complicated

The max length field isn't important for ops that don't modify a string, so
stuff like strlen, strcmp. strstr and strchar could be implemented as they
are now by just calling the C library routines.

Another problem with making strings something other than a simple set of
bytes is if you want to use them in a disk record structure, you probably
don't want the extra length fields taking up space.

I went off on a tangent about eliminating the need for vars/endvars, allowing
you to declare variables anywhere in a user defined word.
  You would probably want to compile the allocLocals op at the first occurence
  of a local variable.  There are many ways that a user could shoot themself
  in the foot doing this, especially if they were manipulating the return
  stack, but it would be mostly safe.
  One consequence of this is that when a string local var is declared, it would
  have to see if a literal constant was just compiled to determine its size.
  -> maybe we could leave that literal constant op where it was compiled, and
     then compile an opcode immediately after it which would store that constant
	 in the local string vars max length field and zero its current length field.

I tried adding an offset optype, it works fine in interpret mode, but not in compile mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 16, 2007

Got most of the floating point ops defined
int, float & double global & local variables are working

- need to test builds...does

- change string variables to include a current length & max length

? make an optimized case branch, where the opcode includes the case value
  and branch offset?

+ added the ability to add 'd' or 'f' to the end of real literals to control
  generation of single or double precision constants

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 13, 2007

Assembler version of forth is mostly working.

I added a macro to allow assembly-code ops to invoke c-code ops.

I added an op "turbo" that allows switching between using c-code
and asm-code inner interpreters on the fly.

c-code is setting ForthCoreState->state @(002F4948 + 434) = 1
asm-code is checking (002F4948 + 432)
? Say huh ?

I auto-generated core.inc from core.h to define the FortheCoreState structure
for asm-code.  One problem area is enumerated types.  Maybe both the c-code
and asm-code structures should be defined strictly in terms of simple types
with a known storage size.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 4, 2007

Worked on writing assembler versions of optype dispatch routines.

Got to LocalIntAction

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 3, 2007

In preparation for switching over to using assembler for inner interpreter,
I changed the inner interpreter to use a 2-stage dispatch scheme, and broke
out the portion of the state that the assembly code will use into a new
structure, the ForthCoreState.

o There is a single ForthCoreState, which is contained in the ForthEngine.
o The ForthCoreState is associated with a single thread at any time.

I had done a similar state breakout of ForthThreadState from ForthThread a
while back.  The big difference is that ForthCoreState contains the
optype dispatch table and other ForthEngine related stuff.

One other related change which caused some bugs is that before both builtinOps
and user defined ops shared a single dispatch table, now they each have their
own table.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Assembler version

7 general purpose registers available:
eax, ebx, ecx, edx, esi, edi, ebp

Things to keep in registers:
IP
SP
optype dispatch table
? builtinOp dispatch table
inner interpreter PC
thread ptr (RP, FP ...)

this would only leave one general purpose register available for stuff...

EAX	free
EBX	free
ECX	IP
EDX	SP
ESI	builtinOp dispatch table
EDI	inner interp PC
EBP	core ptr

? maybe combine opType and builtinOp tables - have bottom 256 builtinOp codes
  be used for opType dispatchers
-> it would not be "free" to detect situation where you compile an opcode in 0..255, which
   would cause an optype handler routine to be executed as if it were a builtinOp
   -> detecting this would require an extra compare & branch instruction pair, which could
      be included in the debug version of the inner interpreter

Maybe the engine ptr should be in a register, and the engine should have a notion
of a current thread, and the threads state is stored in the engine...


Maybe EBP register should point to a new structure, which has:
  1) current thread state (RP, FP, etc)
  2) ptr to engine
  3) ptr to current thread
  4) opType dispatch table
  5) builtinOp dispatch table
forthOps can reuse ESI or EDI, but if they do they either reload them from the EBP struct
or they branch to an alternate inner interpreter entry point that reloads ESI & EDI
Some of this structure is global engine state, some of it is a copy of the current thread state.

innerInterp
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins		; numBuiltins includes the 256 opType dispatchers
	jge	notBuiltin
	mov	eax,[esi+eax*4]
	jmp	[eax]

innerInterpDebug
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins
	jge	notBuiltin
	cmp	eax,256
	jlt	badOpcode
; we should add checking of SP, RP etc. here
	mov	eax,[esi+eax*4]
	jmp	[eax]

notBuiltin
	mov	ebx,eax			; leave full opcode in ebx
	shr	eax,24			; eax is 8-bit optype
	mov	eax,[esi+eax*4]
	jmp	[eax]

;
; builtinOp code
;

addOp
	mov	eax,[edx]
	add	edx,4
	add	[edx],eax
	jmp	[edi]
	
	
+ I broke out the part of the forth machine state the inner interpreter uses
  from the ForthThread class into a structure.
- Change the dispatch table to combine the optype and builtinOp tables
- Move most of ForthThread::InnerInterpreter into a c function, get that
  working and then use the generated assembly entry and exit code
- Remove the user-defined (high level) ops from the builtin op table
- Put the pointer to the dispatch table into the inner interpreter struct
- Don't have 256 opType dispatchers, the top 128 are for method stuff...
- Change the current opType action routines from ForthEngine methods to
  standalone routines
- Move the inner interpreter and the opType action routines into their
  own source module
  -> need to disentangle the intOp/doIntOp/intActionRoutine stuff first

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 8, 2006

+ added ForthForgettable class, changed ForthVocabulary to be based off it

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 5, 2006

+ added input buffer processing ops word/blword/fillInBuffer...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 2, 2006

+ added support for loading DLLs and accessing procedures in DLLs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 30, 2006

+ fixed a bug with parenthesized expressions - the token length byte wasn't
  being set in a few places, so tokens coming off the shell stack disappeared

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 17, 2006

- definition of an interface
- definition of a structure
- definition of a class
- representation of an object on stack
- method invocation
- local objects
  - automatic constructor/destructor
- global objects
- objects as members of other objects
- constructors
- class static data members
- arrays of objects

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 3, 2006

+ added shell stack
+ converted control structures to use control stack
+ added parenthisized expressions using control stack
+ added better error messages for control structure syntax errors

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 12, 2005

I haven't done much with this project in a while.
Current things to add:

1) Shell stack - holds info used while compiling control structures and
   for error checking
2) Add ability to use parenthesized expressions like this:
   sin( x 2 * )
   When "sin(" is parsed, the "sin" token is pushed on the shell stack,
   and when ")" is parsed, the "sin" token is poped and compiled.
   This needs to support parens which have no associated function.
   This should work in interpret and compile mode.
3) Add default input and output files to a thread, and ops for doing
   binary IO with them - formatted IO will probably still use the
   existing IO operators and stream redirection
4) Add support for loading DLLs and accessing their entry points
5) Add a message passing/event system - a thread can have a chain of
   listeners that are informed when a significant event occurs
6) Add support for basic windows calls


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth Implementation Classes

ForthEngine
  tools for building forthops
  code space management
  DP
  inner interpreter
  outer interpreter (token-level interpretation)
  action routines for forthOpTypes

ForthShell
  parsing
  line-level interpretation
  input stream management

ForthVocabulary
  symbol table management
  vocabulary search

ForthThread
  storage for stacks
  SP, RP, IP

ForthInputStack
  current input stream
  pushing and popping streams
  input buffer management

ForthInputStream
  input fetching

ForthParseInfo
  setup for fast vocabulary matching
  interface between ForthShell and ForthVocabulary

ForthForgettable
  does propagation of "forget" to all vocabularies and memory cleanup after forget


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth opcode types

kOpBuiltIn          // low 24 bits is builtin opcode

kOpUserDef          // low 24 bits is opcode

kOpBranch,          // low 24 bits is signed branch offset
kOpBranchNZ,
kOpBranchZ,
kOpCaseBranch,

kOpConstant,        // low 24 bits is signed symbol value

kOpString,          // low 24 bits is immediate string length in longs

kOpAllocLocals,     // low 24 bits is frame size in longs

kOpLocalInt,        // low 24 bits is frame offset in longs
kOpLocalFloat,
kOpLocalDouble,
kOpLocalString,

kOpMethodWithThis,  // low 24 bits is method number

kOpMemberInt,       // low 24 bits is object offset
kOpMemberFloat,
kOpMemberDouble,
kOpMemberString,

kOpLocalUserDefined,             // user can add more optypes starting with this one
kOpMaxLocalUserDefined = 127,    // maximum user defined optype

kOpUserMethods  = 128
// optypes from 128...255 are used to select class methods    

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-


forth extensions for syn2k:

- operations for stating what synops are in a patch,
  and what order they are to be executed in
- operations for initializing synops - settings parameters
  and input and output buffers
- operations for getting note frequency and velocity
- operations for building up sets of patches which are
  selected by midi program number
= operations for defining envelopes and connecting them
  to synops
? is there a way to define the interface so that when
  a new synop is added to syn2k another op doesn't have
  to be added to forth?


table <TABLENAME>
endtable

<TABLENAME> tableLen    leaves number of entries in table on stack

synPatchSet <SETNAME>

synPatch <PATCHNAME>
endPatch



//       11111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890
<############################# Last Line In File ##############################>
