         1         2         3         4         5         6         7
1234567890123456789012345678901234567890123456789012345678901234567890123456789
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
TBDs:

! document existing native ops !
! create examples/tests for all native ops !

- add support for iterating over files in directories

? add a debug feature where a map is maintained from IP address to file/lineNumber

? add a dynamic array (of longs/pointers

? add a string-to-long map based off CMap
  remember that a charPtr-to-long map would just map from the value of the
  charPtr, not the chars in the string, to the long

? add a "parser stack" - this would allow stuff like:
  - using #ifdef to skip sections of code
  - allowing "/*" based comments to span multiple lines
  - allow easily adding user defined parsers for data definition languages

? does support for inline comments using "/* ....*/" break the "*/" operator

- document how parsing is done - put a breakpoint in ProcessToken and go from there

- add a visual debugger that displays execution of words

- switch from having a different exit opcode for ops with and without locals
  to having an epilogue at the end of an op that "exit" will branch to
  
- "forget" doesn't complain about bogus symbols

- add ops for getting current search & definition vocabularies

- a method for saving and restoring state
  -> maybe use memory mapped files for the dictionary, and only allow the restore if
     the file can be mapped at the same address

- testing
  - automated tests using outputToFile & comparison of test result file to known good file
  - test structure support

- dll support
  - a mechanism for supporting callbacks from external code to forth code
    -> the assembler somewhat minimizes the need for this
    
? fix local strings
  ? string vars are currently not using len/maxLen fields
    - change output-to-string to use the string current & max length fields

- windows support
  - first step: create an app where all the windows stuff is in c++
    - support associating windows controls to forth ops
    - a programmable calculator might be a good first step
  - graphics
  ? do this via DLL support
  
- help system

- faster searches

- add "subroutine"
  -> this will definitely cause problems for any simple save/restore scheme where relocation is required
  
? generalize the undefined symbol handling mechanism which is used to
 define enums
? add a way to extend parsing for user-defined literal constants
 
? forward referencing
  Problem: forward referencing breaks "forget"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
In a cygwin shell:

cd /cygdrive/e/pat/prj/forth

cvs checkout DIR
	fetch a project or directory from cvs

cvs commit
	recursively commit all changes
		
cvs log FILENAME
	show revision history

cvs diff FILENAME
	show difference between current file & repository
cvs diff -r REVISION FILENAME
	show difference between current file & specified revision

cvs update
	recursively update all directories from repository
	can be used to show what files are not in CVS or what files have been modified
	
cvs log FILENMAE
	show history of a file
	
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
colonOp
 ForthEngine::StartOpDefinition
  ForthVocabulary::AddSymbol
   ForthEngine::AddUserOp



-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
ForthShell::Run
  ForthShell::InterpretLine
    ForthEngine::ParseToken
    ForthEngine::ProcessToken

ForthShell::Run
	calls ForthShell::InterpretLine in a loop until it returns false

ForthShell::InterpretLine
	calls ForthShell::ParseToken and ForthEngine::ProcessToken in a loop until input line is empty
		
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 17 2009

I got a bunch of the simple problems with struct support debugged.
	point p
	ptrTo point pp
	5 -> pp.x
The above currently has an exception because it compiles into:
  5 -> pp fieldInt(x)
which results in 5 being stored into pp, leaving the stack empty, then
the fieldInt(x) call tries to get the struct base address from TOS, adds
the offset of x, and then dereferences the bogus result address since
the store varaction was cleared when pp was executed.

How can we differentiate between setting the pointer and setting a field in
the struct the pointer references?
When compiling a field reference using a global pointer, look at the opcode
just previously compiled to see if it is one of (addressOf -> ->+ ->-) and if
so, swap the order of the previous opcode and the global pointer opcode.
But what if this is interpret mode? I guess in interpret mode we could save
the varAction at the start of processSymbol, clear the varAction, and compile
the appropriate varAction op after the first field opcode.
Actually, are there any ops other than the final op which use the varAction?
The first op compiled in a field accessor is always one of:
o global struct op - just leaves base address on TOS
o global ptr op - leaves ptr contents on TOS
o local struct op - just leaves base address on TOS
o local ptr op - leaves ptr contents on TOS
-> I overwrote the previously compiled varAction op with the first op of the
   field accessor code, and put the varAction op in the first element of
   the field accessor codes, it appears to work fine

I haven't tried complicated accessors where there is more than one level of
indirection.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 16 2009

I started cleaning up the native type support in ForthInner, making them all
do varOp range checking and use a common code style.

When doing "op" I noticed that the old IP gets stomped, and when you execute
a local or global op var it causes an unwanted return
-> these problems don't happen in turbo mode
DOH! the problem was that it was building a 2 op program, the 2nd op was OP_DONE,
and setting this flag makes the inner interpreter exit - I changed this to
use ForthEngine::ExecuteOneOp, which handles this problem.

+ if you use tick inside a colon definition, that definition shows up in the
  vlist, but if you try to interpret, it causes an undefined symbol error
-> I was misusing tick, it doesn't have precedence, I should have used ['] or lit

OP_DO_CLASS_TYPE is the first and only op in a class defining word, it is
followed by a pointer to the class vocabulary.
doClassTypeOp just calls pClassVocab->DefineInstance() and pops the return stack.
DefineInstance will create an object instance of the class type, which could
mean any of:
o creating a global or local variable/array
o adding an object or object array field to a struct or class definition
Global instances have their vtable and data pointers initialized.
OP_DO_OBJECT is the first and only op in an object instance word.

- "ptrTo" doesn't work with global structs
It looks like ptrTo just changes a var/field to act like a dumb int var

+ structs can't be used as local variables because the ops defined by "struct:"
  don't have precedence, so they are compiled and not interpreted at local var
  definition time...
-> fixed

I need to do more testing, documenting and debugging of existing struct
support before I can advance on class support.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 15 2009

What happens at the start of invocation of a method?
The pushing of this on the rstack can't happen inside the method, since the
code which invokes the method must have already overwritten the this pointer.

Let's assume that the 64-bit object is on TOS already, and the current opcode
is a "method-on-TOS" opcode with method field equal to 5.
Pseudocode for "method-on-TOS":
	rpush TP (2 longs)
	pop TP (2 longs)
	fetch opcode for 5th entry in vtable specified by TP & execute
	

NOTE: doExitMOp and doExitMLOp currently are using a single 32-bit field for
the this pointer - that will have to become 2 fields, right?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 14 2009

+ added strdate, strtime which return current date and time as strings
+ added millitime which returns # milliseconds since forth was started

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 13 2009

+ rewrote systemOp to use stdout/stderr redirection, this should allow it to
  work in ForthGUI
-> it does work, but there is a flash of black when the shell runs...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 12 2009

Chasing the "%c" problem in turbo release mode.  To debug in release mode,
create time wasting user op that takes several seconds to run, pause the
program, chances you will be able to find your way into the inner interpreter
loop pretty quickly.  After that just set breakpoints in the dissassembly
window and look at registers.
After printCharOp returns, the top item on the stack should be the saved EBP
pointer to the forth core, instead that entry has been overwritten by the
characters of the string to be written.  The pushing of EBP was done both to
preserve it and to pass it to the C routine about to be called, in release
mode the compiler feels free to reuse the stack storage of its input params
for other uses, in this case as the character buffer to be printed.  The
solution is to push EBP twice.
This change fixed %c/%bl/%nl as well as vlist in turbo release mode.
Output from forthtest.txt looks ok in all modes now.

Idea for syntax for using TOS as a struct address or object: 
classA.method1
structB.field2

One problem with the current scheme for interfaces, where any class can be
used as an interface, is that it makes it less safe to have classes which
have public fields - the programmer is responsible for keeping track if an
object variable of class blah is:
1) referencing an object which is derived from class blah, in which case it
   is okay to access member fields for class blah
2) referencing an object which is not derived from class blah, but which
   implements the blah interface, in which case it is not okay to access
   any member fields
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 11 2009

Added a "is method" bit to the type code field (pEntry[1]) for struct vocab
symbols.  In the future this will allow the existing bits of the type code
to indicate the return value for the method, so that methods don't have to
terminate a structure accessor string.

Also added a new native type, kNativeObject, which will be a 64-bit field.
When I was putting it in, I found that the global array ops had never
been used, at least in non-turbo mode - their optable entries held the
ops for single variables.

Also, before I made my changes I noticed that running release in turbo mode,
there is an unhandled exception which happens when you do "vlist".
In debug mode, vlist is okay but any immediate op has a "bad opcode"
error.

-> it looks like the assembler version never could have handled immediate
   builtin ops - did the handling of precedence change after the assembler
   version of the nucleus was written?  -> yup!
There was a similar problem with immediate user defined ops, I just made
them use the same table entry as non-immediate user define ops, and I did
the same with "user code" immediate ops, but I haven't tested those yet.

Debug version in turbo mode now runs forthest.txt with no errors and what
looks like valid output.

Release version in turbo mode still breaks on vlist and fails pretty quickly
when loading forthtest.txt
-> %c, %nl, %bl cause a "No Error" failure!  They do display the character
  %nl and %bl just push a char and call %c, %c just build a two char string
  and calls %s, so why does %s work and these other ops fail?
? What does a "No Error" failure mean?
-> the exit status from InnerInterpreterFast is something other than kResultOk
   or kResultDone, but core->error was not set to an error code
The character is always printed correctly.
The problem goes away if I change printCharOp to either use a larger character
buffer or if I remove the SPOP that copies the character from the stack to
the first byte of the buffer.
The problem does not go away if I redirect output to a file.

All of this really emphasizes the need for an automated test suite - changes I
have made in the distant past have broken things, and I have no idea what
change broke what feature.  DOH!

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 10 2009

Decided to tackle a couple of problems using forth, to see what it needs to
solve real problems.  The problems were:

1) merge two equal sized files, which have missing data (zeroes), which come
   from different torrents (rock band .flac file collections)
   mergefiles.txt & mergeall.txt
2) merge guitar pro song collections - there are multiple versions of many songs,
   and the files in different collections sometimes have the same names and
   versions
   gp.txt & narf.txt

Overall, it worked out pretty well.  The main thing that stood out is that I
need to spend some time documenting the functionality that is already implemented.

One missing thing is the ability to iterate over all files in a directory tree,
I got around this by creating a list of files using the cygwin shell and then
turning the list of files into forth files.

Dropped off Xbox-360 today at UPS to fix red-ring-of-death.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 9 2009

+ changed struct/endstruct/enum/endenum to struct:/;struct/enum:/;enum

+ got incomplete class definition time stuff to compile

- there are no examples of "union" - has it ever been tested?
-> test & document its usage

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 7 2009

The ways an interface gets defined:

o the primary interface is defined two ways:
	1) when the "extends" clause is processed, the methods of the defining
	   class are copied
	2) when a method is defined, it either replaces an existing method or is
	   added as new
o secondary interfaces are defined:
	1) when the "extends" clause is processed, the secondary interfaces of
	   the defining class are copied
	2) when the implements clause is processed, if the named interface does
	   not already exist, the new interface is initialized to have the same
	   number of methods as the named interface, and all of the methods are
	   marked as virtual and filled in with a dummy (error) method
	3) when a method is defined inside an implements clause, it replaces the 
	   named method in the interface
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 4 2009

A problem with methods and also struct op fields is that there is no concept of
a return type, so they can't be followed by a dot accessor: objectA.methodZ.fieldQ
doesn't work because we don't know the struct type returned by methodZ, so we
don't know the struct vocab to lookup fieldQ.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 3 2009

One potential gotcha with just extending struct stuff to do classes: the struct
stuff currently does allow structs to be allocated as globals or on the stack.
? Is this really a problem?
We should probably leave structs as is, it would be a pain to have them always
have a dummy vtable on TOS.

Classes should be able to extend a struct, but should a struct be able to
extend a class?  If so, it should just be taking the data members.

When a local class variable is declared, should code be generated to set its vtable?
It would be redundant, except in cases where you only set the dataAddress part of
an object variable.  In those cases the vtable would have to be explicitly
initialized.

Base methods are methods which every class implements, these are methods
in class Object.

-> make a list of class methods and base methods
class.new			...		dataAddress methodsAddress
	this should be an opcode type
struct.sizeof		...		sizeofStructInstance
class.sizeof		...		sizeofClassInstance
object.sizeof		...		sizeofObject
	this should be an opcode type, or be compiled as a constant
class.methods		...		methodsAddress
object.methods		...		methodsAddress
class.numMethods	...		numberOfMethods
object.numMethods	...		numberOfMethods
object.class		...		classDescriptor
	? what should the classDescriptor be?
		1) the struct index
		2) address of something
	what can you do with a class_descriptor? is there a class class?
object.delete
class.parent
object.print
object.queryInterface

? should base methods have a single vtable entry
Note: object.methods could either be:
1) at runtime, fetch the methods field from objects
2) fetch the methods field from the declared class of object (which might be
   a superclass of the actual class of object
We probably want object.methods to fetch the actual object methods field, and
have class.methods be used to fetch the methods field of class
Maybe there are 2 predefined classes at startup, "object" and "class", with
"class" derived from "object".

object methods: delete class methods data sizeof print
class methods: new sizeof methods name parent
Ugh - class.methods doesn't returns the vtable of the class object, it returns
the vtable of objects of its class...
Maybe it should be called "vtable"?  This is bound to cause bugs...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 1 2009

Is there any reason to create a ForthClassVocabulary and manager instead of
just expanding the ForthStruct stuff by adding methods?

Every class defines:
1) an interface
2) a data structure
The interface may be empty, in which case this is an old-fashioned struct.
The data structure may be empty, in which case this is an abstract interface.

How do extends/implements work and interact?
Maybe only the primary interface can extend another class, "implements" means
that this class implements the exact interface of an existing class as a
secondary interface.
When a class extends another class:
o it inherits its implementation
o it inherits any interfaces that it implements, but it may override any or all of the
  implementations of those methods.
When a class implements the interface of another class:
o it does not inherit any implementation from that class
o it does not automatically implement interfaces that the base class implemented

What changes are needed to ForthStructVocabulary?
- add method count
- add abstract method count
- add ?list? of interfaces

Should class methods be assigned normal opcodes, and the vtable contain opcodes,
or should the vtable just hold IP addresses?
Is there a need to have class methods be native opcodes?
o this might help implement classes which are defined in the kernel
o this might be useful when calling a method from another method in the same class
-> make vtables hold opcodes instead of IP addresses

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 31 2009

A class has a primary interface, which is the set of methods which it declares.
A class may have secondary interfaces, which can be gotten by querying.

When a class doesn't have distinct methods of its own, and just implements a
previously defined interface, will that pose a problem?  IE how can the primary
interface for a class be defined using the "implements" keyword ?
-> the endclass word will handle this when the primary interface has 0 methods

When you extend a class which has secondary interfaces, can you override or
extend the secondary interfaces?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 30 2009

What about making all object references be a pair of pointers, a data pointer
and a vtable pointer?  What would this look like?
+ this would allow a simple implementation of multiple interfaces
+ arrays would not need a redundant vtable field per element
o object variables are just a pointer pair
o object reference on TOS is a pointer pair (not a pointer to a pointer pair)
o "this" in thread context is a pointer pair

Maybe all interface definitions which don't have an "extends" statement implicitly
extend the interface "object".

Maybe a class definition could be like:

interface blather1
  talk
  ramble
endinterface

interface blather2
  extends blather1
  spew
endinterface

struct sBlatherer
	...
endstruct

class blahBlah blather2 sBlatherer
 ... method definitions for
-> having "extends" at the class level would make implementation easier
-> "extends" should be available in both class and interface definitions
-> it probably is better to have the class define its data members, instead of
   requiring that its data members be defined in a seperate struct
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 18 2008

More ForthGUI work.

Noticed that the line:   "dir" system
produced no output - the problem is that the directory was sent to standard out
for the console.
? Is there a way to redirect standard out to a function ?
SetStdHandle can be used to redirect standard in/out/error.
? Is there a way to connect a handle to a function
! The easiest thing to do might be to redirect output to a temp file
  inside the "system" op, then after interpreting the string write the output
  to the thread output routine

Also "load" does not do anything.
-> The forth console app calls shell::Run, which has a loop that keeps calling
   GetLine and interpreting it, this is what does the loading.  The forth
   GUI app doesn't call shell::Run or shell::GetLine, it interprets the edit
   buffer when the edit control OnOK handler is triggered.
   Maybe the solution would be for the GUI app to check the input stack depth
   after interpreting a line, and keep doing GetLine/interpret until the input stack reaches zero.

I added the above code to ForthGUI.  forthtest.txt has an error in it, and this
was causing a crash.  I tried to fix it by adding methods to create and delete
all the forth related objects, and these were called when InterpretLine returned
a fatal error result code.  This is currently failing because the engine constructor
saves its this pointer to a global instance pointer, and it asserts if that pointer
is already not null.
At some point I decided to treat the engine as a singleton, and for some
reason I changed the GET_ENGINE macro to use the singleton, but most cases
where it is used the code already has access to the engine, for example forthops
can get the engine from the forth core state.
For now, I am just clearing the engine global instance pointer inside the engine
destructor.  I also had to do this in the ForthStructsManager, which also used
a singleton.
I think the idea was that there should only ever be one engine object.

I get a fatal error when I load sdl.txt, then sdl2.txt, and run "test".

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2008

ForthGui program now mostly works
- "bye" does not exit program
- there is no error output
  -> look at ForthShell::ReportError
  -> fixed
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2008

+ added resetting of console output routine, so app can set default output routine
+ tried to make output more simple/unified by combining user data pointer and
  file pointer
  
It might be nice to have a way of pushing/popping an output context.  There
are 3 overall types of output context, here are their data:
1) external function
  - function address
  - function data address
2) file
  - file pointer
3) user op
  - opcode
  - data address

One way to unify these would be to have an output context structure:
	void*	function address
	void*	data address
	long	opcode

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 19 2008

+ added appending to GUI output pane

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 23 2007

Haven't been working on forth since June.  I did add to help.txt.
Going to to try to:
1) add a string->long map feature, use it for help
2) maybe get the Forth GUI working.

The only problem with a map is that it would make a "save state" feature
much more complicated
-> make the map output be offsets from the DP, not absolute pointers
-> come up with a general solution for dynamic data

If I remember correctly, the hangup with doing the GUI was not knowing how to
incrementally get text output to the edit output pane, I only know how to fill
the whole edit pane at creation.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 13 2007

Not much progress over the last month:
- I took a quick look at class support, no amazing revelations occured
- I started creating the GUI for a programmable calculator
The projects I would like to wack on this summer:
- programmable calculator
- synth2k
- graphics sandbox
  ? based on sdl, or win32 ?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 6 2007

I tried adding a lookup map to vocabularies to speedup loading.  Right now
it is ifded-ed out with MAP_LOOKUP.  It seems to be unnecessary, since in
the release version loading the pentium assembler is instantaneous.  The
slowness of loading in the debug version is probably mostly caused by all
the TRACE message output together with the slowness of debug code.

Removed "code" setting of top search vocab to "assembler".  With this gone,
there was no reason to have "assembler" vocab in kernel anymore, so I removed
it and added it to asm_pentium.txt.

Added a serial number to vocab stack searches to eliminate redundant failed
searches of the same vocabulary.  It worked for everything until I tested
sdl2.txt, and it looks like it failed the first time it tried to lookup
an enumerated type.
-> false alarm, sdl2.txt just wasn't adding sdl to the search order
? maybe make vocabulary stack always have at least 2 entries, and the
  bottom entry is always forth?
  
When this works I should rip out the vocabulary search chain since it is
no longer used.
-> No, the search chain is still used, but only by the structs vocabulary.
-> Move the search chain down to the structs vocabulary
  -> I should probably create a chained vocabulary type, since classes will
     probably want to be able to extend another class, like structs
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 5 2007

Added fprintf/sprintf/fscanf/sscanf - they work except that fprintf/sprintf
can't print floating point numbers - there may be some expectation that
fp numbers will be passed in fp registers, but that would seem to be a
pain for variable numbers of arguments.
One hokey thing is that you have to pass the number of variables to be
printed as the last argument.
Example: stdout "%d,%d" 5 7 2 fprintf

Eliminated precedence vocabulary - it didn't work well with the vocabulary
stack.

Starting debug of pentium assembler.

source:
	code andy dx ) ax mov,  4 # dx add, ax dx ) and, next,
generated:
	011842F8  mov         eax,edx 
	011842FA  add         edx,4 
	011842FD  and         edx,eax 
	011842FF  jmp         edi  
should have generated:
	mov	eax, [edx]
	add	edx, 4
	and	[edx], eax
	jmp	edi

-> The ")" op is never being executed - it may be getting eaten by the shell
-> changed all uses of ")" to "]"
	code andy dx ] ax mov,  4 # dx add, ax dx ] and, next,

Assembler is now generating the correct code for "andy", and the op performs
correctly with both fast & slow interpreters.

DLL support was broken, because it relied on the op for a vocab to push
its address on TOS.

I'm changing vocabularies to act like variables, where a prefix op is used
to set the operation the vocabulary will do when invoked.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 4 2007

Working on switching over to the ans forth vocabulary stack.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 3 2007

Updated CVS.

The GForth assembler is ported, it loads but it is untested.
The GForth package doesn't seem to have any examples of its usage in actual
code, but the assembler is almost identical to the assembler in BigForth,
maybe it has some examples.  The file gforth.050/doc/gforth.i9 has a
"386 Assembler" section which spells out the syntax.

One problem area was that GForth is not case sensitive.

Another was that there was a partially implemented relocation scheme which
remapped forth builtin ops which compile stuff or manipulate the DP to a set of
proxy ops which mostly did exactly the same thing - presumably this was
preparation for swapping out the proxy ops for another set which did something
like assembling to an address offset from the intended run address.

One odd thing was that "," was remapped to "c,", and it looked like "," was
being used to compile byte data, not longs.  Perhaps the intent was that in
the source for the assembler, "," was used to compile stuff that needed to
be relocated and "c," was used to compile stuff that didn't.

The next step would be to create a way to make a user-defined op in
assembler.  This could be tricky, especially if we want the fast inner
interpreter to be able to execute these ops without passing them off to
the slow inner assembler.
-> The user defined code ops would be setup to work with the fast interpreter,
   and create a piece of glue code which the slow interpreter uses to execute
   user defined code ops
   -> We could also use this for builtinOps which have no C++ version (with a small mod)
User defined code ops should live in userOps dispatch table, and therefore
share the opValue space of other user defined ops, which will make "forget"
easy to implement for them.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 30 2007

Working on adapting the GForth assembler

: within  ( u1 u2 u3 -- f )
 over - >r - r> u< ;

: t5a 5 -5 within . ;  ok
: t5b -5 5 within . ;  ok

-6 t5a -1  ok
-5 t5a 0  ok
4 t5a 0  ok
5 t5a -1  ok

-6 t5b 0  ok
-5 t5b -1  ok
4 t5b -1  ok
5 t5b 0  ok

With arguments in low,high order result is true for numbers between low & high-1
With arguments in high,low order result is false for numbers between low & high-1

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 28 2007

Initial debug of new DLL support - it works!

Integrated with old CVS system

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 26 2007

Wrote the assembly side of support for DLL via a special opcode type.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 25 2007

+ look at usage of CompileLong versus CompileOpcode
  -> replaced CompileLong with CompileOpcode where appropriate

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 24 2007

+ see if initialization of local strings works, it might not since it looks like this:
  -> 100 string myName
  The "100" compiles into a constant op, which is then removed by "string", but it
  might make string ignore the "->" and not do the initialization...
  -> added mpLastIntoOpcode to engine, to track last "->" compiled in
     current definition
     
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2007

I moved the replacement of kResultDone with kResultOk into ForthEngine::ExecuteOps.
This centralizes the fix for ops which execute an op variable from exiting
the inner interpreter prematurely.
There is one drawback to fixing this bug, it could make the "done" op useless
except as an internal to the outer interpreter.

+ if "->" has been executed before a native global or local variable declaration,
  initialize the new variable from TOS
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2007

The current state of forth output:

ops which produce output invoke CONSOLE_STRING_OUT, passing a core ptr & a char buffer ptr
CONSOLE_STRING_OUT is defined as: pCore->pThread->consoleOut( A, B )
consoleOut is set by the SET_CON_OUT_ROUTINE macro.

outToScreenOp
  sets consoleOut = consoleOutToFile
  sets output file = stdout

outToFileOp
  sets consoleOut = consoleOutToFile
  sets output file = file on TOS

outToStringOp
  sets consoleOut = consoleOutToString
  sets output file = NULL
  sets output string = string ptr on TOS

outToOpOp
  sets consoleOut = consoleOutToOp
  sets consoleOutOp = TOS

SET_CON_OUT_FILE( FILE_POINTER )
SET_CON_OUT_ROUTINE( OUTPUT_ROUTINE )
SET_CON_OUT_STRING( A )
SET_CON_OUT_OP( OUTPUT_OP )

consoleOutToString just appends the string to the end of the buffer, it should
be changed to use the string current length & max length fields.

Got outToOp working, but found an apparent bug in local variables - if I
define a local pointer variable with "ptrTo byte" I get an exception when
it tries to print what is at that address, but it works if I change that
variable to be "int".
-> the local variable defining code was ignoring the "isPointer" flag.

There is still a bug in the output code - if you use a user-defined op,
any output generating op will end the execution of a calling op.
It almost looks like the "done" flag is being set.
-> duhh, yeah, since consoleOutToOp calls ForthEngine::ExecuteOneOp,
   that does a "done" after executing the output op...
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 21 2007

One way to improve DLL support would be to dedicate an opcode to DLL calls.
The address of the DLL entry point would be held in the user defined op
dispatch table.  The op value field would hold 2 things:
1) the dispatch table index
2) the number of arguments the op takes
As mentioned yesterday, Each DLL would have a dedicated vocabulary.

+ fixed a bug in structure support - any forget was wiping out all structs,
  because it was comparing the forgotten op's value field to the structs
  entire opcode

+ added extends, sizeOf and addressOf

+ add "union" to structure definitions

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 20 2007

The SDL_LoadBMP exception happened because SDL_LoadBMP isn't one of the DLLs
exports - the real export is SDL_LoadBMP_RW.  The defining words for DLL
interface words should check for getProcAddress returning NULL.

Maybe we should create a special type of vocabulary for DLLs, where the
vocabulary would know the path to the DLL and its symbols would be the
DLLs entry points - this would allow saving the forth state and restoring
the DLL linkage on coldstart.

Before you call a C routine you push arguments right-to-left, so the first
argument is on top of the stack (lowest memory address).  When we call a
DLL routine, we push arguments left-to-right, so the last argument is on
top of the stack.  This forces us to have to copy between the parameter
stack and the PC stack to reverse the order.  If that wasn't the case we
could do a trick in assembler where we just set the PC stack pointer to the
parameter stack before the DLL call.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 19 2007

Tried to implement SDL dll interface - got an exception in SDL_LoadBMP

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 16 2007

I took the 11 forth.zip files dating back to February 2004 and entered them
into CVS.  Unfortunately, most of them didn't have the assembler inner
interpreter, just one right after I started writing it and the most
recent version.

I added a recursive search option to FindSymbol and FindSymbolByValue.
The recursive search happens if you pass an optional pointer to a pointer
to a vocab.  This is filled in with the vocab the symbol was found in.
This gets around problems caused by the format of entries being different
in different vocabularies - for example, where the name begins depends on
the number of value fields, which can vary between vocabularies.

I also changed the ForthPrecedenceVocabulary::GetNextSearchVocabulary
to return the engine's current search vocab, so you can just do a recursive
search on the precedence vocab instead of searching it and then searching
the search chain.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 15 2007

Found the "dir" exception - it was in string store code.  String store and
append were stomping multiple registers, and cleaning up by jumping to
the main interpreter entry point to reload the registers from FCore.
Unfortunately, the IP had not been saved out to FCore, so after returning
from the string store, the IP was set back to the return point after the
last user defined word executed.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 14 2007

I tried making symbolic constants forgettable by using the pEntry[1] field
to hold the next user defined op number for forgetting, but that just
doesn't work reliably - many symbolic constants can share the same op
number in this scheme, and there is no way to know which constants were
defined before other constants, since the constants could be in multiple
vocabularies.

I'm switching over to having each enum set having a user-defined op and
having forget only work on user-defined ops.  The user-defined op for an
enum set will act as a defining word that is funtionally the same as the
"int" op.

I added "describe" op which disassembles user ops.
Here is an example:

: dir
  blword -> _aa
  "dir" -> _bb
  strcmp( _aa "" )
  if
    // user specified a directory
    strcat( _bb " " )
    strcat( _bb _aa )
  endif
  _bb system drop
;

dir: type UserDefined:9 value 0x1000009 0x0
0118041c  00:00011d    blword
01180420  00:000012    ->
01180424  01:000001    _aa
01180428  0a:000001    "dir"
01180430  00:000012    ->
01180434  01:000002    _bb
01180438  01:000001    _aa
0118043c  0a:000001    ""
01180444  00:0000b6    strcmp
01180448  04:000007    BranchFalse    0x01180468
0118044c  01:000002    _bb
01180450  0a:000001    " "
01180458  00:0000b2    strcat
0118045c  01:000002    _bb
01180460  01:000001    _aa
01180464  00:0000b2    strcat
01180468  01:000002    _bb
0118046c  00:00010c    system
01180470  00:000001    drop
01180474  00:000016    _exit

There is an exception if you execute "dir" in turbo mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 13 2007

Added "enum definition" mode - this is an interpreted mode, where:
o recognized symbols including numbers are executed like normal
o unrecognized symbols become new enumerated value definitions
o stack depth is recorded at start of enum definition, when a new enumerated
  value definition is created, it will pop its value off TOS if TOS is above
  the level at the start of enum definition
o enumeration value is incremented after each definition
o if possible, enumerated value definitions are created as kOpConstant ops,
  if they are outside the possible range a user-defined constant op is
  defined instead

When testing enums, I found an interesting forget bug: if you try to
forget a kOpConstant definition, nothing appears to happen, the constant ops
still show up in vlist, but if you then forget a user op, the constant ops
will also be forgotten, even if they were defined before the user op.
? Is this a problem just for constant ops, or would if affect any ops which
  do not have an entry in the engine dispatch table ?
-> the problem is because forgetting only works for user defined ops (kOpUserDef)
-> we could make symbol constants unforgettable (this wouldn't work for
   constants which were too big for symbol constants, since they are user ops)
-> maybe there should be a dummy symbol for each enum set that is used just
   for forgetting
-> we could use the unused "struct" field, make it type kDTNone, with the
   value field holding the value of the next user op at the time the
   symbolic constant was defined...  the forget would have to be
   modified to take this into account
   
With enums and structs, I can start making an interface for the SDL DLL.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 11 2007

Got structures working, just did a few simple tests, didn't test arrays or
nested structures or anything complex
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 8 2007

Maybe the first attempt at structures should skip all optimizations, just
compile an op for each symbol in a structure access compound op

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 7 2007

Struct defining stuff is in.  Extension to outer interpreter to handle
stuff like a.b.c is not in yet.

I'm not completely sure that the handling of pointers is correct.
I got rid of ForthNativeStringType, merged it back into ForthNativeType.
I'm not convinced that was a good idea, the code is messy, I was trying to
avoid duplicating DefineInstance.  Most of the ugliness is because strings
need to get the maximum string length, and how that is done is different
in interpret mode and compile mode.

Strings and string arrays in structs is probably not a great idea anyway,
since the maximum length field is not set in that case, so it would be easy
to use an uninitialized string and get a buffer overrun.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 31 2007

Added ForthNativeType

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 26, 2007

Added initStringArrayOp

Added code for arrays to defining words

Added ptrTo support to variable/array defining words
Right now, any variable/array defined with ptrTo is the same as an int
variable/array.
When both arrayOf and ptrTo appear in the same declaration the result is
an array of ints.

Increased length of vocabulary value field for user-defined ops to 2 longs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 25, 2007

Added initString op

How should local & global arrays be supported?
Should they use varOps?  Should they be just like variables except always
doing an array indexing operation?

Simplified existing global/local variable code.  Previously there was code
for each combination of varOp and local/global/field vars.  Now local/global/field
use common code for each varOp.  This is slightly less efficient when running
with the c++ inner interpreter but cuts down the amount of code by a factor
of 2, which makes adding array support easier.

Added support code for all types of arrays

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 23, 2007

Removed remaining vars/endvars dead code
Added field action types
The c++ field action code was using the field offset as longs, changed it
to be using bytes

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 22, 2007

Added dummy entries for struct support ops, just to avoid having to add
them an op at a time to c++ and assembler versions
Added sp, s0, rp, r0, fp ops
Added tuck, pick, roll ops
Changed vocabulary stuff to use long* instead of void* for symbol entry pointers

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 20, 2007

Added byte, short, op data types

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 18, 2007

Added compilation of initLocalStringOp for local string vars

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17, 2007

Added byte & short types
Added local string support to turbo mode
Changed string store & append varOps to use max & current length fields
Added output redirection
Added ArrayOffset optype

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 16, 2007

Been working on structure stuff in ForthStructs.txt

A potential problem with using DLLs from forth ops is anything that requires
a callback.  A possible solution would be to define an interfacing DLL that
goes between the windows DLL and forth.

? could we define a generic callback into forth, and accessors on the forth
  side that gave access to the callback arguments on the stack ?
-> wait until we run into a case where we need a callback

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 15, 2007

Added varAction! and varAction@
Added memcpy and memset

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 14, 2007

Added simple help system to forth_autoload.txt
Still need to add op definitions for builtin ops

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 4, 2007

Started integrating forth into ForthGui

It is at the point where I can pass a line of text from an edit control to
the forth shell, and it processes it correctly.

The next step is to change the output system so that it can be sent back to
ForthGui for display in another edit window.

The way it currently works is that forthOps that generate output call a
local procedure named stringOut.

stringOut writes its output to the current output file if one exists,
otherwise it pushes the string address on param stack and invokes an internal
op called ConOutOpInvoke, which pops the string and appends it to the console
output string buffer.

OutToStringOp sets the current output file to NULL.
OutToScreenOp sets the current output file to stdout.
OutToFileOp sets the current output file to the specified file.

It would be good to change this so that output can be sent to:
1) a specified routine
2) a user op

printCharOp (%c) also uses ConOutOpInvoke.

? does anything currently use output to buffer?

It looks like nothing uses output to buffer, and the console output buffer
is always NULL unless the user executes the "outToString" op.

I should probably implement the changes to strings which set the current
and maximum length fields for local strings before doing the output ops.
The only ops which 
strcpy			->
strncpy			->
strcat			->+
strncat			->+
strlen    strchr    strrchr    strcmp    stricmp    strstr    strtok

I started adding maxLength/curLenth to strings, it is done for global varibles,
but it is probably broken for local variables...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 26, 2007

Added chdir (couldn't use "system" for this)

Added autoforget - just a version of "forget" that doesn't complain if
  symbol to forget doesn't exist

Added interpret - takes a string and gives it to outer interpreter

Added automatic loading at startup of forth_autoload.txt

Added a bunch of string operators (strncpy, strncat, strrchr, stricmp)

Added a bunch of tests to forthtest.txt

Added sc@ & sw@	- signed byte & word fetch
Added c2l & w2l - byte & word sign extension to long

Added ability to specify double float constants by appending a "d": 1.0d
You can specify single float constants by 1.0f, but this is the default

Fixed bug with "0 word"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 21, 2007

Broke out stuff in this file into seperate files in ForthDocs.

Tried out builds... does with:
	: plusser builds , does @ + ;
	5 plusser p5
	20 p5
Normal mode returns 25, but turbo mode returns 40.
	: minusser builds , does @ + ;
	5 minusser m5
	20 m5
Normal mode returns 15, but turbo mode returns 0.

-> got it working, but I should go through and verify that it is right
  It feels like there is another level of indirection than is correct...
-> there was a bug in @ - it wasn't doing any indirection, so it was a no-op,
   and I had added an extra level of indirection to the asm doDoes code

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 18, 2007

Fixed offset optype.

Changed local var stuff so that local vars can be declared anywhere,
vars...endvars are not needed and should be removed.
One case which was a problem was strings:

: anExample
  55 string anyName
;

In this example, the 55 which was intended to be the length param to "string"
had been compiled.  To deal with this, I added a method to the engine which
checks if the last compiled opcode was a literal constant and returns its
value if so.  The "string" implementation backs the DP over this constant.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 17, 2007

When I looked at converting the string ops into assembler, I started thinking
about string variables, in particular about detecting and avoiding string
buffer overruns.  Three main possibilities came to mind:

1) do like C does, just ignore the problem and always assign bigass buffers
2) add a max length field to string variables
  a) add a current length field to string variables
3) go to a scheme where strings are handled more abstractly
  a) suppose a string was a base pointer and a length
  b) or maybe a pointer, current length and writable length (0 means const string)

One problem with making strings more complex than simple uninitialized
buffers is that it would make implementing local strings more complicated

The max length field isn't important for ops that don't modify a string, so
stuff like strlen, strcmp. strstr and strchar could be implemented as they
are now by just calling the C library routines.

Another problem with making strings something other than a simple set of
bytes is if you want to use them in a disk record structure, you probably
don't want the extra length fields taking up space.

I went off on a tangent about eliminating the need for vars/endvars, allowing
you to declare variables anywhere in a user defined word.
  You would probably want to compile the allocLocals op at the first occurence
  of a local variable.  There are many ways that a user could shoot themself
  in the foot doing this, especially if they were manipulating the return
  stack, but it would be mostly safe.
  One consequence of this is that when a string local var is declared, it would
  have to see if a literal constant was just compiled to determine its size.
  -> maybe we could leave that literal constant op where it was compiled, and
     then compile an opcode immediately after it which would store that constant
	 in the local string vars max length field and zero its current length field.

I tried adding an offset optype, it works fine in interpret mode, but not in compile mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 16, 2007

Got most of the floating point ops defined
int, float & double global & local variables are working

- need to test builds...does

- change string variables to include a current length & max length

? make an optimized case branch, where the opcode includes the case value
  and branch offset?

+ added the ability to add 'd' or 'f' to the end of real literals to control
  generation of single or double precision constants

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 13, 2007

Assembler version of forth is mostly working.

I added a macro to allow assembly-code ops to invoke c-code ops.

I added an op "turbo" that allows switching between using c-code
and asm-code inner interpreters on the fly.

c-code is setting ForthCoreState->state @(002F4948 + 434) = 1
asm-code is checking (002F4948 + 432)
? Say huh ?

I auto-generated core.inc from core.h to define the FortheCoreState structure
for asm-code.  One problem area is enumerated types.  Maybe both the c-code
and asm-code structures should be defined strictly in terms of simple types
with a known storage size.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 4, 2007

Worked on writing assembler versions of optype dispatch routines.

Got to LocalIntAction

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 3, 2007

In preparation for switching over to using assembler for inner interpreter,
I changed the inner interpreter to use a 2-stage dispatch scheme, and broke
out the portion of the state that the assembly code will use into a new
structure, the ForthCoreState.

o There is a single ForthCoreState, which is contained in the ForthEngine.
o The ForthCoreState is associated with a single thread at any time.

I had done a similar state breakout of ForthThreadState from ForthThread a
while back.  The big difference is that ForthCoreState contains the
optype dispatch table and other ForthEngine related stuff.

One other related change which caused some bugs is that before both builtinOps
and user defined ops shared a single dispatch table, now they each have their
own table.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Assembler version

7 general purpose registers available:
eax, ebx, ecx, edx, esi, edi, ebp

Things to keep in registers:
IP
SP
optype dispatch table
? builtinOp dispatch table
inner interpreter PC
thread ptr (RP, FP ...)

this would only leave one general purpose register available for stuff...

EAX	free
EBX	free
ECX	IP
EDX	SP
ESI	builtinOp dispatch table
EDI	inner interp PC
EBP	core ptr

? maybe combine opType and builtinOp tables - have bottom 256 builtinOp codes
  be used for opType dispatchers
-> it would not be "free" to detect situation where you compile an opcode in 0..255, which
   would cause an optype handler routine to be executed as if it were a builtinOp
   -> detecting this would require an extra compare & branch instruction pair, which could
      be included in the debug version of the inner interpreter

Maybe the engine ptr should be in a register, and the engine should have a notion
of a current thread, and the threads state is stored in the engine...


Maybe EBP register should point to a new structure, which has:
  1) current thread state (RP, FP, etc)
  2) ptr to engine
  3) ptr to current thread
  4) opType dispatch table
  5) builtinOp dispatch table
forthOps can reuse ESI or EDI, but if they do they either reload them from the EBP struct
or they branch to an alternate inner interpreter entry point that reloads ESI & EDI
Some of this structure is global engine state, some of it is a copy of the current thread state.

innerInterp
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins		; numBuiltins includes the 256 opType dispatchers
	jge	notBuiltin
	mov	eax,[esi+eax*4]
	jmp	[eax]

innerInterpDebug
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins
	jge	notBuiltin
	cmp	eax,256
	jlt	badOpcode
; we should add checking of SP, RP etc. here
	mov	eax,[esi+eax*4]
	jmp	[eax]

notBuiltin
	mov	ebx,eax			; leave full opcode in ebx
	shr	eax,24			; eax is 8-bit optype
	mov	eax,[esi+eax*4]
	jmp	[eax]

;
; builtinOp code
;

addOp
	mov	eax,[edx]
	add	edx,4
	add	[edx],eax
	jmp	[edi]
	
	
+ I broke out the part of the forth machine state the inner interpreter uses
  from the ForthThread class into a structure.
- Change the dispatch table to combine the optype and builtinOp tables
- Move most of ForthThread::InnerInterpreter into a c function, get that
  working and then use the generated assembly entry and exit code
- Remove the user-defined (high level) ops from the builtin op table
- Put the pointer to the dispatch table into the inner interpreter struct
- Don't have 256 opType dispatchers, the top 128 are for method stuff...
- Change the current opType action routines from ForthEngine methods to
  standalone routines
- Move the inner interpreter and the opType action routines into their
  own source module
  -> need to disentangle the intOp/doIntOp/intActionRoutine stuff first

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 8, 2006

+ added ForthForgettable class, changed ForthVocabulary to be based off it

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 5, 2006

+ added input buffer processing ops word/blword/fillInBuffer...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 2, 2006

+ added support for loading DLLs and accessing procedures in DLLs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 30, 2006

+ fixed a bug with parenthesized expressions - the token length byte wasn't
  being set in a few places, so tokens coming off the shell stack disappeared

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 17, 2006

- definition of an interface
- definition of a structure
- definition of a class
- representation of an object on stack
- method invocation
- local objects
  - automatic constructor/destructor
- global objects
- objects as members of other objects
- constructors
- class static data members
- arrays of objects

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 3, 2006

+ added shell stack
+ converted control structures to use control stack
+ added parenthisized expressions using control stack
+ added better error messages for control structure syntax errors

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 12, 2005

I haven't done much with this project in a while.
Current things to add:

1) Shell stack - holds info used while compiling control structures and
   for error checking
2) Add ability to use parenthesized expressions like this:
   sin( x 2 * )
   When "sin(" is parsed, the "sin" token is pushed on the shell stack,
   and when ")" is parsed, the "sin" token is poped and compiled.
   This needs to support parens which have no associated function.
   This should work in interpret and compile mode.
3) Add default input and output files to a thread, and ops for doing
   binary IO with them - formatted IO will probably still use the
   existing IO operators and stream redirection
4) Add support for loading DLLs and accessing their entry points
5) Add a message passing/event system - a thread can have a chain of
   listeners that are informed when a significant event occurs
6) Add support for basic windows calls


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth Implementation Classes

ForthEngine
  tools for building forthops
  code space management
  DP
  inner interpreter
  outer interpreter (token-level interpretation)
  action routines for forthOpTypes

ForthShell
  parsing
  line-level interpretation
  input stream management

ForthVocabulary
  symbol table management
  vocabulary search

ForthThread
  storage for stacks
  SP, RP, IP

ForthInputStack
  current input stream
  pushing and popping streams
  input buffer management

ForthInputStream
  input fetching

ForthParseInfo
  setup for fast vocabulary matching
  interface between ForthShell and ForthVocabulary

ForthForgettable
  does propagation of "forget" to all vocabularies and memory cleanup after forget


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth opcode types

kOpBuiltIn          // low 24 bits is builtin opcode

kOpUserDef          // low 24 bits is opcode

kOpBranch,          // low 24 bits is signed branch offset
kOpBranchNZ,
kOpBranchZ,
kOpCaseBranch,

kOpConstant,        // low 24 bits is signed symbol value

kOpString,          // low 24 bits is immediate string length in longs

kOpAllocLocals,     // low 24 bits is frame size in longs

kOpLocalInt,        // low 24 bits is frame offset in longs
kOpLocalFloat,
kOpLocalDouble,
kOpLocalString,

kOpMethodWithThis,  // low 24 bits is method number

kOpMemberInt,       // low 24 bits is object offset
kOpMemberFloat,
kOpMemberDouble,
kOpMemberString,

kOpLocalUserDefined,             // user can add more optypes starting with this one
kOpMaxLocalUserDefined = 127,    // maximum user defined optype

kOpUserMethods  = 128
// optypes from 128...255 are used to select class methods    

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-


forth extensions for syn2k:

- operations for stating what synops are in a patch,
  and what order they are to be executed in
- operations for initializing synops - settings parameters
  and input and output buffers
- operations for getting note frequency and velocity
- operations for building up sets of patches which are
  selected by midi program number
= operations for defining envelopes and connecting them
  to synops
? is there a way to define the interface so that when
  a new synop is added to syn2k another op doesn't have
  to be added to forth?


table <TABLENAME>
endtable

<TABLENAME> tableLen    leaves number of entries in table on stack

synPatchSet <SETNAME>

synPatch <PATCHNAME>
endPatch



//       11111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890
<############################# Last Line In File ##############################>
