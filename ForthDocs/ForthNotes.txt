         1         2         3         4         5         6         7
1234567890123456789012345678901234567890123456789012345678901234567890123456789
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
TBDs:

! document existing native ops !
! create examples/tests for all native ops !

+ have verbose describe show names of user defined ops

- optimize object field reference code, there is a lot of code like LocalObject,drop
- also optimize stuff like offset,2@,drop

+ add unref op, same op as ->-, it makes object variable:
  o leave object on TOS
  o zeros object variable
  o does nothing if object variable is already null (leaves dnull on TOS)
  o decrements object refcount, but DOES NOT delete object if refcount is 0
  ? what should happen if object already has refcount 0
- add unref method to object containers to do unref for elements
  - add unref methods to iterators
- it looks like OListRemoveHead and OListRemoveTail didn't do a release

- add 'generator' class, it has:
  o lastIP member
  o yield method (saves IP in lastIP and exits)
  o resume method (branches to lastIP if not 0)
  One problem this has is the method can't use local variables, unless I add
  an op to manually dump the stack frame.
  
- redirect current thread console output back to screen before reporting errors
- add native words like %u
- have vlist display the code address of ops
- have error reporting show the param and return stacks, the op that the crash happened in
  -> the param stack might not be up to date, especially in turbo mode
  
? have "woof -> foo( blah )" compile into "woof blah -> foo"

? add properties to classes

- only allow "implements" to be used on abstract interfaces (no data members) - this
  will avoid the problem with accessing data members on secondary interface objects
  which have different data members...

- add support for iterating over files in directories

? add a debug feature where a map is maintained from IP address to file/lineNumber

? add a dynamic array (of longs/pointers

? add a string-to-long map based off CMap
  remember that a charPtr-to-long map would just map from the value of the
  charPtr, not the chars in the string, to the long

? add a "parser stack" - this would allow stuff like:
  + using #ifdef to skip sections of code
  - allowing "/*" based comments to span multiple lines
  - allow easily adding user defined parsers for data definition languages

? does support for inline comments using "/* ....*/" break the "*/" operator

- document how parsing is done - put a breakpoint in ProcessToken and go from there

- add a visual debugger that displays execution of words

- switch from having a different exit opcode for ops with and without locals
  to having an epilogue at the end of an op that "exit" will branch to
  
- "forget" doesn't complain about bogus symbols

- add ops for getting current search & definition vocabularies

- a method for saving and restoring state
  -> maybe use memory mapped files for the dictionary, and only allow the restore if
     the file can be mapped at the same address

- testing
  - automated tests using outputToFile & comparison of test result file to known good file
  - test structure support

- dll support
  - a mechanism for supporting callbacks from external code to forth code
    -> the assembler somewhat minimizes the need for this
    
? fix local strings
  ? string vars are currently not using len/maxLen fields
    - change output-to-string to use the string current & max length fields

- windows support
  - first step: create an app where all the windows stuff is in c++
    - support associating windows controls to forth ops
    - a programmable calculator might be a good first step
  - graphics
  ? do this via DLL support
  
- help system

- faster searches

? generalize the undefined symbol handling mechanism which is used to
 define enums
? add a way to extend parsing for user-defined literal constants
 
? forward referencing
  Problem: forward referencing breaks "forget"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
In a DOS shell:

cvs checkout DIR
	fetch a project or directory from cvs

cvs commit
	recursively commit all changes
		
cvs log FILENAME
	show revision history

cvs diff FILENAME
	show difference between current file & repository
cvs diff -r REVISION FILENAME
	show difference between current file & specified revision

cvs update
	recursively update all directories from repository
	can be used to show what files are not in CVS or what files have been modified
	
cvs log FILENAME
	show history of a file
	
To revert changes to a file, delete the file then do cvs update FILENAME
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
colonOp
 ForthEngine::StartOpDefinition
  ForthVocabulary::AddSymbol
   ForthEngine::AddOp

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Adding an optype checklist:

o add kOpBlah to forthOpType in Forth.h
o add "Blah" to opTypeNames in ForthEngine.h
o (optional) add pretty printing of optype to ForthEngine::DescribeOp
o add OPTYPE_ACTION( BlahAction ) C implementation of optype to ForthInner.cpp
o add BlahAction reference to builtinOptypeAction in ForthInner.cpp
o add blahType x86 assembler implementation of optype to InnerInterp.asm
o add blahType reference to opTypesTable in InnerInterp.asm
o add blahType x86 implementation of optype to InnerInterp.S
o add blahType reference to opTypesTable in InnerInterp.S
o add blahType ARM implementation of optype to InnerInterpARM.S
o add blahType reference to opTypesTable in InnerInterpARM.S

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Gotchas with structure and object support:

1) pointer fields are automatically dereferenced in field selectors, except
   for the final field:    "5 -> woof.pointerToInt" will set the pointerToInt
   field to 5, it will not set the int pointerToInt points at.
2) varAction ops must be the symbol just before a field selector symbol, which
   means that index calculation ops must appear before the varAction op

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 17 2016

I got the ARM assembler versions of snprintf/sscanf/fprintf/fscanf debugged.
I had a few simple mistakes, but when debugging I found out that somehow the
C++ code had been compiled as 16-bit thumb instead of 32-bit arm, the docs
say that arm is the default for gcc, and I couldn't find anywhere I was overriding that.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 14 2016

I looked at the ARM assembly code generated for the snprintf op, I found that
it does special stuff for floating point arguments, stuffing things in FP
registers, which won't work for dynamic argument lists, so I think the only
way to fix that is to only use the vsnprintf procedure.
I should do the same thing for the fprintf, fscanf, sscanf ops.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 13 2016

I've got the pipe logger programs working on both windows and ARM.
The ARM forth assembler version is mostly working, it passes forthtest, but it
crashes when I try printf/sprintf/snprintf.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 10 2016

I added a named pipe logger program which just waits for a client to connect
to pipe ForthLogPipe and then prints everything logged to it.

Next I need to implement a similar thing for Linux and use it to debug the
ARM assembler version of Forth which currently is crashing during startup.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 22 2016

I decided to go back to getting the no-asm-inner-interpreter build working first
on rpi3.  My first step was to test it on x86, and forthtest.txt worked, but
ansitest.txt failed.
-> the c++ version of 'sp' was wrong for the fetch case - it first made room
   on the stack, which decremented sp, then stored sp in the top element of
   the stack.  This meant that on an empty stack doing "sp s0 -" would not
   return 0, so the test code failed.

I am still having the build problem where changing the custom build rule for InnerInterp.asm
to not define ASM_INNER_INTERP doesn't work - I finally tracked it down to the
fact that when I change that in the Debug configuration, the change actually
shows up in the Debug Midi configuration.  I have no idea why this happens or
how to fix it.  For now I just have to change the ForthLib defines to handle C++
and edit InnerInterp.asm and change the ifdef symbol to something other than ASM_INNER_INTERP.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 21 2016

I got my Raspberry Pi 3 working as a git client and updated the Makefile.
I got it compiling, it needs some work in the inner interpreter assembler code.
- I think datan2Bop was broken, it was only taking one argument
- a few ops are undefined, look for a TODO near the end of the file
- I haven't looked at the changes to the optypes table - there are definitely some changes there
- I haven't checked for other core changes
  ? were there output system changes that affected assembly code
- forth crashes on startup
- I think ->o may be defined to be the wrong opcode (->, should be ->+) in the windows version
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 21 2016

I changed the builtin classes to have the first character capitalized, so class
and object became Class and Object, oArray and oList became OArray and OList, etc.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 28 2015

I've been trying to get SDL_TTF to work, but I keep getting a bogus surface
back from the TTF_RenderText_XXX calls.  I've done the equivalent set of SDL
calls in a CPP program successfully.

DOH! I updated sdl_ttf.txt to match version 2, but it was still loading the
version 1 sdl_ttf DLL.  Updating it to use version 2 fixed the problems.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 6 2015

I have a mostly working implementtation of struct initialization ops.

Currently if you define structs or objects which have string fields, the strings maxLength field is uninitialized.
This change would add an automatically generated init op whenever any struct is defined which
contains strings or contains structs which themself have an init op.
A struct which contains an object member which contains strings would not need to have an init op,
when the object is created it will take care of initing its strings.
A secondary motivation for this change is to allow user explicit creation of the equivalent of C++ constructors.

Assuming we create an _init op for each struct which has either string fields or struct fields which
have their own _init op, the code generated would look something like this:

struct: structA
  int iX
  20 string sY
;struct

: _init  // for structA
  // TOS: ptr to struct
  offsetOf sY + 20 initString
;

struct: structB
  int iR
  30 string sQ
  structA m
  4 arrayOf 6 string sT
  3 arrayOf structA w
;struct

: _init  // for structB
  dup offsetOf sQ + 30 initString
  dup offsetOf m + structA:_init
  dup offsetOf sT + 4 6 initStringArray
  offsetOf w + 3 ' structA:_init initStructArray
;

struct: structC extends structA
  structB sb
  10 string baba
;struct

: _init  // for structC
  dup structA:_init		// init parent
  dup offsetOf sb + structB:_init
  offsetOf baba + 10 initString
;
  
4 types of initializations:
o string
o string array
o struct
o struct array

4 situations:
o global instance
o local instance
o struct field
o object member

+ create init op at struct/class definition time
  + save info about fields which need initialization when fields are defined
  + define new init op and compile its code when struct definition is complete
  + deal with structure extension
    + if new struct's parent struct has an init op, and this struct adds no new initable fields, use parents init op
  + if new struct has initable fields, compile parents init op at start
+ compile init op for local instances
  + string (already done)
  + string array (already done)
  + struct
  + struct array
+ execute init op for global instances
  + string (already done)
  + string array (already done?)
  + struct
  + struct array
+ invoke init op at end of 'new'

? add an op for getting the structIndex given a struct/class name
  - have definition of "_init" in struct or class definitions

For some reason, when you start a struct definition, it doesn't change the
definitions vocab to be the new struct vocab, which is unlike class definitions,
which do change the definitions vocab.  Why did I do that?

There was a bug (I think) in memberStringArrayType and fieldStringArrayType, they
were jumping to opEntry instead of stringEntry, I can't see how that could be
right, so I changed it.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 21 2015

I have added the member variable definitions to builtin classes so that they
can be extended.  There is a remaining problem with that, if the extension
classes need there own newOp there is no builtin mechanism to do both.

Currently there are several situations where you can define an old-style string
that leaves the string max-length field uninitialized.

Working cases:
o global string
o local string
Failing cases:
o string inside a global struct
o string inside a local struct
o string members

There is a initMemberString <MEMBER_NAME> immediate op for initializing string
members, but it would be much nicer for this to happen automatically.

o a struct needs to initialize its string members
o a struct needs to initialize its struct members recursively
o an object needs to initialize its string members
o an object needs to initialize its struct members
o add an array of string field offsets to struct vocabularies

A struct can have an initializer opcode which initializes its string and struct fields.

Struct initializer:
o takes a pointer to base of struct, returns nothing
o is a sequence of ops which init either a string or a struct field

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 15 2015

I added an OVocabulary builtin class to allow searching and manipulating vocabularies.
I also updated the SDL libraries to support SDL2.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 30 2015

I changed defining words like colon, struct:, class: etc. to use the shell
stack to make tracking down nesting errors easier.
I added ops for manipulating the shell stack so it can be used in creating
other defining words.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 21 2015

I added atc to git.

I had forgotten that classes which define their own delete method need to do a
super.delete to actually free the memory malloced to the object.

There is still a mysterious 100 byte allocation leftover after running atc.

Also, I moved the atc files from the sandbox level into an atc subdirectory,
after running the game and exiting the atc subdir contains a _blocks.blk file.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 16 2015

I've been working on the atc game a bit.
There is definitely a problem with forgetting global variables, at least global
object variables.  For a simple test case, try running forthtest two times in a
row.  forthtest requires testbase.txt, which uses some OString global vars, the
second time you run it assigning to the global OStrings throws an exception.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 7 2015

I need to look at OString, define how size/length/resize relate, using
resize( length 1- ) should trim off last character of string, it doesn't.
Decide if the size of an OString should always be a multiple of 4.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 26 2015

There were 2 problems in InnerInterp.S I found while debugging forthtest on the
Linux build:

+ exitLBop was still using ECX instead of ESI
+ localStringStore - the source string pointer in ECX was getting clobbered when I
  called strlen

The second problem could happen in other places - I used to be using ESI for a
bunch of things, ESI is preserved by clib routines, now I am using ECX in its
place, ECX is not preserved by clib.

The Linux build can now run forthtest and biclasstest without any errors.

I don't know if it is a new problem, but if you run forthtest 2 times in a row,
it will crash the second time when it tries to do a testBuff.set, it could be
a problem with global object variables.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 25 2015

I'm working on getting tracing to work in fast and slow modes, mostly to make
debugging the Linux version easier.  The Linux version passes forthtest in
no-assembler mode, but crashes in assembler mode.  Knowing what opcode was
being executed at the time of crash would be a big help.  I am thinking of
repurposing the trace engine state to not just be used when switching the
fast/slow or trace flags, and having it be used for single stepping.

The problem I'm trying to figure out is how to run in slow mode with tracing
on and with the assembler inner interpreter used for native ops.  Right now
that would mean InnerInterpreter would dispatch to NativeAction
Call stack when executing a regular forth op from outer interpreter:
	ForthDebug.exe!InnerInterpreter(ForthCoreState * pCore) Line 2375	C++
 	ForthDebug.exe!ForthEngine::ExecuteOps(long * pOps) Line 1914	C++
 	ForthDebug.exe!ForthEngine::ExecuteOneOp(long opCode) Line 1884	C++
 	ForthDebug.exe!ForthVocabulary::ProcessEntry(long * pEntry) Line 634	C++
 	ForthDebug.exe!ForthEngine::ProcessToken(ForthParseInfo * pInfo) Line 2546	C++
 	ForthDebug.exe!ForthShell::InterpretLine(const char * pSrcLine) Line 597	C++
---
Who calls InnerInterpreter/ForthEngine::ExecuteOneOp/ForthEngine::ExecuteOps:

	InnerInterpreter
ForthEngine::ExecuteOps( long *)
ForthEngine::ExecuteOps( ForthCoreState* )
ForthThread::RunLoop
ForthThread::Run

	InnerInterpreterFast
ForthEngine::ExecuteOps( long *)
ForthEngine::ExecuteOps( ForthCoreState* )
ForthThread::RunLoop
ForthThread::Run

	ForthEngine::ExecuteOps( long *)
ForthEngine::ExecuteOneOp
ForthEngine::ExecuteOneMethod
ForthTypesManager::ProcessSymbol

	ForthEngine::ExecuteOneOp
objectReleaseMethod
classCreateMethod
doOpExecute - op var default action
_doOpVarop
MethodWithThisAction
MethodWithTOSAction
XXXComboAction
doMethodOp ?
newOp
doNewOp
executeBop
ForthStructVocabulary::DefineInstance ? initialization of ptr-to-struct instance?
ForthNativeType::DefineInstance ? init global single variable?
ForthNativeType::DefineInstance ? init global single string variable?
ForthVocabulary::ProcessEntry
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 19 2015

I spent the weekend getting Ubuntu running on virtual box to bring the Linux
version up to date.  It is almost compiling, the inner interpreter has a fair
number of changes since the last working x86 linux build, most notably the
change of the IP register from ECX to ESI.  There is something wierd going on
with core_gas.inc, changes to it aren't reflected when you rebuild.
Could it somehow be getting the file from a different path when it includes it?
I did copy the old forth eclipse projects from the machine I originally did the
linux version on, maybe it has some screwy include paths setup.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 12 2015

There is also a problem with forget - I forgot a colon definition, and a global
object variable which was defined before the colon definition was deleted.

The bug I spent over a day chasing was because when a release caused an object
to be deleted, the delete was done by calling ForthEngine::ExecuteOneMethod,
which had the side effect of setting the core state to 'done', which caused the
inner interpreter to exit out of display.init right after the delete, and so it
didn't execute the exitML code, so the next thing executed was trying to execute
bad data out of the stack frame of the previous ExecuteOneOp invocation.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 11 2015

End of the night: there is still a crash when running atc in no-asm mode.  The
problem is triggered by the deleting of an iterator inside a method under certain
circumstances - a method calls a method on another class of object, that method
creates, uses and deletes the iterator - the crash doesn't happen if you don't
delete the iterator and just let it leak.

I added printing out of class:method when tracing MethodWithTOS or MethodWithThis opcodes.
---
I think the 'test[' bug is because ForthShell::InterpretLine loops until a
line empty flag is set, and it ignores the input stream stack depth, so when
an expression stream inside a buffer stream reaches the end it is returning
without executing the stuff at the end of the buffer stream after the parenthesized
expression.  That doesn't explain how the stuff at the end of the buffer eventually
does get executed.

forthtest has been broken since I replaced the shell stack based parenthesis
implementation with expression streams.

The changes to fix forthtest:
+ $evaluate needed to be change to use ForthShell::RunOneStream not ProcessLine
+ the loop in ForthShell::RunOneStream needed to be changed from exiting as soon
  as the input stream changed to exiting as soon as the input stream became the
  original input stream
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 10 2015

End of a long unfinished debugging session:
forthtest is failing because 'test[' is failing sometimes when it contains a
parenthesized expression, it may have something to do with quoted characters or
strings, maybe not.  'test[' evaluates a string, so it is using a buffer input
stream, and the paren expression means it is using an expression stream inside the
buffer stream.  After the expression stream has been interpreted, it is popped and
the buffer stream should be effectively empty, so it should also immediately pop,
but it looks like instead of checking the read and write offsets on the main stream
buffer it is looking at the pointers to its input data buffer, and the src pointer
mpDataBuffer is still pointing to the start of the input data buffer.  The input data
buffer is there to permit buffer streams to contain multiple lines, I think that was
to support interpreting stuff coming from ForthGUI.  I don't know why my recent
changes triggered this bug yet.
? but ForthBufferInputStream::GetLine advances mpDataBuffer as it copies data from
  the input buffer to the main buffer
  -> GetLine isn't called for the first line in the buffer - I tried adding a
     GetLine at the end of the buffers stream constructor, it didn't fix the problem
! the '0=' after the strcmp is being executed after 'test[' has already failed
---
I tried fixing the potential 64-bit object dfetch problem, and after doing it
nothing worked.  I backed out those changes

forthtest.txt fails for both fast and slow modes:
- "string(200) svar" fails because after the end paren is parsed, "200 string"
  is interpreted, but when it tries to get the next token, it gets an empty
  string instead of "svar" because the current input stream is the string stream
  created by the parenthesized expression code, which is empty at that point.
ansitest.txt works for slow mode
atc.txt works for fast and slow mods

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 9 2015

I did more work on object show methods, and I ran into a problem with the double
map and array show methods, because I implemented them as just the long array
and show with different show methods, forgetting that longs get word reversed
when they are moved between memory and the stack to be ansi forth compliant,
but that I hadn't done that with the stack representation of doubles.  If I
want to keep the double array and map I need to give them their own implementation
methods which don't do the word reversal.

A more important problem is that I noticed that there is only one 64-bit fetch op '2@',
there is no 64-bit fetch which doesn't do word reversal, I need to check if any
code compiled for accessing object locals or fields are using 2@.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 5 2015

I added ForthShowContext, which is a lazy created member of ForthThread, to
hold info needed while showing objects, including the show depth, set of
objects which have already been shown, and in the future show options like
pretty print, hide __id, and showing objects in nested form.

I was debugging it using atc, and I ran into a weird crash where suddenly the
IP became NULL.  I finally tracked it down to another case of me putting the
first local object declaration inside an if statement, so the local frame was
not being allocated when the if true branch wasn't taken, and the exitL at
the end was corrupting the state.  This type of error is too easy to cause,
and is too hard to track down when it happens.

One good thing that came out of this is that I added a way for setTrace to
work inside of definitions - previously a setTrace inside a definition usually
had no effect during execution until the program had returned to the outer
interpreter since you were typically staying inside the assembler inner
interpreter.  I changed setTrace to set the status to kResultTrace, which
causes the asm interp to exit, and I changed the engine ExecuteOps to loop
while the status is kResultTrace.  I need to take another look at it, I think
it still doesn't do what I want, I am probably going from the asm interp right
back into it since fast mode hasn't changed.

Another problem is that the trace output is screwed up, particularly when doing
MethodWithTOS calls.  It might be that the stack trace is being shown after the
method returns, and the method has done its own stack trace on the same line?
Also look at output from delete methods which are triggered by final releases.

? is there a way to display the class/method for MethodWithTos
? is there symbolic output for CCode types
  ? is there symbolic output for BuiltinClass methods
? is MethodWithThis ever used
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 28 2015

The recursive show method works great, except when you have cyclic references,
which actually happens a lot.  To try to fix this, I am adding an optional per
thread object (ForthShowContext) which keeps track of objects which have already
been shown.

The current __type field will be replaced with __objid which will combine the
class name and an index which increments for each object shown, so if you did
show on an array the first __objid would be 'OArray_0'.  While recursively showing,
if an object is reached which has already been shown, it is displayed as an @ char
folled by the objid, so the above array would appear as @OArray_0.

When you do object.show, it either goes to objectShowMethod for user defined
types, or it goes to a builtin-class method like OArrayShowMethod.

  ObjectShowMethod
    ForthStructVocabulary::ShowData on the root object
	  ForthShowObject on any object fields

  OArrayShowMethod
    ForthShowObject on each element
	  ForthEngine::ExecuteOneMethod
	    either ObjectShowMethod or a builtin-class ShowMethod

? is ForthShowObject the right place to do the @object substitution
? how do you know when it is safe to clear the list of shown objects
  o ForthShowObject and builtin-class ShowMethods must call showContext Begin and End
    ? maybe Begin adds an object to the map
  The builtin container classes don't have to filter out already shown object,
  they just call ForthShowObject which does the filtering for them
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 6 2015

I added recursive descent to object/struct show, and also custom show methods
for all the builtin container classes.  They are mostly untested.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 5 2015

I added a first cut at 'show' for structs and objects.  The code currently just
shows the native types.

The next steps:
o add recursive descent of nested structs/objects
o add extensibility by invoking the show method for nested objects
o add show methods for builtin container classes

The show method probably should have these parameters:
o maximum nesting depth
o flag telling wether to display __refCount and __type
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2015

I wrote a parenthesized expression evaluator.  Previously if a method returned
an object and you tried to invoke a method on it, the parameters for the original
and second method were computed in the wrong order.

The code is almost working, the problems I know about are:
- double quote support is broken
- there are some cases where a space is missing when groups of tokens are combined
- there are some cases were extra spaces are added between tokens
- single quote support is untested
- multi-line support is untested
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 8 2015

My current goal is to make using client/server for debugging, having trace output
go to the server console window.

o ForthLib/StdAfx.h defines TRACE macro
  o TRACE uses CustomTrace routine, defined in ForthEngine
o Forth.h defines TRACE_PRINTS/TRACE_OUTER_INTERPRETER/TRACE_SHELL for categories
  which will have trace ability compiled in - if these are defined, SPEW_XXX
  macros are defined to be TRACE, otherwise SPEW_XXX are undefined
o ForthEngine::TraceOut sends output to either the console or to a custom defined trace output routine
  o defaultTraceOutRoutine calls TRACE
  o ForthGuiDlg defines a trace routine which sends trace output to debug pane
  o ForthEngine & ForthShell methods conditionally call TraceOut if trace enable flags are set
    o ForthEngine::TraceOp calls TraceOut
    o ForthEngine::TraceStack calls TraceOut
o Only MSDEV builds have TRACE functional, for all others it is a variadic no-op

ForthEngine::TraceOut  ->  defaultTraceOutRoutine  ->  TRACE
ForthEngine::TraceOut  ->  ForthEngine::ConsoleOut
TRACE  ->  CustomTrace  ->  OutputDebugString

ForthEngine::ConsoleOut  ->  ForthConsoleStringOut  ->  pCore->consoleOutStream->pOutFuncs->outString

Overall plan:
- change TraceOut to be variadic
? make as many things go through TraceOut as possible
  ? or should this be outside of ForthEngine, so it can be invoked before engine exists
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 13 2015

I started working on an implementation of the atc game and I quickly ran into
a major limitation of parenthesized expression support - it can't handle any
expressions like a(b).c(d) where the result of a parenthesized expression is
an object that has a method with parameters invoked on it.  That should be
compiled as "d b a.c" but currently fails as soon as it hits ".c".

This is a difficult problem, because the current outer interpreter parses a
token and immediately processes it, fixing this problem would require parsing
an entire parenthesized expression before processing any of its tokens.
It is also common to have expressions span multiple lines, which the current
implementation doesn't support.

My current planned implementation is this:
In parseToken, when you hit a left paren, enter parenthesized expression scan mode.
In this mode:
o scan input into a temp buffer, making a list of tokens found
  o scanning deals with double-slash and backslash comments, comments are
    not entered into temp buffer
  o tokens have type, buffer offset, number of characters
    o type is simple, leftParen, rightParen, characterLiteral, stringLiteral
  o keep track of parenthesized expression level
  o when paren level reaches zero, exit parenExpr scan mode
o perform multiple passes over token list, reducing the level of parenthesized
  expressions with each scan
o 
a(b.c(1).d(2) e f.g(3)).h(4).i(5 j)
5 j  4  b.c(1).d(2) e f.g(3)  a.h.i
5 j  4  2 1 b.c.d  e  3 f.g  a.h.i

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 1 2015

I moved Forth development from Visual Studio 2008 under Windows Vista to Visual
Studion 2013 under Windows 7 today.  The program was working fine, but pretty
soon I ran into strange crashes like "Access violation executing location 0x005FF7DC."
where the address was a valid address inside the dictionary.  The problem turned
out to be the Data Execution Protection feature, it was triggered whenever I
tried to execute an op which was defined in assembler.  The solution was to
allocate the dictionary memory using VirtualAlloc with flags which say to allow
execution in that memory block.

I also had to change the tmpnam op, it had been returning a filename that
started with '\', so I guess it was trying to put the temp file in the root
directory, which caused opens to fail.  My solution was to prepend a '.' to
the path, kinda hacky but it works so far.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 7 2014

I added block file support to the kernel.  It is only partially tested, I
haven't even tried 'load' or 'thru' yet.

In testing block support I found a bug in local array support - the vocab
entries for local arrays actually had the offset for the top of the array
not the base.
There was also a crash bug with the compilation of the allocLocals opcode when a
local array was the first declared local.

I added a new interpreter syntax for local variable references - &var will
now leave a local variable reference on TOS.  This is currently only implemented
for locals, I should add it at least for member variables, and maybe for
global variables.

There are multiple places where file operations are being done directly instead
of thru the shell, I need to clean those up and test client/server in general.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 29 2014

I replaced ansiMode with 'features' which is a fake variable that allows you
to change individual ansi features.
The next ansi compatability change is string variables.  I'm going to change
them from having 2 ints before the characters to having 2 bytes.  This will
limit them from being able to have strings longer than 255 bytes, but will
make compatability much easier.  I should add a builtin buffer type which acts
like the old string, with an added read offset field.
The next change after that should be floating point.  I should probably just
just change all my floating point stuff to be ansi compliant instead of adding
compatability ops and feature flags.
Most forth implementations use a separate FP stack, since this is more efficient
with hardware.  This would make moving the floating point ops out of the kernel
easy, most of the ops are just a single FP instruction.  It would make the
no assembler version a bit harder, it would need to emulate the FP stack.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 28 2014

A change I made to get tetris to work broke ansitest.  The underlying problem
is that ForthShell::ParseToken leaves the buffer pointer pointing to the
delimiter of the token it just parsed, but ForthShell::GetToken leaves the
pointer pointing at the character after the delimiter.  The tetris code builds
its tetris pieces using s" indirectly executed by ' execute
  s" abc" type
    types "abc"
  : boo ' execute ; boo s" abc" type
    types "bc"

Changing ParseToken seems dangerous, but I changed it to move past the terminating
space or tab (not null though), and it seems to work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 27 2014

I made a maze generator for work yesterday, it works, but usually fails with
a deadend because it doesn't have backtracking.  While working on it, I found
a few problems:

1) I ran into a crash because the first local variable I declared was inside a loop
2) I was getting bad opcode errors when I reloaded a file in autoforget.

The autoforget problem was because ForthForgettable::ForgetPropagate was first going
down the chain, getting each forgettable to process the forget, then going down
the chain a second time, deleting any forgettables which were above the new DP.
The problem was that a global object existed whose class had been forgotten the
first time through the forgettable chain, and on the second pass when the global
object was deleted (I think) it was trying to execute its delete method, but
the opcode was bad because the class had already been forgotten.  I tried
swapping the order of the passes, but now I'm getting other errors which seem
to be because autoforget isn't really forgetting anything. 
Undoing that change didn't fix the problem, forgetting some ops causes the ops
to be removed from the engines op table, but not removed from vocabularies.

The bug is a strange one - in ForthVocabulary::ForgetOp for some reason I had
code for processing constant entries that was causing the forget to always
terminate the first time it hit a constant (an enum in this case).  The code
was bizarre, it was trying to get the structure index from the 2nd word of
value field, which is just the kBaseTypeUserDefinition, turns it into an
opcode, and uses that to figure out if it should forget the constant.
I removed the constant case, and added to the default case to have the
forget search continue with the next entry.
After that, I put back in the ForgetPropagate change, and it appears to work.

The fcp.f chess program had been working, but failed when I tried it recently.
The problem is that I had to change how $word worked to make tetris work, $word
has always skipped all initial delimiters, and tetris created its pieces using
a bunch of string which started with multiple whitespace characters.  I changed
ForthShell::GetToken to take a skipLeadingWhitespace flag which defaulted to true,
which $word set to false.  What I didn't know is that on entry to GetToken, the
next character was actually the delimiter to the previous word, so $word was
always terminating immediately and giving back an empty word.  I changed this
to have it break out of the skip-initial-whitespace loop after the first char
if the skip flag was false.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 24 2014

Crazy idea that I've probably had before:

Move the optype bits to the bottom 8 bits, and have the optypes which have
the bottom 2 bits zero be used for native ops - that way the opcode is the
same as the actual code address.  The next code for continuing on to the
next native op is inlined, the inner interpreter branch register is used
for all non-native types.

Native ops would end with this macro:

next macro:
	mov eax, [esi]
	add esi, 4
	test eax, 3
	jnz notNative
	jmp eax
notNative:
	jmp edi
	
	
edi points to this inner interp dispatcher:

innerDispatch:
	mov	[ebp].FCore.IPtr, esi
	mov	[ebp].FCore.SPtr, edx
	mov ebx, eax
	and eax, 255
	mov ecx, [ebp].FCore.ops
	mov ecx, [ecx+eax*4]
	jmp ecx

o call this 'crack forth' for using the cracks between direct threaded
  native addresses for token threaded opcodes
  o source file type is .c4
o there is no longer any checking for a bad native opcode
o if native ops can be immediate, immediacy cannot be determined from the opcode
o we lose a level of indirection, we can't patch the ops table to change what
  native code an opcode dispatches to, which isn't currently used
o this change makes saving a relocatable image harder - it would probably
  require diffing 2 images saved with different base offsets.
o this makes compiling combo ops harder - there would need to be a table of
  the N native combo ops which can be combo-ed
  -> maybe the vocabulary entry for combo-able ops would have the optable index

A related change I've been thinking about is to replace user defined ops with
an optype with the opval being the longword offset from the base of the dictionary.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 22 2014

I've got all the ANSI test problems fixed.
Fixing the 'source' test required me to jump into the ForthBufferInputStream
code, and it is a little messed up.  It sets the buffer size to 4k, plus it
allocates another buffer that is as big as its input buffer and copies the
entire input buffer there.  The code could have gotten this messy because it
is used both for 'evaluate' which uses a single line of input just once,
and ForthGuiDialog, which has a mutli-line buffer that it keeps reusing.

I started working on making saved images, but ran out of steam.  Loading up
a fairly full kernel is instantaneous in release, it does take a while in debug,
mainly because of all the debug spew.

Before I started using the ansi compliance test, I had first ported a robots
game (robots.fth) and a newer version of the chess program (FCP.F).  The ported
version of robots was working fine, I kept running into more and more problems
porting FCP, which is what convinced me to try to get closer to ansi.
After getting ansitest working, I tried the ported version of robots again,
and it was now crashing.  The main problem was a bug in the original code,
in a few places it was using int store/fetch on a byte array, so it was clobbering
code just after the array.  It didn't fail before because I had 'allot' allocate
longs instead of bytes, when I fixed that the bug showed up.

My goal is to get ansi sources to work with little or no changes.  I've setup
a new 'external' directory for ansi sources.  The minimally modified robots.fth
still fails when you try to make your first move, it looks like it is executing
an abort opcode.
-> my '?csp' compatability word had an unterminated 'if'
A lot of debugging could have been prevented by either:
1) having ';' detect a non-empty shell stack
2) having the abort opcode have a parameter indicating 'bad-if' (combo op?)

fcp.f runs with no changes, but it crashes after a dozen or so moves, it looks
like an array of ops is getting written over by part of a string.
YOW! The bug was triggered by the source line:
  ' sortKiller2 , ' sortKiller3 , ' sortKiller4 , ' sort , ' sortNoop ,
The real cause of the bug was the multi-character constant code, which allows
character constants surrounded by single quotes of up to 8 characters, usually
they are just 1 character in length.  The tick sort near the end of the line
was being turned in a characer constant { sort , }, then sortNoop was being
executed instead of compiled, and finally comma was executed, which put the
first 4 chars of the constant { sor} in the dictionary.
The fix was to change the single quote handling code to reject the symbol
if it contains a whitespace or tab, unless it is preceeded by a backslash.
This bug could still be triggered if the user defines words like "'foo\".
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 20 2014

I've got the 64-bit integer changes for ANSI compliance in, and ansitest works
aside from the following problems:
1) a test of 'source' which seems to require that 's"' which pushes a text
   block and the result of evaluating s" source" return the exact same address
   and length
2) a test which prints 0...9 separated by a space is actually separated by two spaces 
3) a test of 'accept' which looks like it has an extra linefeed at the end

I'm not feeling good about the 64-bit integer changes - they require making
some changes that will make 64-bit float code much more messy and not screwing
up any code which tries to access a long long in memory directly.  I am not
willing to change 64-bit float code to embrace this madness.  The first thing
I should do is categorize all the situations where 64-bit values occur:

o on pstack/rstack
o as local vars
o as member vars
o as struct members
o as params to DLL calls
o as literals inlined in code

I need to find a simple way to make these work for ANSI compliance.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 19 2014

I've started making the changes to make 64-bit integers ANSI compliant.  The
changes aren't that hard, but I don't know how 64-bit floats should relate to
this, having them represented reversed on the stack would make using 64-bit
ops like dlit, 2@!++, and 2@@++ less error prone.

CREATE GN-BUF 0 C,
: GN-STRING	GN-BUF 1 ;
: GN-CONSUMED	GN-BUF CHAR+ 0 ;
: GN'		[CHAR] ' WORD CHAR+ C@ GN-BUF C!  GN-STRING ;

{ 1 0 GN' 1' >NUMBER -> BASE @ 1+ 0 GN-CONSUMED }

just before >NUMBER:
o GN-BUF has '1' in first pos
o stack 9s: 1 0 GN-BUF 1

after >NUMBER:
o stack is: 1 0 GN-BUF+1 0
o stack should be : 11 0 GN-BUF+1 0


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 16 2014

John Hayes ANSI compatability test has pointed out 2 somewhat major changes
I need to make:

1) ANSI forth specifies the stack word order for 64-bit numbers to be the
   opposite of what I've done, which is the 'natural' order - natural in the
   sense that it is what the C++ compiler generates and C calls expect, that
   is that the lower order word is at a lower address.
2) ANSI forth allows control flow words to be mixed and matched, I need to
   remove some of the error checking to allow this, I need to replace the
   existing tags like 'begin' and 'if' with more generic ones like 'looptop'
   and 'forward branch'.
   
I'm going to put off the 64-bit order changes for now, I'm getting the tests
to work by doing an order switch in the test.
+ modified control flow words to be more flexible

I changed the assembler inner interpreter to use ESI for the instruction pointer
instead of ECX.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 15 2014

I've made a lot of changes trying to get closer to ANSI forth compatability,
using the fcp.f chess program to expose incompatabilities.  Notable changes:

o better support for case insensitive symbol search
o more words which search vocabs search chain instead of top vocab
o $word & blword leave a byte for counted string length below returned pointer
o support of hex literals starting with '$' when all else fails
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 26 2014

I'm looking at implementing an assembler version of 'does':

: definingWord
  builds
    buildsBody
  does
    doesBody
;

: definingWord
  builds
    buildsBody
  doescode
    doesBodyInAssembler

I can think of 2 ways to do it:

1) the words created by definingWord are high-level, and begin with a
   low-level opcode, which is the 'doescode' part of the definition.  This
   opcode is defined by doesBodyInAssembler, it gets the pointer to the
   definedWord data in IP and must pop the new IP off the rstack before exiting.
2) the words created by definingWord are low-level, and begin with a call to
   doesBodyInAssembler, which gets the pointer to the definedWord data by popping
   it off the system stack.
I went with option 1.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 25 2014

I got the output stream redirection working again, at least to the point
where redirection to string works in forthtest, and there are no undeleted
objects upon exiting forth.

One notable change that occured while debugging is that previously all delete
method execution was being done using the engine primary thread/core, which would have
caused problem when delete methods were called on objects which were allocated
in other threads.

Default console out objects need to be defined as singletons which ignore
a delete triggered by release, since they will be shared by all threads in
an engine.  Default console out objects are only defined when console out is
always redirected somewhere other than the normal user console (stdout), such
as when running in client/server or in the ForthGui app.

A possible fix for the crash

- when I was getting errors while output was redirected to a string, the
  error output was still being sent to the string - the error should have
  caused output to be redirected back to the default console before printing
  error output strings
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 17 2014

I got console output using stream objects mostly working.  While I was doing it
I ran into 3 strange things:

1) When I looked at my changes with 'git dtd', when I exited out of Beyond
   compare, all my changes were being undone.  This happened at least 4 times.
2) When debugging the ForthGui app, MSDEV wouldn't let me set breakpoints after
   recompiling unless I did a full rebuild, claiming that the source had changed.
3) Redirection in ForthGui wasn't working, and I tracked it down to ForthEngine::GetCoreState
   returning an invalid value - changing it to not be inline fixed the problem,
   but does not explain it.
   
One big downside to using output stream objects is that it makes error recovery
much more likely to fail catastrophically - re-initializing after an error can
cause the release/delete of stream objects, and if they are already deleted
or corrupted, this could cause another error.

I refactored things so that OOutStream wasn't completely abstract, and output
streams have an optional pointer to a block of functions for outputting chars, blocks
or strings, and these functions can called directly without the overhead of
setting the current object to the output stream and pushing/popping arguments.
ForthGui app appears to be working.

- ops for redirecting output (replacements for outTOString/File/Screen) aren't done yet.
- reference counting when setting/resetting streams isn't right yet
- client/server is written but untested
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 5 2014

I decided to try to get single stepping threads working as a first step toward
a forth debugger.  There were a bunch of bugs in the assembler version which
were pretty easy to fix, there is a more difficult set of bugs left which
are caused by how the inner interpreter is exited whenever state isn't OK.
To avoid having the inner interpreter be checking state before every dispatch,
I have any code which sets state to non-OK branch to interpLoopExit, which
does a return which only works if the inner interpreter was entered by calling
InnerInterpreterFast, and fails if InterpretOneOpFast was called.
-> Fixed by having InterpretOneOpFast call the inner interpreter instead of
   branching to it - ops which have an error will return and get to the code
   right after the call, ops which exit normally will get to InterpretOneOpFast
   exit code which discards the return address.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 28 2014

I decided to scrap the combo op stuff for now, and concentrate on building
things using forth as it is now to determine what changes need to be made.
I had turned off the ASM_INNER_INTERPRETER define so that I could debug the
combo op code in C++, but when I turned it back on, I am now getting undefined
symbols for all the assembler implemented stuff - there is a linker error for
_InitAsmTables missing.  I tried changing the asm code to add an underscore, that
didn't fix it, maybe I somehow got the linker to now include the object file for
InnerInterp.asm?
-> the custom build rule for InnerInterp.asm wasn't defining ASM_INNER_INTERPRETER,
   and the assembly code has ifdefs that require it.
After fixing this, the debug build works, but the release build fails with
undefined externals for all the single precision float routines.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 1 2014

I moved the opcode compilation/uncompilation from ForthEngine to its own class,
ForthOpcodeCompiler, which is still part of ForthEngine.cpp for now.
While debugging it, I added setTrace( 255 ), and this made the tests crash.
The crash happened because the definition for checkResults got overwritten by
the trace text output.  I haven't chased down how that happens yet.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 12 2014

I got client/server working on both Windows and Ubuntu again.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 11 2014

I tried to get client/server working between Windows and Ubuntu, in preparation
for getting an Android build working, where client/server will be crucial, since
developing on a tablet without a keyboard would be insane.
Ubuntu in its amazing brain-deadness intentionally create /etc/hosts to have
an entry that maps your machine name to 127.0.1.1, an alternate loopback address,
so having the 'server' op print out the ip address for clients to connect to hasn't
worked so far.  I tried using the newer non-deprecated getaddrinfo call, but it
has the same problem as the deprecated gethostbyname call.  There must be a way
to do it, since ifconfig can do it.
I change 'client' to not take the ip address as a ulong on TOS to taking a string,
then found out that client/server is broken in general - it doesn't even work
with localhost between client and server on windows.  On the plus side, this
should allow using regular hostnames and even IPv6 addresses.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 13 2014

I added the missing parts of localRefOp and memberRefOp combos.
I took a stab at fixing the OpZBranch and OpBranch combo types.
Neither of these is currently used so they are both untested.
InnerInterp.S and InnerInterpARM.S are both missing squished literals and the
newer combo op types.
I should add having the combo types be used before porting them over to the
other assembler implementations.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 10 2014

I added squished long literals to the engine.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 9 2014

I added the squished float/double literals to the engine.  I haven't done the
linux or ARM versions of the assembly code

While doing it I noticed that there are some inconsistencies in the optype support:
o there is an ozbComboType which has assembly code but isn't in the optypes table,
  and doesn't have an optype assigned to it in Forth.h
o ForthInner.cpp has 2 combo op types which don't have optypes assigned to them
  and aren't in the assembler version: LocalRefOpComboAction and MemberRefOpComboAction
o ForthInner.cpp doesn't have optype handlers for squished floats/doubles or ozbComboType

Also ozbComboType looks like it won't work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 8 2014

I want to add single and double precision FP literal opTypes.  The overall idea is
that a float would be fit into 24 bits by throwing away 3 bits of exponent and
5 bits of mantissa, and a double would be done by throwing away 11 bits of
exponent and 29 bits of mantissa.

The outer interpreter will only compile the squished float/double types when
the value could be represented exactly in the compressed form.
There should be some syntax for forcing the squished format to be used - maybe
adding '~' to the start of a FP literal?

0x3f800000 == 1.0

0011 1111 1000 0000
0 01111111   0000000
+    127   1.0000000

0x41280000  == 10.5

0100 0001 0010 1000
0 10000010   0101000
+     130   1010.1000
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 7 2014

Added single precision FP ops (fsin, fcos, fpow, ...).  For some reason, I had
to add extern references to the single precision library functions to ForthMain
to make the build work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 4 2014

While trying to implement generators I realized that there was a critical
flaw in how I handle object lifetimes.  There was no safe way for a method to
create an object and return it without retaining a reference to it.
The solution was to provide a way for a container to give up its reference to
an object without deleting the object if the container was the last reference
to the object.  Effectively, this allows an object reference to be left on the
stack even though its reference count is 0, which is much like the state that
an object is in when it is first created - the only reference to it is on the
stack, not in any container.
To do this, I added a prefix operator, unref, which is an alias of '->-', and
the object varaction routines implement this by leaving the object on TOS and
decrementing the refcount, but not deleting the object if refcount is 0.
I also added unref methods to the containers and container iterators wherever
it made sense to do so.  I also removed or modified methods which would leave
a dangling object reference on the stack in the case where the container was
the only reference to the object (replaced OArray.pop with OArray.popUnref and
changed OList.removeHead and removeTail to not leave any object ref on stack).

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 9 2014

I took a long break from Forth while I played through Morrowind.  When I tried
to use forth to decode some morrowind save files to locate a missing quest
item, I found that a bunch of things were broken, just storing to a local
string caused an abort.  The problem was that the opcode for allocating the
local stack frame was stuffed into the wrong place.  After fixing that, there
is still a problem with strings, the local string init optype is stomping
other locations.  It almost looks like all local variable addresses are defined
to be the memory location just above their actual storage, but if that were
true nothing would have worked, right?  The local stack frame layout is:

RP -> last longword of last defined variable
...
FP-4 -> highest longword 
FP -> oldFP
FP+4 -> oldIP

I guess it could have gotten broken when I added the anonymous functions, since
those did change how the local frame got defined.  Changing the local var
addresses to be correct still didn't fix the test, but the test was crashing
because I had turned on full tracing and the test redirects output to a 512
byte buffer, way more than 512 bytes was generated including trace output,
trashing code just after the buffer.  Turning off tracing made the tests
run successfully.
Moral of the story: always run the tests before a checkin!
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 19 2013

Over the last month I converted the SoftSyn2 music project to use QtCreator.
As one attempt to get this to work, I tried to get Microsoft's console
debugger to work, I never did get it to work, but installing it overwrote
parts of the Windows SDK configuration so that MSDEV was using the version
6.0 includes and library directories, which were not actually installed, instead
of the 6.0A version it was previously using.  This caused all MSDEV builds
to break since it couldn't find the include files it needed in the 6.0
directories.  I tried fixing the registry entries to point back to 6.0A, but
MSDEV kept using the 6.0 versions.  To get things to build I added explicit
6.0A paths to the MSDEV Tools/Options/Projects and Solutions/VC++ Directories
settings above the ones which use the WindowsSdkDir variable.

I added an extension of ForthForgettable which is used to cleanup global
object instances when forgetting.  I started thinking about a general way for
ops to use ForthForgettable, that led me to try to define anonymous functions,
which are sequence of ops which are represented by the address of the op
sequence and have no associated opcode.  This is trivial to implement unless
anonymous functions can have local variables, in which case there needs to
be something like push/pop for local variables.
---
- engine kEngineFlagHasLocalVars flag
- engine mpLocalAllocOp
+ local vocab symbol count (and unwind for pop)
? maybe use shell stack to hold pushed info
  -> func definition could occur inside a control struct, so top of stack
     might not be colon/func tag when a nested func definition is started
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 14 2013

Over the last few weeks I added floating point support to the ARM assembler.
The only thing really left is the fp convert instructions.  I also haven't
done the vector/super scalar instructions, but I'm not even sure the RPI
actually supports these.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 29 2013

Last weekend I got DLLVocabulary support working on ARM.  It is only lightly
tested, I am especially unsure if it works when there are more than 4 arguments
to DLL routines.
I have gotten David Kuhling's MacroForth ARM assembler ported and working,
tested to the point of making a no-op and an add op that work.  One bug at
the end was that 'next,' was compiling a relative branch, not a register
branch, the opcode in David's original code was not even close to the right
value.  I don't know if the 'bx,' opcode will work for more than a simple
register argument, but that is okay for now.
A lingering non-compatability with ANSI-forth was revealed in the assembler
port - it used CREATE...DOES> instead of build...does like my version, I had
problems when I left it as create...does, I think my 'create' just makes a
variable without allocated storage, and 'does' doesn't turn it into a real
user def, it still acts like a variable not an executable user def.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 18 2013

I changed the ARM asm inner interpreter to be compiled by GCC instead of using
AS directly so that I could use the GCC preprocessor to give registers
symbolic names.

I added multi-character literal constants to the outer interpreter syntax.
A single quote delimited string of 4 characters or less is stored in one
stack entry, 5 to 8 characters are stored in two stack entries, with characters
0 to 3 on TOS in the two stack entry case.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 16 2013

The crashes in forth_autoload were in strlen and strcpy, they were because r12
isn't protected in this calling convention.  I now save/restore r12 in all ops
which call clib functions.
The forth_autoload 'ls' op fails redirecting stdout, it is probably a difference
betweens linux and windows _dup.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 15 2013

I finished the rest of the assembly optype action routines except for the combo
types for the ARM.  They are untested of course.

if..else..endif, begin..until and begin..while..repeat all work.

Some operations with local variables still crash, like this:
: boo 5 -> int aa begin aa %d %bl 1 ->- aa aa 0= until ;
This crashes, but if you make aa a global it works.

: boo 5 -> int aa 7 -> aa aa ;			// works
: boo 5 -> int aa 7 -> aa aa %d ;		// crashes
: boo int aa %bl ;						// crashes
: boo int aa 0 , ;						// crashes
-> Having a cCode op in a colon definition with local variables crashes
Doh! When going to a cCode op I wasn't saving FP in pCore shadow, and after
returing from cCode op I was restoring incorrect FP from pCore shadow, which
caused a crash as soon as anything tried to use a local variable or on exit.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 14 2013

Many of the basic operations (dup, over) didn't work because I often used the
ldmdb instead of stmdb to push data.

I noticed that 'allot' still allocates longs, not bytes, I thought I had
changed that, it looks like I changed the scripts to use allot instead of callot,
but I didn't change the actual allot op.  Changing it could break things,
because there could still be things that assume it uses longs, and worse there
could be things that are counting on DP to be longword aligned after an allot.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 13 2013

Over the weekend I have added the multitude of missing ops to the ARM inner
interpreter.  The version I started wasn't really debugged - I think I had
gotten the non-turbo version working and just started getting the assembler
version debugged when I dropped the Nintendo DS version.  Things as basic
as do-loops don't work at all.
There are still a number of optype action routines which are not in assembler.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 10 2013

I decided to get my forth running on the raspberry pi ARM machine.  I already
have an old arm7/arm9 Nintendo DS version with an assembler inner interpreter, but
to get it running initially I decided to use a C-only version, so I am getting
the windows C-only version running.

To turn C-Only mode on, you need to manually:

o remove ASM_INNER_INTERPRETER from ForthLib C++ preprocessor definitions

o remove ASM_INNER_INTERPRETER from the custom build rule for InnerInterp.asm
If ASM_INNER_INTERPRETER is not defined, the only things that are assembled
are CallDLLRoutine to allow DLL ops to work, and NativeAction, which is used 
not part of the build configuration.

Just to keep things interesting, I changed the _ASM_INNER_INTERPRETER define
to be ASM_INNER_INTERPRETER.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 5 2013

There was still a crash in biclasstest, the builtin class definition code
wasn't setting the optype of methods defined in C so they were being executed
as if they were native ops.

It looks like everything might back to where it was before the turbo changes.

I changed turbo mode so that now it is the default, and the prompt for turbo
mode is 'ok>' and non-turbo mode is 'OK>'.  The only difference between turbo
and non-turbo now should be that in non-turbo mode the inner interpreter is
still the C version, so non-native optypes will use the C optype action routines,
and native optypes will be sent to the native interpreter one opcode at a
time.  Should I get rid of the C optype action routines, and have all optypes
except the CCode optypes be sent to the native inner interpreter?
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 4 2013

I changed how turbo mode works pretty significantly:
o optype 0 is used for both builtin asm ops and user asm ops
o builtin ops defined in C are now type kOpCCode
o there are no duplicate op definitions - builtin ops are defined in asm or C, not both
o the opcode definitions in Forth.h like OP_FETCH don't need to be kept in
  sync with the order of op definitions - they are now indices into an array of
  opcodes
forthtest and chess work, there is still a crash in biclasstest.

After getting it working I realized I hadn't saved a version of the executables
from before these changes to compare to, so I backed out my changes, built
release and debug versions and saved them along with a copy of the scripts.
I re-added my changes, and decided to change the executable names from both
debug and release being named ForthMain.exe to being Forth.exe and ForthDebug.exe.
After doing this, Forth.exe crashes on startup.  I tried reverting the name back
to ForthMain.exe, but the crash is still there.  After crawling around in map
files and adding printfs, the crash was because the terminating entry of the
builtin op list had an empty string instead of a null for its name, I don't know
why it didn't crash the first time I built it.  Oh well.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 29 2013

The chess turbo mode crash was caused by rpop accessing the param stack instead
of the return stack.  I never noticed it because I use local variables instead
of pushing/popping the return stack.
I added a crash dump, which shows the stacks, frame pointers and what ops
the IPs on the return stack refer to.
I started adding a debug mode for the assembler inner interpreter, where it
saves IP & SP in the core state after every op execution.  Currently it is
always on, I need to add a way to toggle it.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 25 2013

I added the ?do op, adding this made the kforth chess game work, for the few
moves I tried at least.  The game does still crash in turbo mode.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 23 2013

In a fit of extreme stupidity, I decided to change the names of the 64-bit
stack manipulation words (ddup, ddrop, d!, etc) to be ansi compliant (2dup, 2drop),
along with changing the == and != ops to = and <>.  This required updating
every script file, or close to every.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 20 2013

I started porting the kforth chess player, one thing I noticed is that 'allot'
on standard forth systems takes a byte count, while mine takes a cell count.
Along the way I added the standard forth numeric printing system from gforth.
While doing that I found out that gforth stores 64-bit numbers on the stack
in the opposite order from my forth, which caused a bug in the sign op which
was checking the wrong word for the sign.
After a lot of mucking about, I got chess to run, but it fails shortly
after starting - if you tell it to pick the move, it makes one pawn move and
then announces that you are in check.  If you pick the move, an access violation
occurs.  I don't know if debugging it is worth the effort.
Something I might want to do is change ops like ddup, ddrop and so on to
the more standard 2dup, 2drop and so on.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 15 2013

I think it would be good to get rid of many of the builtinOps, move them to
external assembler ops.  Right now non-builtin assembler ops take an additional
6 instructions of overhead for the userCodeType dispatcher over builtin
assembler ops.  To eliminate this, I could make user assembler ops have optype 0
same as builtin ops.
I think I made user assembler ops a different type from builtin ops because that
way optype 0 in turbo mode always meant builtin assembler ops, and optype 0 in
non-turbo mode always meant builtin C ops.  This change would mean that in
non-turbo mode the C inner interpreter would need to be able to invoke user
defined assembler ops, not just C ops.

o builtin op tables would have to be expanded as user ops were added
o a UserCodeAction entry would need to be added to the C ops table for each
  user assembler op to keep non-turbo mode working
o 'forget' would need to distinguish between builtin ops and user assembler ops
  having the same optype
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 30 2013

Add unimplementedMethod op
Add remove, findNext, clone to OIter and derived classes
Add find, clone, count to OIterable and derived classes
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 26 2013

The builtin class collections operations which remove an object from the
collection and leave it on TOS need to be changed - if you do a OArray.push
of a new object, followed by a OArray.pop, it will leave an object reference
on TOS, but the object will have been deleted.
The problem is that if the collection was the only thing that had a reference
to the object, removing it from the collection will delete the object.
The options:
1) get rid of OArray.pop, OList.removeHead and OList.removeTail, and do the
   equivalent with multiple operations
2) have the 'pop' methods leave an object on TOS which has refCount 0, but has
   not been deleted - just like what happens when an object is created
3) have the 'pop' methods take a reference to the object variable which will
   receive the popped object
4) have the 'pop' methods leave the refCount alone, but add a reference to
   the popped object to the autorelease pool
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 22 2013

It looks like supporting classes that extend structs and classes that aren't
descendants of object is too painful and error prone.
+ only allow classes to extend classes and struct to extend structs
+ change class: to do an implicit 'extends object'

I had to change classtest.txt, since it used classes extending structures,
and when I did I ran into a code generation bug - if you do <CLASS>.MEMBER_INT
the code generated should be 'drop FIELD_INT:OFFSET', the drop isn't being
generated.
-> the <TYPE> code generator was not checking if TYPE was a struct or class, fixed

At the end of the day, both classtest and rctest run with no errors and no leaks.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 21 2013

+ added a OThread class

I added an enum of opcode types in forth_optype.txt, I ran into a problem
because one of the optype names was also the name of an operator with
precedence - initMemberString.  I changed the optype name to memberStringInit.

Look at ForthInner.cpp:MemberStringInitAction and ForthOps.cpp:initMemberStringOp
to verify that they match up.  Also consider changing the allocation of bits,
or at least verifying that everything is expressed in terms of longs.
-> they did match up, member offset is longs, max string len is bytes

There are memory leaks from classtest.txt, there were several global objects
that weren't being released, when I tried to fix that I couldn't because one
of the classes extends a struct, not an object.  Things that extend a struct
don't inherit objects delete method.  I guess they could define their 
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 15 2013

I did a log file scanner for work to process 600+ MB stderr files to get the
unique exceptions using the builtin classes and the file class.  I found a
few bugs, the biggest being that I forgot that delete doesn't automatically
propagate - to support this, I had a way to do 'super.delete'.  I added a
super opcode and added support for it as the first symbol to the struct code
generator.  Adding that made the number of unfreed object on exit become 0.
I added a built in hashing function to OString, the hash is generated the
first time you request it with OString.hash, and is only regenerated if it
has been invalidated by a set or append operation.
I added 'ofif', a case op which is like 'of' except it is preceeded by an
arbitrary boolean expression, not a constant.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 8 2013

I split out the struct/class code generation from ForthStructs into ForthStructCodeGenerator,
it works well enough for classtest.txt to run without crashing.
I also reintroduced the debug and trace user definitions.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 30 2013

I'm debugging some code generation bugs I found when trying to add a file class.
The current ForthTypesManager::ProcessSymbol code generation does not work if
the first token is a member object, I don't think it will work if the first
symbol is a local object or struct either.
There is already a somewhat old description of code generation in ForthStructs.txt,
but here is another take on what ProcessSymbol should do:

First symbol cases

1) name of a class or structure type in angle brackets
  a) object on TOS
  b) ptrTo structure on TOS
2) global
  a) global object
  b) global ptrTo object
  c) global structure
  d) global ptrTo structure
3) local 
  a) local object
  b) local ptrTo object
  c) local structure
  d) local ptrTo structure
4) member
  a) member object
  b) member ptrTo object
  c) member structure
  d) member ptrTo structure
5) op which returns a reference (not implemented)
  a) op returns object
  b) op returns ptrTo object
  c) op returns ptrTo structure

After first symbol is processed, TOS is one of:
  a) object
  b) ptrTo structure
? is this true - could it be ptrTo object or op?


Middle symbol cases
  1) field
  2) method which returns a reference
  3) op which returns a reference (not implemented)

  
Final symbol cases
  1) native
  2) ptrTo anything
  3) method
  4) op
  5) struct
  
To be continued...
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 29 2013

+ added 'verbose' prefix op for vlist and describe, eliminated vlistq
+ added the ability to disassemble method ops with describe CLASS.METHOD
- in file.getLine the OByteArray.resize method is getting compiled wrong, the
  opcode used to prefix global byte variables is being compiled where it should
  be putting something to fetch the OByteArray member variable
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 28 2013

I started implementing a 'file' class and ran into a few problems

+ the file class has an OByteArray member - 4 bytes were allocated for this
  member, all object references need 8 - fixed
- the getLine method includes 'new OByteArray' - forth:new isn't executed,
  instead object:new is compiled as 0x520001ef - 1ef is object:new, but the
  0x52 opType is MemberByte which makes no sense, the opType should be
  0x6C opType MethodWithThis.
  -> the object.new vocab entry type field is 0, it should at least have the
     method flag (0x40) set, so it is being compiled as a member byte access
? how to deal with object.new and forth.new confusion
-> I changed object.new to object.%_new_%
- there is no way to add non-method ops to class vocabularies - because of
  how the first entry is defined, they are treated as member variables
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 11 2013

Added 16-bit register definitions to asm_pentium and fixed defs like [edi]
which were actually using 16-bit addresses to use 32-bit addresses.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 3 2013

I tried to make a DLL vocabulary for libmysql.dll, but when I ran any DLL ops
I got a low level error with a warning about using inconsistent calling
conventions.  libmysql uses stdcall, all my previous dll vocabs used cdecl.
Also, some of the libmysql calls return a 64-bit result, the current dll optype
always returns a 32 result.
I added DLLStdCall which sets the current definition dll vocabulary to use
the stdcall calling convention.
I added DllVoid which makes the next dll op definition return nothing.
I added DllLong which makes the next dll op definition return 64-bits - this isn't
fully tested, mysql_num_rows returns a 64-bit result that looks ok, but it could
just be that it is accidentally returning 0 for the high part.
I updated the sdl and sprig libraries to use DLLVoid and tested sdltest and sprigtest.

I got ttf_test.txt working.  When I started, the sdl_ttf dllvocab definition
kept failing, saying the entry points I was requesting were undefined, this
stopped happening when I added the libfreetype and zlib dlls.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17 2013

Resurrected ForthGUI - it had a bug where any error would cause all user
definitions to be forgotten - this was because it uses ForthBufferInputStream
which was defined as 'non-interactive' and when errors occur if the main
input stream is non-interactive, they are promoted to fatal errors which was
causing the existing forth environment to be destroyed and recreated.

- the output redirection system should be replaced with something object based
- ForthGUI should display turbo status
- ForthGUI should load forth_autoload.txt
- bring Windows/CVS version in sync with Linux version and migrate to Git

Changed forthtest.txt to just print errors.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Octomber - December 2012

Worked on Linux version of Forth
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 28 2012

The client/server version was failing in forthtest.txt in the first 't[' test,
it was a weird bug whose final cause was that the server shell was written
before I added ifdef handling to the base shell, so it wasn't calling ProcessLine,
so lines weren't getting skipped when they should, and some lines like the test
string submitted by 't['were being completely ignored.

The 'dir' crash was because it was redirecting stdout and stderr, and those ops
were not going through the shell filefuncs, so file handles from the server
process were being processed by the client process, leading to too much fun.

I added more file operations - rename, mkdir, rmdir.
The mkdir op takes an access mode param which is ignored under Windows.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 25 2012

I updated the windows client and server to have the new file operations (remove,
dup, dup2, fflush etc.).  It fails when I try to do the high level version of
'system', which uses most of the new file ops.  For some reason on the server
the debugger callstack and source don't line up, even after a full rebuild.
MSDEV does warn that the source doesn't match up with the executable.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 24 2012

I replaced all occurences of _WINDOWS to WIN32, the standard windows define.
I got the client-server windows version to work, I had to specify the actual
machine IP address, localhost (127.0.0.1) wouldn't work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 20 2012

Added multiple script panes and window resizing to ForthGui.
Changed trace output to go through a settable traceOutRoutine to allow trace
output to be sent to a ForthGui pane.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 18 2012

Updated classtest.txt to do some testing of OArray, OList and OMap.
Completed changes to have refCounts be 0 at creation time and have object
variable assignment affect refCounts.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 16 2012

Fix bugs in interpret and u* .
Fix bug with handling of things like obj.method( blah )  or   vocab:op( blah ).
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 13 2012

Added a bunch of tests to forthtest.txt.  In doing so I found thatt'interpret'
was broken - it didn't invoke the outer interpreter directly, it just stuck
stuff on the input stack and so the target string wasn't interpreted until
well after exiting 'interpret'.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 29 2012

I just realized that if a class extends a struct, it can't extend object and
be refcounted.

I had been thinking about defining okeep, orelease and odrop ops.  odrop would
be used after you executed a container method that removed an object from a
container and left it on TOS.  odrop would check the refcount and delete the
object if 0, otherwise it would just decrement the refcount and remove the
object from TOS.  This wouldn't work if two containers referred to the same
object and you popped the object from one container then did an odrop - the
odrop would leave the object refcount 0 and delete it, but the second container
would still have a reference to it.
-> odrop should not affect the refcount, it should just delete the object if
   its refcount is already 0
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 28 2012

While debugging the object system changes I ran into a painful bug, that was
caused by another thing I forgot to fix:  if all objects are refcounted, then
all local object variables must be initialized to NULL, otherwise the first
time you assign to a local object variable, it will try decrementing the
refcount of whatever bogus address the local object was pointing to.
-> zero out ALL local variables when allocating a stack frame - and the same
   should be done for global variables and member variables
+ AllocLocalsAction
+ allocObjectsOp
+ global vars & arrays - ForthClassVocabulary::DefineInstance already does this
+ global structs & struct arrays - ForthStructVocabulary::DefineInstance already does this
+ assembler versions where they exist (just allocLocalsType)
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 24 2012

I'm having doubts about the new object changes - maybe they are just doubts
about how to name things.  Specifically, should the root class be called 'object'
or 'ovar' - the other containers are themselves objects, but an ovar is not an
object that contains a single object.

When I was looking through the existing container code, I kept seeing cases
where assigning an object to a container didn't do a keep on the object.

Another odd thing is OListRemoveHead and OListRemoveTail - if I make them
do a release on the removed object, it will often be destroyed, but leave a
dangling object reference on TOS - I guess the rule will be that the user
has to remember to do a release
? or should the refcount be decremented, but no delete done if it is 0 - this
  would fit conceptually with having new objects on TOS have refcount 0.
  -> but if the user wanted to just discard the object, they would first
     have to assign it to a variable and then release it, doing a release
     on TOS would fail because the refcount is already 0.
     
+ I reworked the varop handling routines for all the predefined types to use
  a common inline function rather than explicitly duplicating the code for
  each usage scenario of each type
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 30 2012

I think the next steps for object support are:

o make all objects be refcounted
o change object new to create it on TOS with a refcount of 0
o change object varop assign to do refcounting

The key idea is that all refcounting is done in terms of containers, and an
object variable must be treated as the simplest container.

I think I will make this non-backwards compatible and change names to reflect
this.

o object will become ovar
o rcXXX will become oXXX

? how should varops interact with containers
src -> dst
  increases the refcount of the src object, decreases the refcount of the
  object dst previously referred to.
src ->+ dst
  if dst is an oVar, this is either an exception, or the same as '->'
  if dst is not an oVar, add src to the container, which increases the
  refcount of src
src ->- dst
  this should probably just be an exception, since doing a remove operation
  can cause a costly linear search, and should be forced to be explicit
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 27 2012

I was working on sdl_audio, it needs an audio feed callback, I coded it in
assembler.  I tried gforth assembler (asm_pentium), but it has a bug with
instructions which load an immediate value into a register - it always
uses 2 operands on TOS, and in this case there is only one operand - the
register code.
I switched over to the kforth assembler (asm_kforth), but it has a different bug,
this one happens when you use indexed addressing with ESP, in this case it
generates incorrect opcodes.  There is a note about it not working and it
looks like it implements a workaroudnd, but the generated code is wrong.
I looked at the bigForth assembler - it is an older version of the gforth
one, it doesn't have the change which makes it access undefined data, but that
change must have been made to fix something.
I looked at the bigforth assembler, which was done by the same guy as the
gforth assembler, its mov code has a later date, and it doesn't include the
ops which access below TOS.  I applied that change and it seems to work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 24 2012

I'm planning on implementing a set of 'combo' optypes which will do 2 or 3
common operations in a single forthop.  The planned combos:
  NUM VAROP OP		4 ->+ foo
  NUM VAROP			22000 ->
  NUM OP			6134 *
  VAROP OP			->- woof
---
NUM VAROP OP
  VAROP would need 2 bits (support only ref/->/->+/->-)
  NUM would have 11 bits
  OP would have 11 bits
This would be compiled when compiling an opcode, if the previous two ops
were an int constant in the suitable range and a varop.
---
NUM VAROP
  VAROP would need 2 bits
  NUM would have 22 bits
This would be compiled when compiling an opcode, if the previous two ops
were an int constant NOT in the suitable range and a varop.
---
NUM OP  
  NUM would have 13 bits
  OP would have 11 bits
This would be compiled when compiling an opcode, if the previous op
was an int constant in the suitable range.
---
VAROP OP  
  VAROP would need 2 bits
  OP would have 22 bits
This would be compiled when compiling an opcode, if the previous op
was a varop, but the op before that wasn't a constant.
---
+ make the c++ version of the combo optypes code
+ make the assembler version of the combo optypes code
- test by making some opcodes manually and executing
- add a peephole optimizer to the engine that compiles the opcodes
- add combo support to TraceOp/DescribeOp
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 22 2012

I took the existing implementation of 'system' which did a lot of extra stuff
like redirecting stdout and stderr to files and then spewing them back through
the forth output stream, and made it do just the call to system, and I made
forthops for the other system calls which it had been using, and finally I
implemented system$ in the autoload which did all the redirection stuff.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 19 2012

I'm waffling again about rcobject refcounts.  My current wafflation is that
all object reference counts on TOS shouldn't be refcounted
  ? then how does object creation work - putting a new object ref on TOS and
    giving the object a refcount of 1 is problematic
    o we could make the convention that all objects are created with refcount 0
      and must be immediately assigned to a variable to avoid memory leaks
    o we could also require that you could only create an object into a container,
      with rcObject being the simplest container
    o or ALL object creations add an entry to the autorelease pool
      o maybe there should be a rcObject.create object that takes a ptr on TOS
-> I think the best approach might be:
  1) explicit object creation leaves object with refcount 0 on TOS
  2) temporary object creation leaves object with refcount 1 on TOS, and adds
     an entry to the autorelease pool
I think there is still some confusion between a reference counted object and
the variable that references it in my mind.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 18 2012

I noticed that access violations were crashing forth - to fix it I
changed the ForthLib project C++ code generation exceptions settings from
"Yes" to "Yes with SEH Exceptions", otherwise it can only handle C++ generated
exceptions, not processor exceptions like divide-by-0 or access violations.
Why did this work before?  Maybe I turned it off after it worked, otherwise
the debugger doesn't break on exceptions, and when I turned it back on I didn't
choose SEH exceptions.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2012

I changed how refcounted containers worked - previously whenever an object was
added to a container its refcount was incremented, and whenever an object was
removed from a container its refcount was decremented, that was broken because
it was never treating an object reference on TOS as being counted.  Consider
this scenario:
o create an rcObject -> object reference is on TOS, obj.rc is 1
o add obj to rcArray woof -> obj.rc is 2
o delete woof -> obj.rc is 1
The end result is that the object is left dangling.
Now adding an object to an array doesn't increment its refcount.
Assigning an object to an element which already contains an object reference
does decrement the refcount of the old object reference.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 10 2012

I tried to eliminate as many of the new 'unsafe' warnings as I could.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 19 2012

I added the ability for colon-defined ops inside class definitions to access
class member variables and methods, before only methods could do so.  Colon
ops don't push/pop the this pointer, they use whatever this ptr is already
set.  I should make sure that you can't access these colon-ops from outside
of their own class (and derived) methods.

ForthTypesManager::ProcessMemberSymbol
  called whenever you are in a class definition to process class member symbols
  -> ProcessMemberSymbol does iterate down the derivation chain, which is good if
     we want derived classes to be able to access ancestors colonOps
ForthTypesManager::ProcessSymbol
  called when symbol includes a period, symbol first part is used to determine
  the class
  -> ProcessSymbol incorrectly generates an offset instruction when it is
     given "objectInstance.colonOp" .
     
If colonOps are only to affect the object already referenced by the this ptr,
then I don't think "objectInstance.colonOp" ever makes sense, so we can just
disallow that - only colonOps which have no object instance selector and are
inside a class definition should be supported.
-> it would be nice if colonOp names just weren't recognized in these cases,
   so a colonOp name wouldn't obscure a same-named member in an ancestor class
-> this would be hard to implement, since FindSymbol always just returns the
   first symbol found, there is no direct way to have it continue the search
   after it finds a symbol that the caller rejects.
   
It would be useful to have a way to continue a search after finding a match
that is reject for some reason.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 26 2011

The midi support allows you to define midi in and out callbacks which are done
as user-defined forthops.  I kept seeing that the top level op of the midi in
callback would be executed in the inner interpreter, but none of the ops in the
callback were executed - the problem is because of how threads are created.
Threads contain a ForthCoreState struct, which includes the opcode dispatch
tables and table sizes.  When the midiInCallback opcode is executed, it gets
to the kOpUserDef optype action routine, which first checks that the opcode
low 24 bits is less than or equal to the maximum defined user opcode, but in
this case it isn't, because the midi in callback runs in the midi extension
thread which was created at startup, before any user definitions were loaded.


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 25 2011

After eons of neglect, I decided to try to get ForthMidi working again.  It
turns out the reason I was getting all those strange crashes in the midi input
callback was because I didn't have the 'CALLBACK' keyword in the callback
signature.  DOH!
I also in a fit of stupidity decided to 'clean up' the msdev project/configurations,
forgetting that there is no good way to do things the way I want in msdev.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 8 2011

I renamed the class ForthBaseType to ForthNativeType because there was also
an enumerated type forthBaseType.

I added array indexing to the syntax recognized by the outer interpreter.
The syntax is SYMBOL[] where SYMBOL is one of:
  a) a literal integer
  b) a struct/class typename
  c) a native type name (excluding string)
The symantics are defined by the existing kArrayOffset opcode, which is:
INDEX ARRAY_BASE_ADDRESS TYPE[] ... ARRAY_BASE_ADDRESS+(INDEX * sizeof(TYPE))
Currently, if SYMBOL is a class name, the size is the storage size, not the
size of the object reference on stack (always 8 bytes).

Forth crashes when you create an object instance of a class which has no
methods.  AllocObjectOp gets the primary interface pointer, which exists, but
it pushes the methods pointer, which is the address of mMethods[1], and the
std::vector code in debug does bounds checking, and if there are no methods
then mMethods[1] is out of bounds.
-> fixed
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 22 2011

I started trying to create a directory iterator class and found a big bug in
class support.  Inside a method definition compound symbols like MEMBERVAR.METHOD
don't work at all.
-> I now push the new class on the vocab stack during class definition

Another problem: the chdir command leaves _system_stdout.txt & _stderr files
behind it every time and everywhere it is run.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 17 2011

There were more problems with method definition, derived classes weren't
really working before.  I think they are mostly fixed now.
I fixed the method definition problem where a non-method whose name matches
will terminate the search, potentially causing the method to be assigned a
new method index instead of the index of the method it is intended to
override, but it is untested.  As part of the fix I added the ability to
continue searching vocabularies in general.  While adding this I had to
change how the search iteration was done so that instead of ending the
iteration based on the symbol count, now it ends the iteration when the
entry pointer goes beyond the top of the vobab storage.  There was already
a mpStorageTop pointer, but nothing was initializing or using it.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 16 2011

rcMap.headIter was always crashing when it tried to assign the map.begin() to
the c++ iterator in the rcMapIterStruct.  To fix it I had to change the allocation
of the rcMapIterStruct from malloc to new, because the c++ iterator assignment
doesn't just copy data, it needs the iterator to be initialized.

rctest.txt tests the containers and their iterators for empty, one element
and multiple element cases.  If the cleanup op is run, on exiting forth in
the debugger the object dump is empty.

I made an abstract base class rcIter so that you could define ops that would
take an iterator object that would work for all three container types.  This
broke things because as part of this, I had AddBuiltinClass check for the
methodOp routine being NULL and use badOp as the opcode, which uncovered two
bugs:
1) when a class extends another class, its primary inteface is overwritten
   with the primary interface of the parent class, including the interfaces
   defining vocabulary - this led to all interfaces of derived classes having
   their defining vocab be the base 'object' vocabulary
2) ForthInterface::GetMethodIndex should go through the chain of defining
   vocabularies and find the first matching symbol which has type method,
   instead it finds the first matching symbol, and if that is not a method,
   it returns NULL
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 15 2011

I finished adding refcounted containers (array, list, map) with iterators.
Map iterators are completely untested.
I had to add global variables to allow the container classes to create their
associated iterator classes.
I put in rudimentary tracking of new/delete/keep/release in global variables.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 7 2011

The main hard drive on my old work machine failed on August 19.  It took me
several days to get things transferred to my new machine.  After getting
things working.  It looked like the Forth and Music directories were okay,
except the CVS file for sdl.txt was lost.
I just noticed that somehow the change of 'addressOf' to 'ref' in forthops.cpp
got lost somehow, but the changes in the sandbox scripts are all still there.
Over the last week or so I added some refcounted containers - rcArray, rcMap,
rcList and refCounted strings.  They all need testing.

UGH! if you remove an element from an rcList its refcount is decremented, so
if the list was the only thing that referenced that object it will be deleted,
but a non-null reference to the object is left on the stack.  We can't just
look at the refcount before pushing the object, unless we are requiring that
all rcObjects have a standard way of accessing the refcount...

I started to change rcList to not expose its link elements as structs and
instead have an iterator object, but it will take some thought
? when iteration hits end of list should the user be able to reverse
  directions and iterate back
? what should be returned each iteration - just the object, or the object
  and some end-of-list indicator

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 15 2011

rcArray methods:
o delete
  for each element
    if element.methods is nonzero
      element.release
  delete rcArray
  delete rcArrayStruct

o count
  return number of elements
  
o get( index ) ... object
  if ( index < elements.size )
    return element[index]
  else
    error( invalid parameter )

o set( object index )
  if ( index < elements.size )
    oldObject = element[index]
    if object is not null
      object.keep
    if oldObject is not null
      oldObject.release
  else
    error( invalid parameter )

o findIndex( object ) ... index (-1 if not found)
  scan array for first occurence of object, return index if found else -1
  
o remove( index num )
  if ( index+num < elements.size )
    for each element to be removed
      if element.methods is nonzero
        element.release
  else
    error( invalid parameter )
    
o append( object )
o resize( size )

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 7 2011

Changed 'addressOf' to 'ref'.  Updated all scripts.
Also changed addref to keep.
Started to define rcArrary, decided I needed to think it through.  The current
object bodies are just malloced, if i am going to use stl templates to implement
this and other reference-counted containers I will be using 'new'.  My current
thinking is that the object body for a rcArray will be just the refCount and
a pointer to the std::vector object.

- add autorelease to rcObject
-> requires the definition of autorelease pool
? whan do you explicitly autorelease
  -> when you return a newly generated temporary object

rcArray methods:

INDEX OBJECT set
INDEX get ... OBJECT
INDEX ref ... PTR_TO_OBJECT
count ... NUM_ELEMENTS
N resize
OBJECT append
OBJECT find ... INDEX (-1 if not found)


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 30, 2011

Reverted ForthInner.cpp and ForthStructs.cpp array changes, had to add in
array support for unsigned byte and short also.
Added _doUByteArray and _doUShortArray ops, I added the table changes to
the assembler version, but in the assembler they are just copies of the
signed version.

I rearranged the ops which have specified positions so that the ops for global
variables and arrays have the same ordering as the corresponding optypes.
Before the unsigned byte & short global ops were not with the other ops, which
made code generation for variable and fields clunky.  To avoid reordering all
the defines I moved the varop setting ops to the end of the table.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 29, 2011

I started putting back the array opcodes, first I made a backup zip file.
I got through Forth.h and ForthEngine.cpp.

Also, the new opcodes for 64-bit integer are mixed in with the other changes
and were never checked in.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 19, 2011

The crash in classtest.txt was because the tests array operations needed to
be updated to match the change in how arrays work.
While debugging the changes to array handling, I ran into a few things that
are making me rethink the whole idea.  For one thing, things involving arrays
are a good bit clunkier since there can be no field accessors after an array
access - I didn't think about how painful this would be.
For example, this
	2 arrayOf ptrTo rgba gapo
	1 gapo.g					-> 0 gapo.r
becomes
	2 arrayOf ptrTo rgba gapo
	1 gapo @ d@ <rgba>.g		0 gapo @ d@ -> <rgba>.r
There really aren't that many extra operations being performed, it is just the
amount of typing needed that is annoying, plus the loss of clarity.

The reasons for changing arrays was:
1) it was too easy to mistakenly place a varop so that it was applied to the
   array index instead of the array element
2) getting a pointer to array elements with addressOf is a mess
? maybe just change it from 'addressOf' to 'ref'?

If I keep things the way they are, most likely when array elements are being
manipulated the element address will be gotten and then immediately assigned
to a local var whose type is a ptr to the element type.

Removing the array changes and keeping the signed/unsigned changes wouldn't
be that hard, the worst part would be rearranging the opcodes, since the
number of optypes is now 11, the tables wouldn't be arranged in neat groups
of 10 anymore.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 18, 2011

I renamed ellipse.txt to graf2d.txt since it has lines, rectangles and circles.
+ vlistq is broken, it quits well before it has listed all ops

I am going to do 2 related somewhat major changes:
o support signed and unsigned integer types
o simplify array support
---
The signed/unsigned support mainly means adding unsigned versions of the byte
and short types which will do sign extension on fetch.  There is also a isUnsigned
flag in the datatype descriptor.  This will be useful for qsort & bsearch.

One thing that might be painful is that now the mapping from native type to
optype might be more complicated, unless I define new native types for the
4 unsigned integer types.

Another gotcha is that previously I defined int and short as signed but byte
was unsigned, I did this because otherwise I ran into problems when displaying
characters when sign extension got in the way.  Now by default bytes will be
signed, so things will have to be declared ubyte to fix it.

- classtest.txt crashes
---
The array support change is that array variables/field ops will just produce
an element address, they won't pay attention to the varmode:

  5 -> 7 arrayOfBytes
    will become
  5 7 arrayOfBytes c!
  
The interaction between varmode and variables used as array indices was just
too screwed up.

The kOpLocalXXXArray/kOpFieldXXXArray/kOpMemberXXXArray optypes could all be
replaced by kOpZZZStructArray, there might be a small performance penalty.
since now there would be a multiply for any array access.  Alternatively I
could have 4 special localArray optypes that would support 1, 2, 4 or 8
bytes per element.

+ changed ForthEngine::AddLocalArray to use kOpLocalStructArray
+ changed ForthTypesManager::ProcessSymbol
  + to not allow non-final tokens to be arrays
+ ForthTypesManager::ProcessMemberSymbol
- It looks like ForthTypesManager::ProcessMemberSymbol doesn't allow you to
  access the fields of member structs, only member native types inside method
  definitions - ProcessSymbol and ProcessMemberSymbol need to be refactored
+ changed ForthNativeType::DefineInstance
  + to compile different opcodes for unsigned byte & short global vars
+ change byte & short fetches to be signed by default
+ change global array ops to ignore varops
+ remove array action optypes
+ added unsigned byte & short global var opcodes
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 15, 2011

I added generic quicksort and binary search ops.

qsort( ARRAY_ADDR NUM_ELEMENTS ELEMENT_SIZE COMPARE_TYPE SIGNED_FLAG COMPARE_OFFSET )
o COMPARE_TYPE is forth native base type
o COMPARE_OFFSET is offset into record of field to compare
o SIGNED_FLAG is 0 for unsigned, not 0 for signed for integer types
o SIGNED_FLAG is string size for string comparisons
Some sample output for signed & unsigned bytes:

ok> variable aa
ok> 0x17330483 aa ! aa 4 1 0 0 0 qsort aa @ %x
83331704
ok> 0x17330483 aa ! aa 4 1 0 1 0 qsort aa @ %x
33170483
ok> 0x17333317 aa ! aa 4 1 0 1 0 qsort aa @ %x
33331717
ok> 0x87333387 aa ! aa 4 1 0 1 0 qsort aa @ %x
33338787
ok> 0x87333387 aa ! aa 4 1 0 0 0 qsort aa @ %x
87873333

bsearch( ARRAY_ADDR NUM_ELEMENTS ELEMENT_SIZE COMPARE_TYPE SIGNED_FLAG COMPARE_OFFSET KEY_ADDR )

bsearch is a little screwy - when it doesn't find a key it pushes the negative
of the nearest index+1, which is a little confusing, but I needed some way to
indicate when something wasn't found and was less than the lowest value in
the array.  If the return value is negative, you need to insert at -(val-1).

Maybe I should change it so it always returns the insertion index, and the
caller is responisble for checking for an exact match?

The next thing this suggests is adding a way of making datatypes user visible,
so that the user can easily specify:
o type of array elements
o type of comparison fields
o offset of comparison field

Something like STRUCT_TYPE:FIELD_NAME would be nice.
This would still leave the signed/unsigned issue to be dealt with.
Bit 7 is unused in the data storage descriptor word, could be used for sign.

A way of entering literal data for records would also be handy,
maybe something like: data NAME STRUCT_TYPE ... enddata

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 10, 2011

There was a crash in sdl testEvents, it was caused by return stack corruption,
it had a SDL_Event local variable and only 8 bytes was allocated for it, it is
a union type, and some of its subtypes have more than 8 bytes (SDL_KeyEvent is
10 for example).  I'm guessing that the size of a union type isn't the size of
its largest member, it is the size of the last member added to the union.
-> yup, fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 9, 2011

I tried a test of sdl keyboard events, the key value didn't appear anywhere,
it looks like there is a mismatch of how the c++ compiler aligns structure
fields and how forth does.

typedef struct SDL_KeyboardEvent {
	Uint8 type;	/* SDL_KEYDOWN or SDL_KEYUP */
	Uint8 which;	/* The keyboard device index */
	Uint8 state;	/* SDL_PRESSED or SDL_RELEASED */
	SDL_keysym keysym;
} SDL_KeyboardEvent;

typedef struct SDL_keysym {
	Uint8 scancode;			/* hardware specific scancode */
	SDLKey sym;			/* SDL virtual keysym */
	SDLMod mod;			/* current key modifiers */
	Uint16 unicode;			/* translated character */
} SDL_keysym;
SDLKey & SDLMod are both enums, both require 16 bits to represent

0	Uint8 type;	/* SDL_KEYDOWN or SDL_KEYUP */
	Uint8 which;	/* The keyboard device index */
	Uint8 state;	/* SDL_PRESSED or SDL_RELEASED */
3	SDL_keysym keysym;
3		Uint8 scancode;			/* hardware specific scancode */
5		SDLKey sym;			/* SDL virtual keysym */
7		SDLMod mod;			/* current key modifiers */
9		Uint16 unicode;			/* translated character */

The forth declarations are:
struct: SDL_keysym
	byte scancode			// hardware specific scancode
	short sym				// SDL virtual keysym 
	short mod				// current key modifiers
	short unicode			// translated character
;struct
// I'm not sure about sym and mod size, they are enums

struct: SDL_KeyboardEvent
	byte type	// SDL_KEYDOWN or SDL_KEYUP
	byte which	// The keyboard device index
	byte state	// SDL_PRESSED or SDL_RELEASED
	SDL_keysym keysym
;struct

-> when SDL_keysym is defined, the struct code recognizes that the short sym
   field would be misaligned, so it adds a pad byte after scancode
   
key down   type=0x2  which=0x0  state=0x1  scancode=0x0  sym=0x12fc  mod=0x0  unicode=0x0
 02   00   01         00    1e  fc 12  00 61 00 00 00 00 00 00 00        ........a.......
type which state   scancode ??   sym
key down   type=0x2  which=0x0  state=0x1  scancode=0x0  sym=0x12fc  mod=0x0  unicode=0x0
00950098   02 00 01 00 1e fc 12 00 61 00 00 00 00 00 00 00        ........a.......
key up   type=0x3  which=0x0  state=0x0  scancode=0x0  sym=0x12fc  mod=0x0  unicode=0x0
00950098   03 00 00 00 1e fc 12 00 61 00 00 00 00 00 00 00        ........a.......

key down   type=0x2  which=0x0  state=0x1  scancode=0x0  sym=0x12fc  mod=0x0  unicode=0x0
00950098   02 00 01 00 30 fc 12 00 62 00 00 00 00 00 00 00        ....0...b.......
key up   type=0x3  which=0x0  state=0x0  scancode=0x0  sym=0x12fc  mod=0x0  unicode=0x0
00950098   03 00 00 00 30 fc 12 00 62 00 00 00 00 00 00 00        ....0...b.......
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 8, 2011

I put in a new optype "internalMethod" which was like "methodWithThis" except
that it didn't push TPM/TPD and on exit wouldn't pop them, then I realized
that this could be done with regular forth ops, there just has to be a
syntax that allows forth ops which are defined within a class to access the
member variables of the current 'this' object.  Maybe within an forthop
definition which is inside a class definition a leading period will cause
the following symbol to be treated as a member variable of this class.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 4, 2011

I added the ability to append forth text files to the forth executable, so
that you can create forth applications that don't need external files.

o at startup, the executable file is scanned starting at the end for markers
  that show that there are appended files and their names, the shell records
  these names and their positions in the executable file
o ForthShell::PushInputFile checks its filename parameter against the list
  of appended files and will use the appended file if it finds it instead of
  opening an external file
  * there is a potential gotcha here - ForthInputFile will read to the end of
    the file if it doesn't hit a 'loaddone', so if you append a file which
    doesn't have a loaddone it could keep reading past the end of the appended
    file and read garbage
o forth will now load app_autoload.txt if it exists instead of forth_autoload.txt.

There is a utility forth script make_archive.txt which can append files to the
forth executable in the proper format.

While debugging make_archive.txt, I kept getting a crash on 'bye' due to
heap corruption.  It was because when I made some thread support changes a
while back, I wasn't specifying the main threads param and return stack sizes
explicitly, so it was getting the defaults, which is 128 longwords for each.
This is normally enough, but the make_archive code had several long local
buffers eating up rstack space, so the return stack was overflowing and
corrupting stuff beyond it.  The outer interpreter only checks under/overflow
between top level ops, so the overflow was never caught.

I also found that files that are loaded are kept locked until forth exits, I
know that this wasn't the case until recently, because when creating scripts I
usually just keep switching between forth and the editor without exiting forth.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 2, 2011

I added the ability to append a set of files to the forth.exe image,
I changed ForthShell::SetCommandLine to gather the list of files.  I made a
test file named spud.exe in the sandbox which has forth_autoload.txt and
asm_pentium.txt appended to it, it gathered the file list successfully.

Remaining to be done:
- create a utility for appending files to the forth image
- change ForthShell::PushInputFile to check the input filename against its
  list of internal files and open an internal file if one exists with the
  same name

0x00000  forth.exe (length=0x59000)

0x59000  data from forth_autoload.txt (length=0x1332)
0x5a332  0x00001332
0x5a336  0xDEADBEEF
0x5a33a  "forth_autoload.txt" (length=0x12)
0x5a34c  0x00000012

0x5a350  data from asm_pentium.txt (length=0x6cf2)
0x61042  0x00006cf2
0x61046  0xDEADBEEF
0x6104a  "asm_pentium.txt" (length=0xf)
0x61059  0x0000000f

0x6105d  0x00000002
0x61061  0x34323137
0x61065

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 29, 2011

I got the SDL audio callback coded in forth assembler working, just producing
a tone computed by incrementing an 8 bit sample by 1 every sample time.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 28, 2011

I added the fast hash function and unsigned multiply (32*32 -> 64) ops.

While looking at the assembler version I noticed that it has implementations
for most of the file ops, but when I looked at them I realized that unlike
the C versions, they call the clib functions directly, while the C++ version
goes through the shell wrapper calls which supports client/server operation.

A bigger problem is that the C++ version ops use the GET_ENGINE, which at
some point I changed from being pCore->pEngine to ForthEngine::GetInstance(),
I don't remember why I did that.

cvs diff -r 1.3 -r 1.4 ForthInner.h
The 1.4 log message is 'More struct work' and is from 4/15/2007
The 1.3 log message is 'Start adding user-defined structure support.' from 4/7/2007

I can think of 2 probable reasons:
1) I was on a 'must use singleton pattern' kick
2) In the same change I had also changed the definition of pEngine from ForthEngine* to void*,
   maybe the change had something to do with whatever that was about
   
To fix the file op problems, I'm going to try to stick a table of file operations
in the shell, and put a pointer to them in the core state, the forth fileops
will all dispatch through the table.
The client/server version of the shell will replace that table with remote
file access functions.
After a little debugging, it works fine in regular and turbo mode.

I made the same change on the client/server version, it works fine.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 25, 2011

I was thinking of changing vocabularies to be special objects, something
like class objects.

The overall idea was:
o eliminate the vocabulary specific varops: removeEntry, entryLength, numEntries,
  and getClass, replace them with methods on the vocabulary class
o have each class object have an op that handles when the object symbol
  appears by itself (IE 'forth' or 'assembler') - most classes would use the
  standard op, which would implement just default, fetch, store and ref.
  The one for vocabularies would have its default action be setting the
  top element of the search stack to this vocabulary.  This op is what would
  be compiled as the first and only op for global instances of this class.
  ? what about local instances
  This might not be such a great idea, and the only thing it buys us is being
  able to keep support traditional forth search order ops like also/only/definitions
  
There is a similar problem here between vocabulary objects and class object -
the instances of these objects are globals, and their symbols have special
meanings - 'object' by itself defines an instance of an object reference, it
doesn't leave the 'object' class object instance on TOS.

Also, how do you declare a reference object for special classes like vocabulary?
If you use the 'vocabulary' keyword, it creates a new global vocabulary, not
an empty object reference variable like other standard class name symbols.

This requires more thought.  Maybe vocabularies are fine as is.  The way
that vocab operations are done using varops does seem like a kludge though.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 22, 2011

+ fixed the bug where global object arrays had a redundant element size field,
  it was a cut-and-paste error, ForthClassVocabulary::DefineInstance was cloned
  from ForthStructVocabulary::DefineInstance, and doStructArray DOES have an
  element byte field.
+ fixed the bug where initMemberString in turbo mode inited the string to
  contain one garbage character
  
It seems that many, if not all exceptions are causing Forth to exit.
-> the main loop was not handling the result case for kResultException, fixed.
   I'm guessing that previously an exception set the result to kResultError.
   
There is a crash in turbo mode if you do CLASSNAME.new, it doesn't happen in
non-turbo mode, and 'new CLASSNAME' works in turbo mode.

: zoo object.new ;
turbo> describe zoo
zoo: type UserDefined:4f value 0x200004f 0xa (user defined forthop)
  00d51520  00:000036    vocabToClass
  00d51524  03:000000    object
  00d51528  5b:000004    MethodWithTOS    4
  00d5152c  00:000018    _exit

Stepping through in turbo mode:

12f704	02:00004f	zoo
d51520	00:000036	vocabToClass
d51524	03:000000	object
d50068	00:00002e		_doClassType
d51528	5b:000004	MethodWithTOS(4)
d51530	cd:cdcdcd	?huh?

Somehow after MethodWithTOS(4), which should be the 'new' operator, the IP has
been incremented by 8 instead of 4.
When we get to _methodWithTOSType, IP is d5152c, which is correct.
At the end of _methodWithTOSType, it jumps to interpLoopExecuteEntry with
the allocateObject opcode 1B7 in eax, it figures out that it is a builtin op,
but that the op is only implemented in C++, so it calls extOp, which loads the
opcode from ecx-4, so it is getting 5b000004, then it masks off the top byte,
giving it opcode 4, so it executes the C++ version of 'lit', which advances the
IP by 8 instead of 4 since it has an immediate argument.

The problem is that extOp is grabbing its opcode from ecx-4 instead of using
the opcode which is already in eax.  This should fail for anything which calls
interpLoopExecuteEntry, so I'm guessing 'execute' probably has the same bug.

In this particular case, ebx has a copy of the opcode we want executed, there
must be other cases where extOp gets called and the opcode isn't in ebx.

I changed extOp to take the opcode in ebx, the optype routines already were
using ebx for the opcode, I just had to change a few spots in the inner
interpreter to use ebx instead of eax.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 21, 2011

If I execute "object.getClass" twice, the second time results in a return
stack underflow.

object.getClass  // should return the 'class' class object
class.getClass   // should also return the 'class' class object

It looks like the underflow only happens in interpret mode.
-> The bug was caused by ForthClassVocabulary::DoOp not clearing the varOp set
   by vocabToClass, so ForthTypesManager::ProcessSymbol was compiling a bogus varOp
   setting op before the last field accessor
   
It looks like global arrays have the element length stored in a long just after
the _doXXXArray opcode, but if you store to element 0 it overwrites it.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 16, 2011

Fixed the crash, in ForthInterface::SetMethod I wasn't taking into account the
fact that methods[0] now holds the class object pointer, so when 'class' overrode
method 0 (delete) it actually overwrote the class object pointer.

Class object stuff now seems to be working.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 15, 2011

While looking at supporting CLASSNAME.METHOD, I noticed a few things in
ForthTypesManager::ProcessSymbol:
- the section for handling when the first token is a pointer/array is ifdefed
  out, there is code which handles the pointer-to-object case
+ the handling for the case where the preceeding opcode was a varop setter
  should be changed to move the varop to just before the last op, not just
  after the first op
+ the vocabulary entries for methods don't have a way for a method to return nothing

At the end of the day, the class object was mostly working, but there is a
crash if you do this:

object.new -> object foo   foo.getClass.show

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 14, 2011

My current thinking on class objects and new:

Each class will not have a 'new' method, the class object for each class will
have a newOp member variable which holds the 'new' forthop for that class.  The class.new
method will just invoke the classes newOp member.

The syntax for object creation will be:

new CLASS_NAME
OBJ.getClass.new
CLASS_OBJECT.new

+ when a class vocabulary is created, it will create a class object, and there
  will be a pointer to the class object in the class vocabulary
+ class vocabulary destructor will delete class object
+ the class object will have:
  o a pointer to the class vocabulary
  o the new operator
+ there will be a class.setNew method
+ there will be a class.new method
+ the header field of each interface will point to the class object
+ there will be a default new forthop _allocObject, which will take a class vocabulary
  pointer, will use the class vocabulary to get the storage length, will
  malloc storage of that size, and will push the allocated storage address
+ the 'new' forthop will need to be implemented
+ all 'class' methods will have to be changed, since 'this' data pointer is
  no longer the class vocabulary pointer

When I tested this, there was a crash in 'implements:' because it was creating
an interface, but wasn't passing the class vocabulary to the interface constructor,
and now the interface constructor uses the class vocabulary to get the class
object since it stores the class object pointer in the methods table header.
I don't know if there are things which rely on non-primary interfaces having
a null defining class.

Bugs that came up during testing:
+ there was a slight difference between the text output of classtest.txt in
  turbo and regular mode
  -> classtest.txt prints out an uninitialized string variable
- classtest.txt had an error message complaining about structs not having
  the expected size - this may not be a new error
- classes are not automatically derived from 'object'
- the predefined classes & methods don't have the correct return types
+ CLASS_OBJECT.new does not work
  ? is CLASS_OBJECT.METHOD needed
  - this will need to work in both interpret and compile mode

CLASS_OBJECT.METHOD doesn't work because the op which has the class name
symbol is the op which defines an instance of the class.  There is no op
defined which returns the class object like a global variable.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 13, 2011

I added return types to builtin-class methods.
I have currently defined the 'new' and 'getInterface' methods to methods of
'class', I probably have to rethink that.  My thinking is that 'new' shouldn't
be in the methods table, because you would never call .new on an instance of
an object, and you need to call .new before you have any instances of an object.
Maybe 'new' is not a regular method at all, it is an op that is part of the
class object - this would argue for having a class-object that is separate
from the class vocabulary

The good thing about the current arrangement is that for a large number of
classes the existing class methods would be fine, but it won't work for all
classes.  The 'class' class methods should be universal:
  getName
  getSuper
  getVocabulary
  
class.new really doesn't belong there.
class.getInterface also isn't universal, a type might want to return a
different data pointer for different interfaces.
I really need to think about what gets compiled for the 'new' method.
To have a generic constructor, it needs access to either the class vocabulary
or some class object, or at the very least the object storage size.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 11, 2011

I added most of what is needed to have predefined 'object' and 'class' classes.
What remains:
1) Make ForthTypesManager::ProcessSymbol handle the CLASSNAME.CLASSMETHOD case
2) Change ForthTypesManager::AddBuiltinClasses to define the return types of
   the predefined class methods
? Is there a chicken-and-egg problem here - object.getClass method needs to
  be defined to return an object of type 'class', but class.getInterface needs
  to return an object of type 'object'
  -> not a problem if we predefine the classIndices for all builtin classes
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 10, 2011

I need to document how to implement methods in assembler.  I think that all
that is necessary is to pop TPD & TPM off the return stack.

Can non-public methods be coded to not push/pop this?

What is created in memory when a class is created?

'class' op compiles (also done by ForthEngine::AddBuiltinClass)
  0  _doClassType opcode
  1  ptr to vocabulary for class

In order to add the 'class' type, I need to provide some way to get to the
class vocabulary or class object from an object.  The only thing an object
reference has currently that connects it to its class is the method table pointer.
I'm thinking that the way to do this is to put either the class vocab pointer
or the class object pointer into the method table, or maybe just preceeding it.

What exactly is a class object?  Is there any reason that the data pointer
for it shouldn't just be the vocabulary pointer?
If the class/object system was separated from the forth vocabulary implementation
it might make it easier to implement/extend more of it outside the C++ kernel.

What does class.getClass do?

What are the forth objects that exist at startup?
  'object' class object
  'class' class object?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 8, 2011

I added the 64-bit comparison operators as well as lmod and l/mod.
If I ever decide to do assembler versions of the 64-bit ops, there are asm
version of multiply & divide in MS Visual Studio 2003/vc7/crt/src/intel

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 6, 2011

I added partial support for 64-bit integers:

o I added 64-bit literals to outer interpreter, add 'L' or 'l' to end of an
  integer literal to make it 64-bit
o I added 64-bit ops:
  l+ l- l* l/ i2l f2l d2l l2f l2d %lld %llx
o I added the 'long' datatype

: test10s  1 -> int v  30 0 do v 10 * -> v v %d %nl loop ;
: test10l 1l -> long v 30 0 do v 10l l* -> v v %lld %nl loop ;

Not done:
o comparison operators (needed)
o offset operators like 1+L (not needed)

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 20, 2011

Document these ops:
  class:  ;class
  method:  ;method
  returns
  doMethod
  implements:  ;implements
  union
  extends
  sizeOf   offsetOf
  new
  initMemberString

I'm thinking that methods which you want all objects to handle should be done
by adding a single method 'process', which takes:
 1) interface index
 2) method index
 3) arguments (should there be an argument count on TOS?)

Methods which all objects must support would be made a part of the 'common'
interface, and would include things like:
o get interface
o serialize
o convert to string

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 12, 2010

Back looking at class stuff.  I am currently thinking about how to implement
class objects.  Class objects would have methods that you would want to apply
to all objects, like construction/destruction, object display, parent class,
class name.  Generic container class implementation could be simplified if
certain operations could be handled using the same method in all classes.
It would also avoid having duplicate names for class methods in every class.

I think there is a name collision - "object" is both a builtin generic object
instance defining op (like "int" or "float"), it is also a class vocabulary.
-> it looks like the one in forthops is redundant and is never called, I commented it out

How things work as of today:

---
class: CLASSNAME
o defines a class vocabulary
o compiles:
  _doClassType
  <ptr to class vocabulary just defined>
  
When executed, _doClassType calls pClassVocab->DefineInstance, which normally
just defines a global/local variable or a field with this class type.
NOTE: this does NOT create an instance of this type, it just creates a
 methods/data pointer pair which are initialized to NULL
 
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 7, 2010

I added 2 things:

o you can now explicitly specify vocabulary name as in
	VOCABNAME:OPNAME
  Explicit vocabulary specification can be used with global structures:
	VOCABNAME:INSTANCE_NAME.FIELDS
	
o you can cast the top of stack to a class/struct pointer
	<TYPENAME>.FIELDNAME
	
I was originally going to use (TYPENAME), but that would have complicated
the current parenthesis code, which is in ForthShell and ForthEngine.  The
current cast code is isolated to ForthTypesManager::ProcessSymbol.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 30, 2010

I added assembler version of floating point comparison operators.

I had started to add thread support but wound up backing it out when 
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 28, 2010

I spent some time trying to get ForthMidiExtension to work.  There is a crash
that happens when I open a midi input port.  The overall situation is:
 ForthMidiExtension::OpenInput
  winmm.lib::midiInOpen
   ForthMidiExtension::MidiInCallback
    ForthMidiExtension::HandleMidiIn
    ... crash ..
HandleMidiIn and MidiInCallback appear to be fine, the crash happens after
MidiInCallback returns but before midiInOpen returns.
The PC is 0 and there is no valid call stack (why?)
I ifdef-ed out the forth related stuff, all forth does is call midiInOpen,
the callback doesn't do anything with forth, and the crash is unchanged.
After we return from ForthMidiExtension::MidiInCallback we are in dissassembly
land and it looks like we are in a simple wrapper, the PC becomes zero when
the next return instruction happens.  So why isn't the return address where
the callback wrapper expects it?
After I get the crash 2 or 3 times, the program hangs on startup without
ever getting to main.  The call stack shows many levels of calls in ntdll,
kernel32, winmm, xgusb and myokent dlls.  After this I can't start the task
manager and many programs won't startup either.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 21, 2010

I ported the kforth assembler to this forth, intending to replace gforth, but
I can't get it to generate the correct code for  "edi jmp," which is needed to
return to the inner interpreter.  I was interested in it mainly because I
haven't found any real documentation for the gforth assembler, particularly
how addressing modes work.  I finally gave up on the kforth assembler.

- figure out and document addressing mode syntax in gforth assembler
  - create assembler tests
- figure out and document gforth assembler control structures
  
+ fixed a bug in my port of gforth pentium assembler that was leaving zeros
  on the stack after assembling code

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 16, 2010

+ I added conditional compilation support words - #if #ifdef #ifndef #else #endif

- I tried to add inline assembly ops, but kept running into problems - I need
  to find out more about how to use the gforth assembler
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 4, 2010

I added r[ and ]r, which are used for variable numbers of arguments, and I
added some definitions which use them which build tables of the basic types.

I've mainly been working on SoftSyn2 for the past 7 months.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 1, 2009

BOOL CForthGuiAppDlg::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
  nID: id of the control
  nCode: tells how to interpret pExtra
  pExtra:
  pHandlerInfo:
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 28, 2009

Did a quick look around at ways to support dynamic dialogs.  These are the
ways I found:

1) use standard GUI wizard to create a crapload of controls which are all
   initially hidden, unhide them when you need them
   + least complicated initially
2) use OnCmdMsg handler and process the command messages
   + most flexible
   - requires a lot of knowledge about control messages
3) use ON_CONTROL_RANGE in the message of a dialog class to map a range of
   control IDs to a specific handler
   + could be combined with method 1
4) dynamically build the message map at runtime (Dr. Dobb's article tells how)
   - can't easily add a control after dialog is visible
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 18, 2009

Been away for a few months.

Did some thinking about adding threads to forth, in particular how this
would affect the server, and the different forth use scenarios (standalone
console app, script support in local apps, script support in remote app/game)
and I think I know how to proceed.  The details are in ForthThreads.txt and
ForthServer.txt.

The first step will be to create a good set of backups.

o The main loop in ForthShell::Run will be removed, most of its functionality
  will go into a new method ForthEngine::Update

o ForthEngine will be responsible for managing thread lists or queues

o ForthClient will be changed to do its console fgets in a separate Windows
  thread

o ForthServer methods which send messages to the clients will be broken in two,
  with the part which waits for the client response and then process it being
  removed and put in a single common client response processing method

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 1, 2009

DOHHHHHHHHHHHHHHHHHH!
The problem with the DS server is that recv always returns SOCKET_ERROR until
it gets the requested number of bytes...
Removing that made the DS server work fine...

Can't run forthtest.txt, it uses "demo" which is defined in forth_autoload.txt,
and forth_autoload.txt won't load on the DS because it uses the "system" op.
-> See if system op can be made to run easily on the DS
? Maybe make it a shell operation, like the way file operations are?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 19, 2009

A quick overview of the windows client:

  init winsock
  create ConnectSocket  (AF_INET, SOCK_STREAM, 0)
  fill in ClientService with IP address of server, port 27015
  connect to server
  if connect worked
    create pMsgPipe    ForthPipe( ConnectSocket, valid messages are in kClientMsgDisplayText...kClientMsgLimit )
    push stdin on top of inputStack
    while !done
      get a message from server
      process message
  cleanup
  cleanup winsock
  exit

A quick look at ForthDS.txt and ForthNotes.txt shows that the last known
working version of Forth.NDS was on May 31, 2009.

The source files which have been modified after that date are:
modified						rev		revDate
jun4	ForthInner.h			10		may25
jun6	ForthInput.cpp			6		jun19
jun6	ForthInput.h			6		jun19
jun23	ForthInner.cpp			16		jun27
jun28	ForthShell.cpp			18		jun27
jun28	ForthShell.h			13		jun27
jul1	ForthMessages.h			1		jun28
jul10	ForthOps.cpp			25		jun27
jul12	ForthPipe.cpp			1		jun28
jul18	ForthPipe.h				1		jun28
jun30	ForthServer.h			2&3		jun28			1	jun19
jul1	ForthServer.cpp			2&3		jun28			1	jun19
-------------------------
jun29	ForthServerMain.cpp		2		jun28			1	jun19
-------------------------
jul1	ForthClientMain.cpp		2&3		jun28			1	jun19
jul2	main.cpp				2		jun28			1	jun19

It appears that I really only have a snapshot of June 19, but the changes between
May 31 and June 19 seem to all be related to Thumb versus Arm assembler changes,
not networking changes.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 15 2009

The current use of bracket to switch into interpret mode seems like a waste
of a potentially very valuable synctactic element for a very limited use.
I think it would be better if "[" was treated like a special character by the
outer interpreter, to help disambiguate operations on array members from
operations on the array itself.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 1, 2009

Got a lot of work done in the windows version of client/server, details are in ForthNotes.txt:

o file IO goes through the shell, and works for client/server
o fixed a bunch of existing client server bugs
o broke out client/server communication into ForthPipe

Ugh, when I brought the DS forth server up, after it connects it gets an
error back from the first recv call! DOH!

------
Server									Client

connects to access point
waits for a client to connect
										connects to server
										waits for a message from Server (forever)
accepts connection
sends SendLine("ok>") message
calls recv to get reply
recv returns error

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 30 2009

Looked at the "load blah.txt" bug - what is happening is that after trying to
load a non-existant file, there is a one line delay between when you send a
line to the server and when you get the response.  This delay increases by one
line each time you try to load a bogus file.

The problem appears to be that right after the server sends a "StartLoad"
message, it sends a "SendLine" message, since it is done processing the
line that had the bogus load command on it.

+ adding a kServerMsgStartLoadResult message fixed it

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 29 2009

+ created separate solutions for ForthClient and ForthServer - it just makes
  it easier when running multiple sessions of MSDEV to do client/server debug
  
+ fixed the disconnect problem that happened after loading forthtest.txt -
  the problem was that when a "loaddone" opcode was executed, the client was
  not told to pop its input stack, so it kept on reading forthtest.txt until
  it hit the end of file, at which point it sent a "pop input stream" to the
  server, which caused it to disconnect
  ? should server ignore "pop input stream" when the input stack depth is 1 ?
  
The bug where things get screwy after you type "load blah.txt" when blah.txt
doesn't exist is probably very similar

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 28 2009

+ finished implementing the remote file operations

+ partially tested file operations locally and remotely, they work

o I had switched numItems/itemSize in fread and fwrite ops, I switched them
  back everywhere, I think...
  
o I turned off 64-bit compatability warnings because they harped about storing
  file pointers in ints...

Known differences/problems when using server:
+ sometimes the prompt doesn't appear on its own line
- sometimes there are multiple prompts printed on a line after loading a file
- if you type "load foo.txt" and foo.txt doesn't exist, if you then type in
  the correct name, it looks like the load doesn't happen right away, it
  happens after you enter another console line... maybe...
+ sometimes after loading a file, the server shows the client as disconnected,
  while the client is permanently stuck waiting for the next 8-byte message header
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 27 2009

+ Added ForthPipe abstraction which implements message passing between client
  and server, and converted over old ForthClient/ForthServer to using it, got
  it working on Windows, need to try it out on DS

+ need to add remote file operations using ForthPipe

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 26, 2009

Started reworking server/client messages to be more regular, to make
implementing remote file access easier.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 21, 2009

DS asm inner interpreter is completely switched over to ARM mode.
Also implemented many more ops in assembler.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 19, 2009

Switching DS asm inner interpreter to ARM mode gives us registers r8-r12 to
use.  I plan to use them like this:

@	R0 - R3		scratch		(R0 is pCore at start)
@	R4			core ptr
@	R5			IP
@	R6			SP
@	R7			FP
@	R8			RP
@	R9			builtinOps table
@	R10			#builtinOps
@	R11			actionType table
@	R12			0xFFFFFF (opvalue mask)

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 13, 2009

Got Desmume built on second system, copied over to this system.
What I am doing:
- double-click E:\pat\prj\NDS\Desmume shortcut, which has " --arm9gdb=1234" param
	File\Open	Forth.nds
- double-click C:\bin\devkitPro\insight\bin\arm-eabi-insight.exe
	File\Target settings
		Target:		Remote/TCP
		Hostname:	192.168.1.150
		Port:		1234
	Run\Connect to target
	File\Open E:\pat\prj\Forth\Forth.elf
	Run\Run
	If a popup comes up saying "Make breakpoint pending on future shared library load?",
		click "No" - clicking "Yes" crashes Insight.
If you reload the file in insight, you need to reload it in desmume as well
Sometimes when insight gets stuck, doing reset on desmume unsticks it

All assembler functions need to be preceeded with ".thumb_func", or else
arm-mode instructions are generated, and the cpu misinterprets arm instructions
as thumb instructions leading to crashes.
? is there a way to tell the gnu assembler that the whole file should be thumb
? should I switch the inner interpreter to be arm mode?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 5, 2009

Tried DS Forth in the iDeaS emulator, they say SWI #FD will break into the
debugger, but it didn't work for me.

-> it looks like it only works in ARM code, not THUMB code

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 1, 2009

Looking at ARM assembly language

InnerInterpreter:
	push	{r4, r5, r6, lr}
	mov	r3, #0				// SET_STATE( kResultOk )
	ldr	r5, .L146			// r5 = 0x00FFFFFF
	mov	r4, r0				// r4 = pCore
	str	r3, [r0, #64]		// r0 = pCore
.L143:
	ldr	r3, [r4, #36]		// r3 = IP
	mov	r0, r4				// r0 = pCore
	ldmia	r3!, {r1}		// r1 = next opcode, advance IP
	str	r3, [r4, #36]		// save IP in core
	lsr	r2, r1, #24			// r2 = opType (hibyte of opcode)
	ldr	r3, [r4]			// r3 = opType action routine table address
	lsl	r2, r2, #2			// turn opType into longword offset
	and	r1, r1, r5			// r1 = low 24 bits of opcode
	ldr	r3, [r2, r3]		// r3 = action routine for this opType
	blx	r3					// dispatch to action routine
	ldr	r0, [r4, #64]		// get state from core
	lsl	r0, r0, #24			// mask off top 24 bites
	lsr	r0, r0, #24
	cmp	r0, #0				// keep looping if state is still ok (zero)
	beq	.L143
	pop	{r4, r5, r6, pc}
	
	.align	2
.L146:
	.word	16777215

	
	
eForthResult
InnerInterpreter( ForthCoreState *pCore )
{
    ulong opVal, numBuiltinOps;
    forthOpType opType;
    long *pIP;
    long op;
    numBuiltinOps = pCore->numBuiltinOps;

    SET_STATE( kResultOk );
    
    while ( GET_STATE == kResultOk ) {
        // fetch op at IP, advance IP
        pIP = GET_IP;
#ifdef TRACE_INNER_INTERPRETER
        GET_ENGINE->TraceOp( pCore );
#endif
        op = *pIP++;
        SET_IP( pIP );
        opType = FORTH_OP_TYPE( op );
        opVal = FORTH_OP_VALUE( op );
        pCore->optypeAction[ (int) opType ]( pCore, opVal );
    }

    return GET_STATE;
}


	
	
	
// A B + ... (A+B)
// forth SP points to B
//
plusOp:
	push	{r4, lr}	// save r4 and return address
	ldr	r3, [r0, #40]	// r3 = SP
	mov	r2, r3			// r2 = SP
	ldmia	r2!, {r1}   // r1 = B, r2 = SP after popping B
	ldr	r4, [r3, #4]	// r4 = A
	str	r2, [r0, #40]	// save new SP
	add	r2, r4, r1		// r2 = A + B
	str	r2, [r3, #4]	// push r2 (result of A + B)
	pop	{r4, pc}		// restore r4 & return

	
// A B - ... (A-B)
//
minusOp:
	push	{r4, lr}	// save r4 and return address
	ldr	r3, [r0, #40]	// r3 = SP
	mov	r2, r3			// r2 = SP
	ldmia	r2!, {r1}   // r1 = B, r2 = SP after popping B
	ldr	r4, [r3, #4]	// r4 = A
	str	r2, [r0, #40]	// save new SP
	sub	r2, r4, r1		// r2 = A - B
	str	r2, [r3, #4]	// push r2 (result of A + B)
	pop	{r4, pc}		// restore r4 & return

timesOp:
	push	{r4, lr}	// save r4 and return address
	ldr	r3, [r0, #40]	// r3 = SP
	mov	r2, r3			// r2 = SP
	ldmia	r2!, {r4}   // r4 = B, r2 = SP after popping B
	ldr	r1, [r3, #4]	// r1 = A
	str	r2, [r0, #40]	// save new SP
	mov	r2, r4			// r2 = B
	mul	r2, r1			// r2 = A * B
	str	r2, [r3, #4]	// push r2 (A * B)
	pop	{r4, pc}

	
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 31 2009

I switched over to the combined build with an explicit arm7 section, but it
still didn't work, then I found an error in my accept call, fixed that and
now the DS Forth server connects to the PC client and works! Woohoo!

There is a problem when an error occurs while doing a "load", the input
stream is not sent back to the console, so you get a cascade of errors.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 30 2009

I noticed that wifi_example1 and wifi_lib_test, which I got from the dswifi site
both have an arm7 source file which sets up the network.

The DSMI examples (DS midi wifi) all have an equivalent arm7 section.

The nds-examples-20090504\dswifi examples, which I got my Forth Makefile from,
do not have arm7 sections - say huh?
? are they loading an arm7 lib from somewhere
? are they out of date
I did build and run the ap_search and autoconnect examples, and they do work.

I found a website with a NDS tutorial (http://www.double.co.nz/nintendo_ds/nds_develop1.html)
that says that libnds includes boilerplate ARM7 code, and that devKitPro includes
this, but the tutorial wasn't talking about network stuff.

The dswifi forums are down, supposed to be back up June 3 (Wednesday).

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 25 2009

+ rearranged some things to make server-client split easier
+ got client-server working on PC
+ changed build target configurations - before all executables were a single target

Client takes server address as a command line argument, uses localhost if no arguments.

! right now, ForthClientMain doesn't include any Forth files, so the definitions of
  server and client command message numbers are both in ForthClientMain.cpp and in ForthServer.h,
  they are bound to get out of sync...
  
+ got Forth server to compile for DS, but it didn't do anything when I ran it...
  -> there may be more DS wifi hardware setup required
  
server    --kClientCmdSendLine(prompt)->      client
client    --kServerCmdProcessLine(text)->     server
client    --kServerCmdPopStream->             server

server    --kClientCmdStartLoad(filename)->    client

-> means server to client
<- means client to server

-> getLine( ok> )
<- data( load blah.txt )
-> pushStream( blah.txt )
-> getLine()
<- data ( ... )

... repeat previous 2 lines for each line of file ...

-> getLine()
<- endOfFile ( ... )

-> getLine( ok> )

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 24 2009

Forth on the DS will run as a server, with a command shell client running on
the PC.  The client will be responsible for sending text to the server, and
for displaying text from the server.
The first step is to make a client-server version of Forth where both client
and server run on the PC.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 23 2009

Got Forth to compile for the DS under devkitPro.  There are a few new defines
used, _WINDOWS and _ASM_INNER_INTERPRETER.

There are still a lot of warnings when building for the DS.

Replaced MFC containers with STL containers.

+ also, replaced strtime and strdate ops with time and strftime ops, this
  allows more complex formatting and also works on the DS

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 4 2009

Got the SPriG dll to work, I forgot to do SDL_UpdateRects after drawing

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 3 2009

Tried to get SPriG, an SDL based graphics library to work, couldn't get it
to draw a line, after running there was extra junk on stack.
Several params are declared as Uint16, could this be screwing things up?
I thought short params were promoted to long on the stack

Also, sdltest.txt now leaves extra junk on stack.
-> there was an enum that was defined twice - enum definitions rely on
   the new enum symbols being undefined, since during an enum definition
   any defined symbol is just executed

Some of the SPriG functions take a callback, this brings up the question of
adding a general callback mechanism - a way to have callbacks from DLLs
execute forth code.
o it wouldn't be hard to implement this
o may need to support callbacks that return a value and callbacks that don't

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 30 2009

Making vocabularies be a kind of object has some problems - for one thing,
we would probably want them to ignore the "delete" method and "->".
I'm now leaning toward having a set of "class methods", either using a
dotted syntax like "className.new" or prefix syntax like "new className".

class methods:
	new
	parent
	size
	methods
	id
	
Use "classA.id objB.queryInterface" to get the classA interface from objB - the
result is an object - if objB does not have a classA interface, the result is
the null object (double zeros).
	
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 29 2009

I changed the initialization of the builtinOp and optypeAction tables in the
forth core to only be done once in ForthEngine->Initialize.  Previously this
was being done also in ForthEngine::SetFastMode, since those tables were used
for both fast and slow modes.  SetFastMode was not filling in any builtinOps
which were not in baseDictionary, such as builtin classes or user-defined builtins

The next challenge is defining what appears in the builtin classes.  A lot of
functionality is hard to define without making some decisions - like how do
you specify the interface you want to a queryInterface method?  I am leaning
toward defining a classVocabulary class, parented off a vocabulary class,
parented off the object class.

object : NULL
	delete
	data
	methods
	show
	class	(returns a classVocabulary object)
	size
	queryInterface

vocabulary : object
	uses
	also
	? something to undo "also" ?
	only
	definitions
	numEntries
	find
	addEntry
	removeEntry
	* some way to iterate through entries *
		* info about entries - number of longs in data section
	
classVocabulary : vocabulary
	parent
	methods
	classId
	isAbstract
	numMethods

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 28 2009

Messed around with asm version of kernel, got it to use the static tables
opsTable and opTypesTable instead of the stuff in FCore

+ change table init routines to always fill in core optypeAction and builtinOps
  with C versions
+ replace extOp macros with a single extOp routine
+ fill in FCore.numAsmBuiltinOps with # entries in opsTable, and have
  inner interp check against that, and call extOp for entries which are past
  end of table
+ rearrange opsTable to put most routines without asm versions at end, remove
  as many at end as possible
+ change FCore to just have a pointer to opTypesTable instead of the whole table
  in the structure
+ currently assembler version of opTypesTable uses badOp for all optypes for
  which there is no assember version, replace this with something that invokes
  the C version instead - if the optype is truly unimplemented, the C version
  will signal the error
  -> until this is fixed, all optypes must have an assembler version...
+ take advantage of the fact that ESI register is no longer reserved for opsTable

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 27 2009

I started putting in support for builtin classes, then I realized I hadn't
put stuff in CVS in a while

Right now when switching in and out of turbo mode the opType dispatch table
and builtinOps tables in the forth core are re-initialized - I think it would
be better to have copies of asm and c versions of the tables in the core
that were initialized once.

+ get stuff to compile with partially done builtin class support
+ bring CVS up to date
x have asm and c modes use separate tables in forth core
+ replace the extOp macro with a single asm routine that grabs the c routine
  address from the c builtinOps table
? maybe move the majority of c-only ops to the end of the builtinOps table
  and allow the size of the asm table to be smaller
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 26 2009

More fiddling with dynamic dialog creation.

There is a fair amount of functionality in the CWnd class that would be useful
to have available to derived controls - setting position, label text, styles
and so on.  The most convenient thing to do would probably to define a set of
forth classes corresponding to CWnd and the derived controls.  This would
require creating built-in classes, something I haven't done yet.

While working on ForthEngine::AddBuiltinClass I noticed that overwriting a
method probably adds a redundant symbol to its class.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 24 2009

+ Fixed boundary cases for assembler comparison ops - this should fix "dump".

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 21 2009

Started fiddling with dynamic dialog creation.

Some simple controls could be handled by just adding a OnCmdMsg handler to the
top level generic dialog.

----------
Step 1 - Static text control
CStatic* pStatic = new CStatic;
pStatic->Create( "some text",
                 WS_CHILD | WS_VISIBLE | SS_CENTER,
                 CRect(10,100,100,130),
                 pDialogWnd,
                 controlId );

----------
Step 2 - Pushbuttons
CButton* pButton = new CButton;
pButton->Create( "button text",
                 WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                 CRect(10,100,100,130),
                 pDialogWnd,
                 controlId );
pButton->SetWindowText( "Woohoo!" );
Other button types:
	BS_PUSHBUTTON
	BS_RADIOBUTTON
	BS_AUTO3STATE
	BS_AUTOCHECKBOX
	BS_AUTORADIOBUTTON
	BS_CHECKBOX
	BS_RADIOBUTTON
	BS_3STATE 

I'm not sure what would be involved with doing radio buttons in terms of
grouping them.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17 2009

Need a way for a class to return secondary interfaces...
- implement a generic queryInterface class method
- require individual classes to implement explicit "getInterfaceX" methods

Inside secondary interface methods, how can methods from other interfaces be
accessed?  Possible approaches:

1) they can't - that is what is currently implemented - you could still do it
   manually by creating local objects with the appropriate methods/data pair

2) concatenate all interface vtables, the method number is relative
   to current interface, negative values and numbers larger than the current
   interface method count would refer to methods in other interfaces of this
   class - actually, you would only need negatives, since you could only refer
   to methods defined in previously defined interfaces
   -> that would require that all the methods for each interface are specified
      in one shot - you couldn't define some primary interface methods, then
      implement a secondary interface, then add some more primary interface methods

3) when a cross-interface method is compiled, it is compiled as code which pushes
   the object pointer pair for the target interface and then uses the MethodWithTOS
   opcode type to invoke the method
   
I decided to try out the assembler again, I found that it works, there is a
problem where some ops leave crap on stack when they are done - in particular,
the "next," op leaves 2 zeroes.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 16 2009

Methods returning an object as a non-final selector works...

Stuff to do:
- class/struct support
  - "implements" & "queryInterface"
  - class methods - new/delete/queryInterface/show/
  ? have all classes derive from a base "object" class
  - struct accessor optimizer
- testing
  - more tests of datatypes: locals, structs, classes
  - more automated tests of core forth stuff
- sample block ops
- GUI app support
- assembler documentation and test

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 14 2009

Been off doing other things...
Starting debugging methods which aren't final selectors - I really still need
to define how methods as final selectors work, in particular if the return
value is an array - should I be compiling an array accessor, and should it
use varAction?
o if you want to have varAction work on data inside an object, use an object
  data member as an accessor, not a method
o you can have methods use varAction if you want to code it that way
o when final selector is a method, do nothing about method return type
  ? it feels inconsistent/broken to allow array indexing to be done on non-final
    selectors but not on final selectors...
o a non-final method selector whose base type is byte/short/int/float/double is illegal
! maybe the right choice is to only allow "returns" to take a struct/class type,
  with no ptrTo or arrayOf modifiers.  This is actually the most flexible choice,
  since the method could take an index argument if an array is involved
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 7 2009

+ made turbo versions of most of the file operations

+ made turbo versions of doExitMOp and doExitMLOp - the rstack underflow
  checking doesn't seem to be working, though
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 5 2009

Try loading foo.txt in non-turbo mode, switch to turbo, then do "addressOf kk kookoo",
switch back to non-turbo and repeat - the namb and numb fields of kk were modified
by reading or printing them from turbo mode...

-> the problem was that the turbo version of dfetch was badly broken

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 3 2009

Bugfixing struct and class stuff.

An unrelated bug: if you do "dump" in turbo mode, it displays a different
number of rows of output - it looks like there is one extra row, as long as
the last expected row...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 2 2009

Ugh, my graphics card died yesterday, killing a day.

There is a memory trash bug, it is triggered by LocalIntArray, but I think it
is because the opVal coming in is 0x2004, when it should probably be 4.
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 28 2009

The basic class support seems to be working - I haven't tested many combinations
of member accessors, but I can access members of local and global objects,
including arrays and pointers, and I can invoke methods on objects.

There are crashes running class stuff in turbo mode.

One thing I don't think I implemented is allowing field accessors or methods
on member variables.

I added "returns" op, it doesn't work at the moment.

If you start forth, run structtest.txt, then do "bye", there is a crash
while trying to delete the parameter stack of the current thread.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 27 2009

First field code for object accessors:

+ gobj1.blah					global object
	gobj1			doObject drop
+ pgobj1.blah					global ptrTo object
	gobj1			doInt d@ drop
+ 1 gaobj1.blah					global object array
	gaobj1			doObjectArray drop
+ 1 gapobj1.blah				global ptrTo object array
	gapobj1			dOIntArray d@ drop

+ lobj1.blah					local object
					LocalObject drop
+ plobj1.blah					global ptrTo object
	gobj1			LocalInt d@ drop
+ 1 laobj1.blah					local object array
	laobj1			LocalObjectArray drop
+ 1 lapobj1.blah				local ptrTo object array
	lapobj1			LocalIntArray d@ drop

Most of the broken ones are pointer types - they are all missing the d@.

If we implemented an opcode which added an offset to TOS and then did a fetch,
that could replace the "d@ drop", and could also be useful in struct accessors
whenever a pointer field was used - these usually compile into (offset(N), @).
-> But you don't know if you should use offsetFetch until you process the next
   field, since if it is a method you need both pointers on TOS
   -> There should be a final optimization step
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 26 2009

There is a problem with local and global ptrTo array implementation - an intArray
is used, and the intArray will use the varAction which is meant for the field code...
For example:
	5 -> 4 pFoo.A
compiles into
	lit 5
	->
	lit 4
	_dOIntArray(pFoo)
	FieldInt(A)
and the varAction set by "->" is used by _dOIntArray, not FieldInt.  The code
which compiles field accesses does handle the case where the varAction symbol
is just before the field accessor, but in array access cases the array index
calculating op(s) are usually just before the field accessor.

There is also a general problem with the varAction being consumed accidentally
if there are any variables used in calculating the array index.
The general (ugly) solution to this problem is to require that the varAction
op be placed just before the field accessor:
	"5 -> 4 pFoo.A"		is replaced with	"5 4 -> pFoo.A"

A better workaround might be to use parens:
	5 ->( 4 ) pFoo.A
This looks silly in this case, but might help with cases where the index
calculation uses variables...


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 25 2009

+ added "lsize" - number of longwords in local variables
+ added "dlocals" - displays local variables

Ran into some crashes while testing class support, writing tests to check both
struct and class support.
-> all local arrays were allocating 0 bytes because ForthEngine::SetArraySize
   wasn't being called before calling ForthEngine::AddLocalVar and ForthEngine::AddLocalArray
   
First field code for struct accessors:
+ gstr1.blah					global struct
	gstr1			doStruct
+ pgstr1.blah					global ptrTo struct
	pgstr1			doInt
+ 1 gastr1.blah					global struct array
	gastr1			doStructArray
+ 1 gapstr1.blah				global ptrTo struct array
	gapstr1			dOIntArray
	
+ lstr1.blah					local struct
	lstr1			LocalRef
+ plstr1.blah					local ptrTo struct
	plstr1			LocalInt
+ 1 lastr1.blah					local struct array
	lastr1			LocalStructArray
+ 1 lapstr1.blah				local ptrTo struct array
	lapstr1			LocalIntArray
	
Here is what the rstack should look like when local variables are defined:

ok> : woo hex drstack int aa int bb int cc drstack 5 -> aa 7 -> bb 9 -> cc drstack ;
ok> woo
rstack: 12f844
rstack: 1 3 7 0 12f844
rstack: 9 7 5 0 12f844
The top 3 elements are the 3 local int variables, next is the old frame pointer,
and last is the return IP from woo.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 24 2009

? does the current structure support properly handle the case where the first
  field of an accessor is a pointer to a struct?

Ugh, some of the code assumes object variables have the native flag set,
other parts of the code require that object variables have the native flag
clear...

Why didn't I just have a typeCode bit for "array" - why is there a 2-bit
storage type field with choices none/single/array/illegal?  What does it mean
to have a storage type of none?
-> "none" had been used by enum opcodes to help with a problem with forgetting
   enums, but that had been made obsolete a while ago

I changed the typeCode around to have:
o bottom 4 bits are baseType
  o baseType are the old native types, plus struct
    o object is a baseType, but it is no longer a native
o isArray is a separate bit, there is no idea of single/none/illegal
o the top 24 bits is the stringLen/structIndex/classIndex
? Are there any changes needed in the assembler code, or is all the typeCode
  stuff always handled by the outer interpreter or C++ only code?

The field accessor stuff will need to be changed, some of it is still treating
object fields as native...

o changed ForthStructsManager to ForthTypesManager
o changed ForthStructInfo to ForthTypeInfo
o changed most uses of Native to BaseType

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 23 2009

The existing struct support handles struct accessors in 3 stages:
1) the first token, either a local or global struct (or pointer)
  -> compile opcode which pushes the address of base of struct
2) intermediate accessors
  -> compile opcodes which add offsets to TOS, or do an indirection on TOS
     for fields which are pointers
3) the final field
  -> compile fieldAction opcode based on the type of field

Things get a little messier with classes, because:
o an object field is automatically a pointer access, a ptrTo object field
  requires a double dereferencing
o a field which is an object needs to be processed differently depending on
  wether the next accessor designates a method or a member field - a method
  will require both pointers, a member will just need one of the pointers
  
Class support status:

-------
- objG.methodB						method invocation on global object objG
	objG
	OP( methodWithTOS, B )
+ methodB							method invocation on current object within method
	OP( methodWithThis, B )
- objA.methodB						method invocation on other local object
	OP( localObject, A )
	OP( methodWithTOS, B )
- objD.methodB						method invocation on other member object
	OP( memberObject, D )
	OP( methodWithTOS, B )
- stuff.objQ.methodB
	...stuff leaving addr of objQ on TOS...
	d@
	OP( methodWithTOS, B )

+ fieldC							member access within method
	OP( memberInt, C )
- objA.fieldC						(objA is local within method)
	OP( localObject, A )
	drop
	OP( fieldInt, C )
- objD.fieldC						(objD is a member variable)
	OP( memberObject, D )
	drop
	OP( fieldInt, C )
- objG.fieldC
-------
Member access and methods outside a method:
- objL.methodB						(objL is a local object)
- objL.fieldC

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 22 2009

+ Some class support is working, I can invoke methods using doMethod, the right
  vtable opcode is executed, stacks look after it is done.
+ "extends" works for classes
- currently member fields don't work in classes

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 21 2009

The next step for class support is to create "new", possible approaches:

1 - new sets a varAction
=========================
Syntax is "new blah"
o blah must be next opcode executed
o a struct/class defining word like blah is immediate, so it can define local
  instances while compiling.  doStructTypeOp/doClassTypeOp would need to be
  modified when compiling to check if the preceeding compiled op was a
  varAction setting op, and if so just compile appropriate code.
  doClassTypeOp:
  if ( state is compile )
    // either defining a local instance, or "new blah"
    if previously compiled op is a valid varAction (IE "new")
      compile blahOp (how do I know blahOp?)
    else
      DefineInstance of blah
    endif
  else
    if varAction is valid
      
    else
      DefineInstance of blah
    endif
  endif
  
  The code to be compiled can't just be the blah opcode - when it is
  executed, 
  ? what is the appropriate code

2 - new is an immediate op
==========================
Syntax is "new blah"
o blah must be next immediate token, on same line
o new grabs next token, and interprets or compiles appropriate code
o the code compiled would be:
  doNewClassOp
  <pointer to class vocab>
  ? what is the appropriate code

3 - struct manager ProcessSymbol handles new
============================================
Syntax is "blah.new"
o stuct manager ProcessSymbol recognizes blah as a class name and new
  as a special token and interprets/compiles appropriate code
  ? what is the appropriate code

In all these cases, we are stuck with the question of what should be
compiled - it can't be the blah opcode.

The minimalist in me thinks that a varAction approach is best, but varAction is
a kludge:
o varActions look like local operations, but use globals
o varActions break making methods be part of a struct accessor chain
o a varAction could be applied to the wrong object/variable
  o the same varAction value means different things for different datatypes
Also, struct/class type ops are currently defining words which eat the
next simple token, and they have precedence

- "sizeOf" and "offsetOf" will only work in interpret mode
  ? change these into varActions too
  
Currently varAction ops are implemented with non-precedence ops, should I
change them to precedence ops?
-> No, I don't think it would really fix the general varAction problems

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 18 2009

+ changed ShowVocab to use ForthVocabulary::PrintEntry

+ Changed "describe" to display the symbols of struct or class vocabularies

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 17 2009

I debugged a bunch of the simple problems with struct support.
	point p
	ptrTo point pp
	5 -> pp.x
The above currently has an exception because it compiles into:
  5 -> pp fieldInt(x)
which results in 5 being stored into pp, leaving the stack empty, then
the fieldInt(x) call tries to get the struct base address from TOS, adds
the offset of x, and then dereferences the bogus result address since
the store varaction was cleared when pp was executed.

----
How can we differentiate between setting the pointer and setting a field in
the struct the pointer references?

A structure/object accessor has the syntax
	start.end
or	start.middle.end	where middle can be many dotted ops

o start always compiles into an opcode which pushes the base address of the data
o end always compiles into an opcode which will actually affect the data, and
  which pays attention to the current varAction
o middle is a series of ops which can:
  o add an offset to TOS
  o do a fetch - replace TOS with the address it points to
  o do an array address calculation: replace a base address and index with the
    address of the indexed element
  o (someday) execute a method with a known return type
If the opcode compiled for start is a pointer var op, it can mistakenly
use the varAction which is intended for the end op.  Also, when methods
can be in the middle ops, the methods could interfere with the varAction.
On a different note, there is a potential optimization for local structs,
where the start op, middle ops and end op are combined into a single op which
is the same as a local variable op.
---

When compiling a field reference using a global pointer, look at the opcode
just previously compiled to see if it is one of (addressOf -> ->+ ->-) and if
so, swap the order of the previous opcode and the global pointer opcode.
But what if this is interpret mode? I guess in interpret mode we could save
the varAction at the start of processSymbol, clear the varAction, and compile
the appropriate varAction op after the first field opcode.

Actually, are there any ops other than the final op which use the varAction?
Not now, but when methods can be in the middle of an accessor chain, those
methods are very likely to internally modify the varAction

The first op compiled in a field accessor is always one of:
o global struct op - just leaves base address on TOS
o global ptr op - leaves ptr contents on TOS
o local struct op - just leaves base address on TOS
o local ptr op - leaves ptr contents on TOS
-> I overwrote the previously compiled varAction op with the first op of the
   field accessor code, and put the varAction op in the first element of
   the field accessor codes, it appears to work fine

I haven't tried complicated accessors where there is more than one level of
indirection.

+ I added "comparefiles" to forth_autoload.txt.

+ Added automated test file autotest.txt, which runs forthtest.txt in
  both slow and turbo mode and compares the output of both against output
  from a known good run
  
Maybe there should be a varAction-setting opcode type...
That would require that the varAction setting opcodes in the kernel be in
their own list.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 16 2009

I started cleaning up the native type support in ForthInner, making them all
do varOp range checking and use a common code style.

When doing "op" I noticed that the old IP gets stomped, and when you execute
a local or global op var it causes an unwanted return
-> these problems don't happen in turbo mode
DOH! the problem was that it was building a 2 op program, the 2nd op was OP_DONE,
and setting this flag makes the inner interpreter exit - I changed this to
use ForthEngine::ExecuteOneOp, which handles this problem.

+ if you use tick inside a colon definition, that definition shows up in the
  vlist, but if you try to interpret, it causes an undefined symbol error
-> I was misusing tick, it doesn't have precedence, I should have used ['] or lit

OP_DO_CLASS_TYPE is the first and only op in a class defining word, it is
followed by a pointer to the class vocabulary.
doClassTypeOp just calls pClassVocab->DefineInstance() and pops the return stack.
DefineInstance will create an object instance of the class type, which could
mean any of:
o creating a global or local variable/array
o adding an object or object array field to a struct or class definition
Global instances have their vtable and data pointers initialized.
OP_DO_OBJECT is the first and only op in an object instance word.

- "ptrTo" doesn't work with global structs
It looks like ptrTo just changes a var/field to act like a dumb int var

+ structs can't be used as local variables because the ops defined by "struct:"
  don't have precedence, so they are compiled and not interpreted at local var
  definition time...
-> fixed

I need to do more testing, documenting and debugging of existing struct
support before I can advance on class support.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 15 2009

What happens at the start of invocation of a method?
The pushing of this on the rstack can't happen inside the method, since the
code which invokes the method must have already overwritten the this pointer.

Let's assume that the 64-bit object is on TOS already, and the current opcode
is a "method-on-TOS" opcode with method field equal to 5.
Pseudocode for "method-on-TOS":
	rpush TP (2 longs)
	pop TP (2 longs)
	fetch opcode for 5th entry in vtable specified by TP & execute
	

NOTE: doExitMOp and doExitMLOp currently are using a single 32-bit field for
the this pointer - that will have to become 2 fields, right?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 14 2009

+ added strdate, strtime which return current date and time as strings
+ added millitime which returns # milliseconds since forth was started

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 13 2009

+ rewrote systemOp to use stdout/stderr redirection, this should allow it to
  work in ForthGUI
-> it does work, but there is a flash of black when the shell runs...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 12 2009

Chasing the "%c" problem in turbo release mode.  To debug in release mode,
create time wasting user op that takes several seconds to run, pause the
program, chances you will be able to find your way into the inner interpreter
loop pretty quickly.  After that just set breakpoints in the dissassembly
window and look at registers.
After printCharOp returns, the top item on the stack should be the saved EBP
pointer to the forth core, instead that entry has been overwritten by the
characters of the string to be written.  The pushing of EBP was done both to
preserve it and to pass it to the C routine about to be called, in release
mode the compiler feels free to reuse the stack storage of its input params
for other uses, in this case as the character buffer to be printed.  The
solution is to push EBP twice.
This change fixed %c/%bl/%nl as well as vlist in turbo release mode.
Output from forthtest.txt looks ok in all modes now.

Idea for syntax for using TOS as a struct address or object: 
classA.method1
structB.field2

One problem with the current scheme for interfaces, where any class can be
used as an interface, is that it makes it less safe to have classes which
have public fields - the programmer is responsible for keeping track if an
object variable of class blah is:
1) referencing an object which is derived from class blah, in which case it
   is okay to access member fields for class blah
2) referencing an object which is not derived from class blah, but which
   implements the blah interface, in which case it is not okay to access
   any member fields
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 11 2009

Added a "is method" bit to the type code field (pEntry[1]) for struct vocab
symbols.  In the future this will allow the existing bits of the type code
to indicate the return value for the method, so that methods don't have to
terminate a structure accessor string.

Also added a new native type, kBaseTypeObject, which will be a 64-bit field.
When I was putting it in, I found that the global array ops had never
been used, at least in non-turbo mode - their optable entries held the
ops for single variables.

Also, before I made my changes I noticed that running release in turbo mode,
there is an unhandled exception which happens when you do "vlist".
In debug mode, vlist is okay but any immediate op has a "bad opcode"
error.

-> it looks like the assembler version never could have handled immediate
   builtin ops - did the handling of precedence change after the assembler
   version of the nucleus was written?  -> yup!
There was a similar problem with immediate user defined ops, I just made
them use the same table entry as non-immediate user define ops, and I did
the same with "user code" immediate ops, but I haven't tested those yet.

Debug version in turbo mode now runs forthest.txt with no errors and what
looks like valid output.

Release version in turbo mode still breaks on vlist and fails pretty quickly
when loading forthtest.txt
-> %c, %nl, %bl cause a "No Error" failure!  They do display the character
  %nl and %bl just push a char and call %c, %c just build a two char string
  and calls %s, so why does %s work and these other ops fail?
? What does a "No Error" failure mean?
-> the exit status from InnerInterpreterFast is something other than kResultOk
   or kResultDone, but core->error was not set to an error code
The character is always printed correctly.
The problem goes away if I change printCharOp to either use a larger character
buffer or if I remove the SPOP that copies the character from the stack to
the first byte of the buffer.
The problem does not go away if I redirect output to a file.

All of this really emphasizes the need for an automated test suite - changes I
have made in the distant past have broken things, and I have no idea what
change broke what feature.  DOH!

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 10 2009

Decided to tackle a couple of problems using forth, to see what it needs to
solve real problems.  The problems were:

1) merge two equal sized files, which have missing data (zeroes), which come
   from different torrents (rock band .flac file collections)
   mergefiles.txt & mergeall.txt
2) merge guitar pro song collections - there are multiple versions of many songs,
   and the files in different collections sometimes have the same names and
   versions
   gp.txt & narf.txt

Overall, it worked out pretty well.  The main thing that stood out is that I
need to spend some time documenting the functionality that is already implemented.

One missing thing is the ability to iterate over all files in a directory tree,
I got around this by creating a list of files using the cygwin shell and then
turning the list of files into forth files.

Dropped off Xbox-360 today at UPS to fix red-ring-of-death.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 9 2009

+ changed struct/endstruct/enum/endenum to struct:/;struct/enum:/;enum

+ got incomplete class definition time stuff to compile

- there are no examples of "union" - has it ever been tested?
-> test & document its usage

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 7 2009

The ways an interface gets defined:

o the primary interface is defined two ways:
	1) when the "extends" clause is processed, the methods of the defining
	   class are copied
	2) when a method is defined, it either replaces an existing method or is
	   added as new
o secondary interfaces are defined:
	1) when the "extends" clause is processed, the secondary interfaces of
	   the defining class are copied
	2) when the implements clause is processed, if the named interface does
	   not already exist, the new interface is initialized to have the same
	   number of methods as the named interface, and all of the methods are
	   marked as virtual and filled in with a dummy (error) method
	3) when a method is defined inside an implements clause, it replaces the 
	   named method in the interface
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 4 2009

A problem with methods and also struct op fields is that there is no concept of
a return type, so they can't be followed by a dot accessor: objectA.methodZ.fieldQ
doesn't work because we don't know the struct type returned by methodZ, so we
don't know the struct vocab to lookup fieldQ.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 3 2009

One potential gotcha with just extending struct stuff to do classes: the struct
stuff currently does allow structs to be allocated as globals or on the stack.
? Is this really a problem?
We should probably leave structs as is, it would be a pain to have them always
have a dummy vtable on TOS.

Classes should be able to extend a struct, but should a struct be able to
extend a class?  If so, it should just be taking the data members.

When a local class variable is declared, should code be generated to set its vtable?
It would be redundant, except in cases where you only set the dataAddress part of
an object variable.  In those cases the vtable would have to be explicitly
initialized.

Base methods are methods which every class implements, these are methods
in class Object.

-> make a list of class methods and base methods
class.new			...		dataAddress methodsAddress
	this should be an opcode type
struct.sizeof		...		sizeofStructInstance
class.sizeof		...		sizeofClassInstance
object.sizeof		...		sizeofObject
	this should be an opcode type, or be compiled as a constant
class.methods		...		methodsAddress
object.methods		...		methodsAddress
class.numMethods	...		numberOfMethods
object.numMethods	...		numberOfMethods
object.class		...		classDescriptor
	? what should the classDescriptor be?
		1) the struct index
		2) address of something
	what can you do with a class_descriptor? is there a class class?
object.delete
class.parent
object.print
object.queryInterface

? should base methods have a single vtable entry
Note: object.methods could either be:
1) at runtime, fetch the methods field from objects
2) fetch the methods field from the declared class of object (which might be
   a superclass of the actual class of object
We probably want object.methods to fetch the actual object methods field, and
have class.methods be used to fetch the methods field of class
Maybe there are 2 predefined classes at startup, "object" and "class", with
"class" derived from "object".

object methods: delete class methods data sizeof print
class methods: new sizeof methods name parent
Ugh - class.methods doesn't returns the vtable of the class object, it returns
the vtable of objects of its class...
Maybe it should be called "vtable"?  This is bound to cause bugs...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 1 2009

Is there any reason to create a ForthClassVocabulary and manager instead of
just expanding the ForthStruct stuff by adding methods?

Every class defines:
1) an interface
2) a data structure
The interface may be empty, in which case this is an old-fashioned struct.
The data structure may be empty, in which case this is an abstract interface.

How do extends/implements work and interact?
Maybe only the primary interface can extend another class, "implements" means
that this class implements the exact interface of an existing class as a
secondary interface.
When a class extends another class:
o it inherits its implementation
o it inherits any interfaces that it implements, but it may override any or all of the
  implementations of those methods.
When a class implements the interface of another class:
o it does not inherit any implementation from that class
o it does not automatically implement interfaces that the base class implemented

What changes are needed to ForthStructVocabulary?
- add method count
- add abstract method count
- add ?list? of interfaces

Should class methods be assigned normal opcodes, and the vtable contain opcodes,
or should the vtable just hold IP addresses?
Is there a need to have class methods be native opcodes?
o this might help implement classes which are defined in the kernel
o this might be useful when calling a method from another method in the same class
-> make vtables hold opcodes instead of IP addresses

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 31 2009

A class has a primary interface, which is the set of methods which it declares.
A class may have secondary interfaces, which can be gotten by querying.

When a class doesn't have distinct methods of its own, and just implements a
previously defined interface, will that pose a problem?  IE how can the primary
interface for a class be defined using the "implements" keyword ?
-> the endclass word will handle this when the primary interface has 0 methods

When you extend a class which has secondary interfaces, can you override or
extend the secondary interfaces?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 30 2009

What about making all object references be a pair of pointers, a data pointer
and a vtable pointer?  What would this look like?
+ this would allow a simple implementation of multiple interfaces
+ arrays would not need a redundant vtable field per element
o object variables are just a pointer pair
o object reference on TOS is a pointer pair (not a pointer to a pointer pair)
o "this" in thread context is a pointer pair

Maybe all interface definitions which don't have an "extends" statement implicitly
extend the interface "object".

Maybe a class definition could be like:

interface blather1
  talk
  ramble
endinterface

interface blather2
  extends blather1
  spew
endinterface

struct sBlatherer
	...
endstruct

class blahBlah blather2 sBlatherer
 ... method definitions for
-> having "extends" at the class level would make implementation easier
-> "extends" should be available in both class and interface definitions
-> it probably is better to have the class define its data members, instead of
   requiring that its data members be defined in a seperate struct
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 18 2008

More ForthGUI work.

Noticed that the line:   "dir" system
produced no output - the problem is that the directory was sent to standard out
for the console.
? Is there a way to redirect standard out to a function ?
SetStdHandle can be used to redirect standard in/out/error.
? Is there a way to connect a handle to a function
! The easiest thing to do might be to redirect output to a temp file
  inside the "system" op, then after interpreting the string write the output
  to the thread output routine

Also "load" does not do anything.
-> The forth console app calls shell::Run, which has a loop that keeps calling
   GetLine and interpreting it, this is what does the loading.  The forth
   GUI app doesn't call shell::Run or shell::GetLine, it interprets the edit
   buffer when the edit control OnOK handler is triggered.
   Maybe the solution would be for the GUI app to check the input stack depth
   after interpreting a line, and keep doing GetLine/interpret until the input stack reaches zero.

I added the above code to ForthGUI.  forthtest.txt has an error in it, and this
was causing a crash.  I tried to fix it by adding methods to create and delete
all the forth related objects, and these were called when InterpretLine returned
a fatal error result code.  This is currently failing because the engine constructor
saves its this pointer to a global instance pointer, and it asserts if that pointer
is already not null.
At some point I decided to treat the engine as a singleton, and for some
reason I changed the GET_ENGINE macro to use the singleton, but most cases
where it is used the code already has access to the engine, for example forthops
can get the engine from the forth core state.
For now, I am just clearing the engine global instance pointer inside the engine
destructor.  I also had to do this in the ForthTypesManager, which also used
a singleton.
I think the idea was that there should only ever be one engine object.

I get a fatal error when I load sdl.txt, then sdl2.txt, and run "test".

ForthShell::Run
  ForthShell::InterpretLine
    ForthEngine::ParseToken
    ForthEngine::ProcessToken

ForthShell::Run
	calls ForthShell::InterpretLine in a loop until it returns false

ForthShell::InterpretLine
	calls ForthShell::ParseToken and ForthEngine::ProcessToken in a loop until input line is empty
		
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2008

ForthGui program now mostly works
- "bye" does not exit program
- there is no error output
  -> look at ForthShell::ReportError
  -> fixed
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2008

+ added resetting of console output routine, so app can set default output routine
+ tried to make output more simple/unified by combining user data pointer and
  file pointer
  
It might be nice to have a way of pushing/popping an output context.  There
are 3 overall types of output context, here are their data:
1) external function
  - function address
  - function data address
2) file
  - file pointer
3) user op
  - opcode
  - data address

One way to unify these would be to have an output context structure:
	void*	function address
	void*	data address
	long	opcode

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 19 2008

+ added appending to GUI output pane

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 23 2007

Haven't been working on forth since June.  I did add to help.txt.
Going to to try to:
1) add a string->long map feature, use it for help
2) maybe get the Forth GUI working.

The only problem with a map is that it would make a "save state" feature
much more complicated
-> make the map output be offsets from the DP, not absolute pointers
-> come up with a general solution for dynamic data

If I remember correctly, the hangup with doing the GUI was not knowing how to
incrementally get text output to the edit output pane, I only know how to fill
the whole edit pane at creation.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 13 2007

Not much progress over the last month:
- I took a quick look at class support, no amazing revelations occured
- I started creating the GUI for a programmable calculator
The projects I would like to wack on this summer:
- programmable calculator
- synth2k
- graphics sandbox
  ? based on sdl, or win32 ?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 6 2007

I tried adding a lookup map to vocabularies to speedup loading.  Right now
it is ifded-ed out with MAP_LOOKUP.  It seems to be unnecessary, since in
the release version loading the pentium assembler is instantaneous.  The
slowness of loading in the debug version is probably mostly caused by all
the TRACE message output together with the slowness of debug code.

Removed "code" setting of top search vocab to "assembler".  With this gone,
there was no reason to have "assembler" vocab in kernel anymore, so I removed
it and added it to asm_pentium.txt.

Added a serial number to vocab stack searches to eliminate redundant failed
searches of the same vocabulary.  It worked for everything until I tested
sdl2.txt, and it looks like it failed the first time it tried to lookup
an enumerated type.
-> false alarm, sdl2.txt just wasn't adding sdl to the search order
? maybe make vocabulary stack always have at least 2 entries, and the
  bottom entry is always forth?
  
When this works I should rip out the vocabulary search chain since it is
no longer used.
-> No, the search chain is still used, but only by the structs vocabulary.
-> Move the search chain down to the structs vocabulary
  -> I should probably create a chained vocabulary type, since classes will
     probably want to be able to extend another class, like structs
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 5 2007

Added fprintf/sprintf/fscanf/sscanf - they work except that fprintf/sprintf
can't print floating point numbers - there may be some expectation that
fp numbers will be passed in fp registers, but that would seem to be a
pain for variable numbers of arguments.
One hokey thing is that you have to pass the number of variables to be
printed as the last argument.
Example: stdout "%d,%d" 5 7 2 fprintf

Eliminated precedence vocabulary - it didn't work well with the vocabulary
stack.

Starting debug of pentium assembler.

source:
	code andy dx ) ax mov,  4 # dx add, ax dx ) and, next,
generated:
	011842F8  mov         eax,edx 
	011842FA  add         edx,4 
	011842FD  and         edx,eax 
	011842FF  jmp         edi  
should have generated:
	mov	eax, [edx]
	add	edx, 4
	and	[edx], eax
	jmp	edi

-> The ")" op is never being executed - it may be getting eaten by the shell
-> changed all uses of ")" to "]"
	code andy dx ] ax mov,  4 # dx add, ax dx ] and, next,

Assembler is now generating the correct code for "andy", and the op performs
correctly with both fast & slow interpreters.

DLL support was broken, because it relied on the op for a vocab to push
its address on TOS.

I'm changing vocabularies to act like variables, where a prefix op is used
to set the operation the vocabulary will do when invoked.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 4 2007

Working on switching over to the ans forth vocabulary stack.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 3 2007

Updated CVS.

The GForth assembler is ported, it loads but it is untested.
The GForth package doesn't seem to have any examples of its usage in actual
code, but the assembler is almost identical to the assembler in BigForth,
maybe it has some examples.  The file gforth.050/doc/gforth.i9 has a
"386 Assembler" section which spells out the syntax.

One problem area was that GForth is not case sensitive.

Another was that there was a partially implemented relocation scheme which
remapped forth builtin ops which compile stuff or manipulate the DP to a set of
proxy ops which mostly did exactly the same thing - presumably this was
preparation for swapping out the proxy ops for another set which did something
like assembling to an address offset from the intended run address.

One odd thing was that "," was remapped to "c,", and it looked like "," was
being used to compile byte data, not longs.  Perhaps the intent was that in
the source for the assembler, "," was used to compile stuff that needed to
be relocated and "c," was used to compile stuff that didn't.

The next step would be to create a way to make a user-defined op in
assembler.  This could be tricky, especially if we want the fast inner
interpreter to be able to execute these ops without passing them off to
the slow inner assembler.
-> The user defined code ops would be setup to work with the fast interpreter,
   and create a piece of glue code which the slow interpreter uses to execute
   user defined code ops
   -> We could also use this for builtinOps which have no C++ version (with a small mod)
User defined code ops should live in userOps dispatch table, and therefore
share the opValue space of other user defined ops, which will make "forget"
easy to implement for them.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 30 2007

Working on adapting the GForth assembler

: within  ( u1 u2 u3 -- f )
 over - >r - r> u< ;

: t5a 5 -5 within . ;  ok
: t5b -5 5 within . ;  ok

-6 t5a -1  ok
-5 t5a 0  ok
4 t5a 0  ok
5 t5a -1  ok

-6 t5b 0  ok
-5 t5b -1  ok
4 t5b -1  ok
5 t5b 0  ok

With arguments in low,high order result is true for numbers between low & high-1
With arguments in high,low order result is false for numbers between low & high-1

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 28 2007

Initial debug of new DLL support - it works!

Integrated with old CVS system

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 26 2007

Wrote the assembly side of support for DLL via a special opcode type.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 25 2007

+ look at usage of CompileLong versus CompileOpcode
  -> replaced CompileLong with CompileOpcode where appropriate

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 24 2007

+ see if initialization of local strings works, it might not since it looks like this:
  -> 100 string myName
  The "100" compiles into a constant op, which is then removed by "string", but it
  might make string ignore the "->" and not do the initialization...
  -> added mpLastIntoOpcode to engine, to track last "->" compiled in
     current definition
     
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2007

I moved the replacement of kResultDone with kResultOk into ForthEngine::ExecuteOps.
This centralizes the fix for ops which execute an op variable from exiting
the inner interpreter prematurely.
There is one drawback to fixing this bug, it could make the "done" op useless
except as an internal to the outer interpreter.

+ if "->" has been executed before a native global or local variable declaration,
  initialize the new variable from TOS
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2007

The current state of forth output:

ops which produce output invoke CONSOLE_STRING_OUT, passing a core ptr & a char buffer ptr
CONSOLE_STRING_OUT is defined as: pCore->pThread->consoleOut( A, B )
consoleOut is set by the SET_CON_OUT_ROUTINE macro.

outToScreenOp
  sets consoleOut = consoleOutToFile
  sets output file = stdout

outToFileOp
  sets consoleOut = consoleOutToFile
  sets output file = file on TOS

outTOStringOp
  sets consoleOut = consoleOutTOString
  sets output file = NULL
  sets output string = string ptr on TOS

outToOpOp
  sets consoleOut = consoleOutToOp
  sets consoleOutOp = TOS

SET_CON_OUT_FILE( FILE_POINTER )
SET_CON_OUT_ROUTINE( OUTPUT_ROUTINE )
SET_CON_OUT_STRING( A )
SET_CON_OUT_OP( OUTPUT_OP )

consoleOutTOString just appends the string to the end of the buffer, it should
be changed to use the string current length & max length fields.

Got outToOp working, but found an apparent bug in local variables - if I
define a local pointer variable with "ptrTo byte" I get an exception when
it tries to print what is at that address, but it works if I change that
variable to be "int".
-> the local variable defining code was ignoring the "isPointer" flag.

There is still a bug in the output code - if you use a user-defined op,
any output generating op will end the execution of a calling op.
It almost looks like the "done" flag is being set.
-> duhh, yeah, since consoleOutToOp calls ForthEngine::ExecuteOneOp,
   that does a "done" after executing the output op...
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 21 2007

One way to improve DLL support would be to dedicate an opcode to DLL calls.
The address of the DLL entry point would be held in the user defined op
dispatch table.  The op value field would hold 2 things:
1) the dispatch table index
2) the number of arguments the op takes
As mentioned yesterday, Each DLL would have a dedicated vocabulary.

+ fixed a bug in structure support - any forget was wiping out all structs,
  because it was comparing the forgotten op's value field to the structs
  entire opcode

+ added extends, sizeOf and addressOf

+ add "union" to structure definitions

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 20 2007

The SDL_LoadBMP exception happened because SDL_LoadBMP isn't one of the DLLs
exports - the real export is SDL_LoadBMP_RW.  The defining words for DLL
interface words should check for getProcAddress returning NULL.

Maybe we should create a special type of vocabulary for DLLs, where the
vocabulary would know the path to the DLL and its symbols would be the
DLLs entry points - this would allow saving the forth state and restoring
the DLL linkage on coldstart.

Before you call a C routine you push arguments right-to-left, so the first
argument is on top of the stack (lowest memory address).  When we call a
DLL routine, we push arguments left-to-right, so the last argument is on
top of the stack.  This forces us to have to copy between the parameter
stack and the PC stack to reverse the order.  If that wasn't the case we
could do a trick in assembler where we just set the PC stack pointer to the
parameter stack before the DLL call.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 19 2007

Tried to implement SDL dll interface - got an exception in SDL_LoadBMP

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 16 2007

I took the 11 forth.zip files dating back to February 2004 and entered them
into CVS.  Unfortunately, most of them didn't have the assembler inner
interpreter, just one right after I started writing it and the most
recent version.

I added a recursive search option to FindSymbol and FindSymbolByValue.
The recursive search happens if you pass an optional pointer to a pointer
to a vocab.  This is filled in with the vocab the symbol was found in.
This gets around problems caused by the format of entries being different
in different vocabularies - for example, where the name begins depends on
the number of value fields, which can vary between vocabularies.

I also changed the ForthPrecedenceVocabulary::GetNextSearchVocabulary
to return the engine's current search vocab, so you can just do a recursive
search on the precedence vocab instead of searching it and then searching
the search chain.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 15 2007

Found the "dir" exception - it was in string store code.  String store and
append were stomping multiple registers, and cleaning up by jumping to
the main interpreter entry point to reload the registers from FCore.
Unfortunately, the IP had not been saved out to FCore, so after returning
from the string store, the IP was set back to the return point after the
last user defined word executed.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 14 2007

I tried making symbolic constants forgettable by using the pEntry[1] field
to hold the next user defined op number for forgetting, but that just
doesn't work reliably - many symbolic constants can share the same op
number in this scheme, and there is no way to know which constants were
defined before other constants, since the constants could be in multiple
vocabularies.

I'm switching over to having each enum set having a user-defined op and
having forget only work on user-defined ops.  The user-defined op for an
enum set will act as a defining word that is funtionally the same as the
"int" op.

I added "describe" op which disassembles user ops.
Here is an example:

: dir
  blword -> _aa
  "dir" -> _bb
  strcmp( _aa "" )
  if
    // user specified a directory
    strcat( _bb " " )
    strcat( _bb _aa )
  endif
  _bb system drop
;

dir: type UserDefined:9 value 0x1000009 0x0
0118041c  00:00011d    blword
01180420  00:000012    ->
01180424  01:000001    _aa
01180428  0a:000001    "dir"
01180430  00:000012    ->
01180434  01:000002    _bb
01180438  01:000001    _aa
0118043c  0a:000001    ""
01180444  00:0000b6    strcmp
01180448  04:000007    BranchFalse    0x01180468
0118044c  01:000002    _bb
01180450  0a:000001    " "
01180458  00:0000b2    strcat
0118045c  01:000002    _bb
01180460  01:000001    _aa
01180464  00:0000b2    strcat
01180468  01:000002    _bb
0118046c  00:00010c    system
01180470  00:000001    drop
01180474  00:000016    _exit

There is an exception if you execute "dir" in turbo mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 13 2007

Added "enum definition" mode - this is an interpreted mode, where:
o recognized symbols including numbers are executed like normal
o unrecognized symbols become new enumerated value definitions
o stack depth is recorded at start of enum definition, when a new enumerated
  value definition is created, it will pop its value off TOS if TOS is above
  the level at the start of enum definition
o enumeration value is incremented after each definition
o if possible, enumerated value definitions are created as kOpConstant ops,
  if they are outside the possible range a user-defined constant op is
  defined instead

When testing enums, I found an interesting forget bug: if you try to
forget a kOpConstant definition, nothing appears to happen, the constant ops
still show up in vlist, but if you then forget a user op, the constant ops
will also be forgotten, even if they were defined before the user op.
? Is this a problem just for constant ops, or would if affect any ops which
  do not have an entry in the engine dispatch table ?
-> the problem is because forgetting only works for user defined ops (kOpUserDef)
-> we could make symbol constants unforgettable (this wouldn't work for
   constants which were too big for symbol constants, since they are user ops)
-> maybe there should be a dummy symbol for each enum set that is used just
   for forgetting
-> we could use the unused "struct" field, make it type kDTNone, with the
   value field holding the value of the next user op at the time the
   symbolic constant was defined...  the forget would have to be
   modified to take this into account
   
With enums and structs, I can start making an interface for the SDL DLL.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 11 2007

Got structures working, just did a few simple tests, didn't test arrays or
nested structures or anything complex
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 8 2007

Maybe the first attempt at structures should skip all optimizations, just
compile an op for each symbol in a structure access compound op

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 7 2007

Struct defining stuff is in.  Extension to outer interpreter to handle
stuff like a.b.c is not in yet.

I'm not completely sure that the handling of pointers is correct.
I got rid of ForthNativeStringType, merged it back into ForthNativeType.
I'm not convinced that was a good idea, the code is messy, I was trying to
avoid duplicating DefineInstance.  Most of the ugliness is because strings
need to get the maximum string length, and how that is done is different
in interpret mode and compile mode.

Strings and string arrays in structs is probably not a great idea anyway,
since the maximum length field is not set in that case, so it would be easy
to use an uninitialized string and get a buffer overrun.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 31 2007

Added ForthNativeType

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 26, 2007

Added initStringArrayOp

Added code for arrays to defining words

Added ptrTo support to variable/array defining words
Right now, any variable/array defined with ptrTo is the same as an int
variable/array.
When both arrayOf and ptrTo appear in the same declaration the result is
an array of ints.

Increased length of vocabulary value field for user-defined ops to 2 longs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 25, 2007

Added initString op

How should local & global arrays be supported?
Should they use varOps?  Should they be just like variables except always
doing an array indexing operation?

Simplified existing global/local variable code.  Previously there was code
for each combination of varOp and local/global/field vars.  Now local/global/field
use common code for each varOp.  This is slightly less efficient when running
with the c++ inner interpreter but cuts down the amount of code by a factor
of 2, which makes adding array support easier.

Added support code for all types of arrays

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 23, 2007

Removed remaining vars/endvars dead code
Added field action types
The c++ field action code was using the field offset as longs, changed it
to be using bytes

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 22, 2007

Added dummy entries for struct support ops, just to avoid having to add
them an op at a time to c++ and assembler versions
Added sp, s0, rp, r0, fp ops
Added tuck, pick, roll ops
Changed vocabulary stuff to use long* instead of void* for symbol entry pointers

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 20, 2007

Added byte, short, op data types

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 18, 2007

Added compilation of initLocalStringOp for local string vars

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17, 2007

Added byte & short types
Added local string support to turbo mode
Changed string store & append varOps to use max & current length fields
Added output redirection
Added ArrayOffset optype

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 16, 2007

Been working on structure stuff in ForthStructs.txt

A potential problem with using DLLs from forth ops is anything that requires
a callback.  A possible solution would be to define an interfacing DLL that
goes between the windows DLL and forth.

? could we define a generic callback into forth, and accessors on the forth
  side that gave access to the callback arguments on the stack ?
-> wait until we run into a case where we need a callback

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 15, 2007

Added varAction! and varAction@
Added memcpy and memset

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 14, 2007

Added simple help system to forth_autoload.txt
Still need to add op definitions for builtin ops

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 4, 2007

Started integrating forth into ForthGui

It is at the point where I can pass a line of text from an edit control to
the forth shell, and it processes it correctly.

The next step is to change the output system so that it can be sent back to
ForthGui for display in another edit window.

The way it currently works is that forthOps that generate output call a
local procedure named stringOut.

stringOut writes its output to the current output file if one exists,
otherwise it pushes the string address on param stack and invokes an internal
op called ConOutOpInvoke, which pops the string and appends it to the console
output string buffer.

OutTOStringOp sets the current output file to NULL.
OutToScreenOp sets the current output file to stdout.
OutToFileOp sets the current output file to the specified file.

It would be good to change this so that output can be sent to:
1) a specified routine
2) a user op

printCharOp (%c) also uses ConOutOpInvoke.

? does anything currently use output to buffer?

It looks like nothing uses output to buffer, and the console output buffer
is always NULL unless the user executes the "outTOString" op.

I should probably implement the changes to strings which set the current
and maximum length fields for local strings before doing the output ops.
The only ops which 
strcpy			->
strncpy			->
strcat			->+
strncat			->+
strlen    strchr    strrchr    strcmp    stricmp    strstr    strtok

I started adding maxLength/curLenth to strings, it is done for global varibles,
but it is probably broken for local variables...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 26, 2007

Added chdir (couldn't use "system" for this)

Added autoforget - just a version of "forget" that doesn't complain if
  symbol to forget doesn't exist

Added interpret - takes a string and gives it to outer interpreter

Added automatic loading at startup of forth_autoload.txt

Added a bunch of string operators (strncpy, strncat, strrchr, stricmp)

Added a bunch of tests to forthtest.txt

Added sc@ & sw@	- signed byte & word fetch
Added c2l & w2l - byte & word sign extension to long

Added ability to specify double float constants by appending a "d": 1.0d
You can specify single float constants by 1.0f, but this is the default

Fixed bug with "0 word"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 21, 2007

Broke out stuff in this file into seperate files in ForthDocs.

Tried out builds... does with:
	: plusser builds , does @ + ;
	5 plusser p5
	20 p5
Normal mode returns 25, but turbo mode returns 40.
	: minusser builds , does @ + ;
	5 minusser m5
	20 m5
Normal mode returns 15, but turbo mode returns 0.

-> got it working, but I should go through and verify that it is right
  It feels like there is another level of indirection than is correct...
-> there was a bug in @ - it wasn't doing any indirection, so it was a no-op,
   and I had added an extra level of indirection to the asm doDoes code

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 18, 2007

Fixed offset optype.

Changed local var stuff so that local vars can be declared anywhere,
vars...endvars are not needed and should be removed.
One case which was a problem was strings:

: anExample
  55 string anyName
;

In this example, the 55 which was intended to be the length param to "string"
had been compiled.  To deal with this, I added a method to the engine which
checks if the last compiled opcode was a literal constant and returns its
value if so.  The "string" implementation backs the DP over this constant.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 17, 2007

When I looked at converting the string ops into assembler, I started thinking
about string variables, in particular about detecting and avoiding string
buffer overruns.  Three main possibilities came to mind:

1) do like C does, just ignore the problem and always assign bigass buffers
2) add a max length field to string variables
  a) add a current length field to string variables
3) go to a scheme where strings are handled more abstractly
  a) suppose a string was a base pointer and a length
  b) or maybe a pointer, current length and writable length (0 means const string)

One problem with making strings more complex than simple uninitialized
buffers is that it would make implementing local strings more complicated

The max length field isn't important for ops that don't modify a string, so
stuff like strlen, strcmp. strstr and strchar could be implemented as they
are now by just calling the C library routines.

Another problem with making strings something other than a simple set of
bytes is if you want to use them in a disk record structure, you probably
don't want the extra length fields taking up space.

I went off on a tangent about eliminating the need for vars/endvars, allowing
you to declare variables anywhere in a user defined word.
  You would probably want to compile the allocLocals op at the first occurence
  of a local variable.  There are many ways that a user could shoot themself
  in the foot doing this, especially if they were manipulating the return
  stack, but it would be mostly safe.
  One consequence of this is that when a string local var is declared, it would
  have to see if a literal constant was just compiled to determine its size.
  -> maybe we could leave that literal constant op where it was compiled, and
     then compile an opcode immediately after it which would store that constant
	 in the local string vars max length field and zero its current length field.

I tried adding an offset optype, it works fine in interpret mode, but not in compile mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 16, 2007

Got most of the floating point ops defined
int, float & double global & local variables are working

- need to test builds...does

- change string variables to include a current length & max length

? make an optimized case branch, where the opcode includes the case value
  and branch offset?

+ added the ability to add 'd' or 'f' to the end of real literals to control
  generation of single or double precision constants

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 13, 2007

Assembler version of forth is mostly working.

I added a macro to allow assembly-code ops to invoke c-code ops.

I added an op "turbo" that allows switching between using c-code
and asm-code inner interpreters on the fly.

c-code is setting ForthCoreState->state @(002F4948 + 434) = 1
asm-code is checking (002F4948 + 432)
? Say huh ?

I auto-generated core.inc from core.h to define the FortheCoreState structure
for asm-code.  One problem area is enumerated types.  Maybe both the c-code
and asm-code structures should be defined strictly in terms of simple types
with a known storage size.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 4, 2007

Worked on writing assembler versions of optype dispatch routines.

Got to LocalIntAction

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 3, 2007

In preparation for switching over to using assembler for inner interpreter,
I changed the inner interpreter to use a 2-stage dispatch scheme, and broke
out the portion of the state that the assembly code will use into a new
structure, the ForthCoreState.

o There is a single ForthCoreState, which is contained in the ForthEngine.
o The ForthCoreState is associated with a single thread at any time.

I had done a similar state breakout of ForthThreadState from ForthThread a
while back.  The big difference is that ForthCoreState contains the
optype dispatch table and other ForthEngine related stuff.

One other related change which caused some bugs is that before both builtinOps
and user defined ops shared a single dispatch table, now they each have their
own table.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Assembler version

7 general purpose registers available:
eax, ebx, ecx, edx, esi, edi, ebp

Things to keep in registers:
IP
SP
optype dispatch table
? builtinOp dispatch table
inner interpreter PC
thread ptr (RP, FP ...)

this would only leave one general purpose register available for stuff...

EAX	free
EBX	free
ECX	IP
EDX	SP
ESI	builtinOp dispatch table
EDI	inner interp PC
EBP	core ptr

? maybe combine opType and builtinOp tables - have bottom 256 builtinOp codes
  be used for opType dispatchers
-> it would not be "free" to detect situation where you compile an opcode in 0..255, which
   would cause an optype handler routine to be executed as if it were a builtinOp
   -> detecting this would require an extra compare & branch instruction pair, which could
      be included in the debug version of the inner interpreter

Maybe the engine ptr should be in a register, and the engine should have a notion
of a current thread, and the threads state is stored in the engine...


Maybe EBP register should point to a new structure, which has:
  1) current thread state (RP, FP, etc)
  2) ptr to engine
  3) ptr to current thread
  4) opType dispatch table
  5) builtinOp dispatch table
forthOps can reuse ESI or EDI, but if they do they either reload them from the EBP struct
or they branch to an alternate inner interpreter entry point that reloads ESI & EDI
Some of this structure is global engine state, some of it is a copy of the current thread state.

innerInterp
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins		; numBuiltins includes the 256 opType dispatchers
	jge	notBuiltin
	mov	eax,[esi+eax*4]
	jmp	[eax]

innerInterpDebug
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins
	jge	notBuiltin
	cmp	eax,256
	jlt	badOpcode
; we should add checking of SP, RP etc. here
	mov	eax,[esi+eax*4]
	jmp	[eax]

notBuiltin
	mov	ebx,eax			; leave full opcode in ebx
	shr	eax,24			; eax is 8-bit optype
	mov	eax,[esi+eax*4]
	jmp	[eax]

;
; builtinOp code
;

addOp
	mov	eax,[edx]
	add	edx,4
	add	[edx],eax
	jmp	[edi]
	
	
+ I broke out the part of the forth machine state the inner interpreter uses
  from the ForthThread class into a structure.
- Change the dispatch table to combine the optype and builtinOp tables
- Move most of ForthThread::InnerInterpreter into a c function, get that
  working and then use the generated assembly entry and exit code
- Remove the user-defined (high level) ops from the builtin op table
- Put the pointer to the dispatch table into the inner interpreter struct
- Don't have 256 opType dispatchers, the top 128 are for method stuff...
- Change the current opType action routines from ForthEngine methods to
  standalone routines
- Move the inner interpreter and the opType action routines into their
  own source module
  -> need to disentangle the intOp/doIntOp/intActionRoutine stuff first

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 8, 2006

+ added ForthForgettable class, changed ForthVocabulary to be based off it

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 5, 2006

+ added input buffer processing ops word/blword/fillInBuffer...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 2, 2006

+ added support for loading DLLs and accessing procedures in DLLs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 30, 2006

+ fixed a bug with parenthesized expressions - the token length byte wasn't
  being set in a few places, so tokens coming off the shell stack disappeared

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 17, 2006

- definition of an interface
- definition of a structure
- definition of a class
- representation of an object on stack
- method invocation
- local objects
  - automatic constructor/destructor
- global objects
- objects as members of other objects
- constructors
- class static data members
- arrays of objects

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 3, 2006

+ added shell stack
+ converted control structures to use control stack
+ added parenthisized expressions using control stack
+ added better error messages for control structure syntax errors

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 12, 2005

I haven't done much with this project in a while.
Current things to add:

1) Shell stack - holds info used while compiling control structures and
   for error checking
2) Add ability to use parenthesized expressions like this:
   sin( x 2 * )
   When "sin(" is parsed, the "sin" token is pushed on the shell stack,
   and when ")" is parsed, the "sin" token is poped and compiled.
   This needs to support parens which have no associated function.
   This should work in interpret and compile mode.
3) Add default input and output files to a thread, and ops for doing
   binary IO with them - formatted IO will probably still use the
   existing IO operators and stream redirection
4) Add support for loading DLLs and accessing their entry points
5) Add a message passing/event system - a thread can have a chain of
   listeners that are informed when a significant event occurs
6) Add support for basic windows calls


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth Implementation Classes

ForthEngine
  tools for building forthops
  code space management
  DP
  inner interpreter
  outer interpreter (token-level interpretation)
  action routines for forthOpTypes

ForthShell
  parsing
  line-level interpretation
  input stream management

ForthVocabulary
  symbol table management
  vocabulary search

ForthThread
  storage for stacks
  SP, RP, IP

ForthInputStack
  current input stream
  pushing and popping streams
  input buffer management

ForthInputStream
  input fetching

ForthParseInfo
  setup for fast vocabulary matching
  interface between ForthShell and ForthVocabulary

ForthForgettable
  does propagation of "forget" to all vocabularies and memory cleanup after forget


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth opcode types

kOpBuiltIn          // low 24 bits is builtin opcode

kOpUserDef          // low 24 bits is opcode

kOpBranch,          // low 24 bits is signed branch offset
kOpBranchNZ,
kOpBranchZ,
kOpCaseBranch,

kOpConstant,        // low 24 bits is signed symbol value

kOpString,          // low 24 bits is immediate string length in longs

kOpAllocLocals,     // low 24 bits is frame size in longs

kOpLocalInt,        // low 24 bits is frame offset in longs
kOpLocalFloat,
kOpLocalDouble,
kOpLocalString,

kOpMethodWithThis,  // low 24 bits is method number

kOpMemberInt,       // low 24 bits is object offset
kOpMemberFloat,
kOpMemberDouble,
kOpMemberString,

kOpLocalUserDefined,             // user can add more optypes starting with this one
kOpMaxLocalUserDefined = 127,    // maximum user defined optype

kOpUserMethods  = 128
// optypes from 128...255 are used to select class methods    

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-


forth extensions for syn2k:

- operations for stating what synops are in a patch,
  and what order they are to be executed in
- operations for initializing synops - settings parameters
  and input and output buffers
- operations for getting note frequency and velocity
- operations for building up sets of patches which are
  selected by midi program number
= operations for defining envelopes and connecting them
  to synops
? is there a way to define the interface so that when
  a new synop is added to syn2k another op doesn't have
  to be added to forth?


table <TABLENAME>
endtable

<TABLENAME> tableLen    leaves number of entries in table on stack

synPatchSet <SETNAME>

synPatch <PATCHNAME>
endPatch



//       11111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890
<############################# Last Line In File ##############################>
