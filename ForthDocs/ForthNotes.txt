         1         2         3         4         5         6         7
1234567890123456789012345678901234567890123456789012345678901234567890123456789
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
TBDs:

- get multiple interfaces working using wrapper objects

- add a global AsyncLock for things like pushConsoleOut

? deal with ref counting being non-atomic
  ? or just prohibit sharing objects between threads

+ get DLL support working for 64-bit

+ debug pooled memory manager
  + something is freeing many more 16 byte (or less) objects than are allocated thru pooled manager
    - add a check that freed objects are actually in a pooled storage block

+ test summary is always blank

- show method always shows Object __pMethods value
+ IntMap, StringIntMap, StringFloatMap have missing comma after "map" element - are there others like this?

! document existing native ops !
! create examples/tests for all native ops !

+ have verbose describe show names of user defined ops

- optimize object field reference code, there is a lot of code like LocalObject,drop
- also optimize stuff like offset,2@,drop
  -> these drops don't exist anymore, since getting rid of methods/data pair, right?
  
+ add unref op, same op as ->-, it makes object variable:
  o leave object on TOS
  o zeros object variable
  o does nothing if object variable is already null (leaves dnull on TOS)
  o decrements object refcount, but DOES NOT delete object if refcount is 0
  ? what should happen if object already has refcount 0
- add unref method to object containers to do unref for elements
  - add unref methods to iterators
- it looks like OListRemoveHead and OListRemoveTail didn't do a release

- add 'generator' class, it has:
  o lastIP member
  o yield method (saves IP in lastIP and exits)
  o resume method (branches to lastIP if not 0)
  One problem this has is the method can't use local variables, unless I add
  an op to manually dump the stack frame.
  
- redirect current thread console output back to screen before reporting errors
- add native words like %u
- have vlist display the code address of ops
- have error reporting show the param and return stacks, the op that the crash happened in
  -> the param stack might not be up to date, especially in turbo mode
  
? have "woof -> foo( blah )" compile into "woof blah -> foo"

? add properties to classes
  ? are these just getters/setters

- only allow "implements" to be used on abstract interfaces (no data members) - this
  will avoid the problem with accessing data members on secondary interface objects
  which have different data members...

- add support for iterating over files in directories

? add a debug feature where a map is maintained from IP address to file/lineNumber

+ add a string-to-long map based off CMap
  remember that a charPtr-to-long map would just map from the value of the
  charPtr, not the chars in the string, to the long

? add a "parser stack" - this would allow stuff like:
  + using #ifdef to skip sections of code
  - allowing "/*" based comments to span multiple lines
  - allow easily adding user defined parsers for data definition languages

? does support for inline comments using "/* ....*/" break the "*/" operator

- document how parsing is done - put a breakpoint in ProcessToken and go from there

- add a visual debugger that displays execution of words

- switch from having a different exit opcode for ops with and without locals
  to having an epilogue at the end of an op that "exit" will branch to
  
- "forget" doesn't complain about bogus symbols

- add ops for getting current search & definition vocabularies

- a method for saving and restoring state
  -> maybe use memory mapped files for the dictionary, and only allow the restore if
     the file can be mapped at the same address

- testing
  - automated tests using outputToFile & comparison of test result file to known good file
  - test structure support

- dll support
  - a mechanism for supporting callbacks from external code to forth code
    -> the assembler somewhat minimizes the need for this
    
? fix local strings
  ? string vars are currently not using len/maxLen fields
    - change output-to-string to use the string current & max length fields

- windows support
  - first step: create an app where all the windows stuff is in c++
    - support associating windows controls to forth ops
    - a programmable calculator might be a good first step
  - graphics
  ? do this via DLL support
  
- help system

- faster searches

? generalize the undefined symbol handling mechanism which is used to
 define enums
? add a way to extend parsing for user-defined literal constants
 
? forward referencing
  Problem: forward referencing breaks "forget"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
colonOp
 ForthEngine::StartOpDefinition
  ForthVocabulary::AddSymbol
   ForthEngine::AddOp

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Adding an optype checklist:

o add kOpBlah to forthOpType in Forth.h
o add "Blah" to opTypeNames in ForthEngine.h
o (optional) add pretty printing of optype to ForthEngine::DescribeOp
o add OPTYPE_ACTION( BlahAction ) C implementation of optype to ForthInner.cpp
o add BlahAction reference to builtinOptypeAction in ForthInner.cpp
o add blahType x86 assembler implementation of optype to InnerInterp.asm
o add blahType reference to opTypesTable in InnerInterp.asm
o add blahType x86 implementation of optype to InnerInterp.S
o add blahType reference to opTypesTable in InnerInterp.S
o add blahType ARM implementation of optype to InnerInterpARM.S
o add blahType reference to opTypesTable in InnerInterpARM.S

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Gotchas with structure and object support:

1) pointer fields are automatically dereferenced in field selectors, except
   for the final field:    "5 -> woof.pointerToInt" will set the pointerToInt
   field to 5, it will not set the int pointerToInt points at.
2) varAction ops must be the symbol just before a field selector symbol, which
   means that index calculation ops must appear before the varAction op


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Double and long memory and stack layouts:

                              memory                       param stack
0.5d                   00 00 00 00  00 00 e0 3f     00 00 00 00  00 00 e0 3f
0xfedcba9876543210L    10 32 54 76  98 ba dc fe     98 ba dc fe  10 32 54 76  

Double has consistent layout, long is reversed on param stack.


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 3 2022

The Linux assembler inner interpreter version is complete, it runs test.txt
without failures.  atc fails to parse its airport definition files, but that
is happening on master too.
-> it was a 64-bit conversion problem - atc at start seeds random generator
  by grabbing time (a double) and turns it into 32-bits by xor-ing its two
  32-bit parts - fixed

I made the printf/scanf/oStringFormatSub routines not be defined in assembler
for now on Linux, I might leave it that way permanently.
I should also rethink about having assembler versions of things which are
just wrappers on clib functions, like fopen/fread/strcmp/memcpy, they are more
of a pain than they are worth.

+ thread cleanup - get rid of thread/fiber forthops which are redundant
  with Thread/Fiber/System methods
	createThread		kill, System method
        async_philosophers philosophers pizzashop help helpdeck testNotes
    createFiber			kill, Thread method
        philosophers pizzashop helpdeck
    exitThread			kill, add Thread method
        async_philosophers philosophers pizzashop help helpdeck
	yield				move to asm
    stopFiber			kill, thisFiber.stop
    sleepFiber			kill, thisFiber.sleep
        philosophers pizzashop
	exitFiber			kill, thisFiber.exit
        philosophers pizzashop
	getCurrentFiber		rename thisThread
	getCurrentThread	rename thisFiber
        eventqueue threads
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 22 2022

The Linux crash in rctest was caused by IntMapIterator being created with new
and freed using the pooled memory manager.  C++ iterators need to be created
with new, but the forth objects which hold them should be created with the
pooled memory manager.  I am surprised that this bug wasn't caught in the
Windows build.  Linux64 now runs test.txt with no errors.  I still need to
get it working with assembler for builtin ops/
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 19 2022

I've got the non-assembler Linux64 build largely working - it can now run user ops
defined in assembler, which had caused a crash in tree_examples, since it
includes numberio which includes extops.  There is still a crash in rctest in
oIntMapIterNextMethod, the parent map pointer is null.

I fixed all the warnings when building Linux64 debug.  I had hoped there
would be an int-used-for-pointer error somewhere in there, but there wasn't,
except one in OSocket, which isn't what caused the IntMapIter crash.
I should try to get all the warnings out of the Windows builds as well.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 16 2022

I tried to get the Linux64 build working, I got it to compile but it crashes
during startup in InitAsmTables.  I didn't know that Linux/MacOs uses a completely
different calling convention from Windows for Amd64.  Ugh, this will be ugly and
painful to deal with.

I decided to try to just get the non-assembler build working on Linux, and ran
into an even bigger problem - on 64-bit Linux long is 64-bits!  I need to switch
over to types like int32_t to fix this.

I changed ulong to uint32_t, long to int32_t, unsingned int to uint32_t.
I left plain int alone.

Problem cases:
printNumInCurrentBase in ForthOps.cpp - div takes a long
fseek/ftell and fileSeek/fileTell in ForthServer.cpp/h - explicitly take longs

Is the compiler just being pedantic here - long and int32_t should have the same size
on 64-bit Windows.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 11 2022

I finally tracked down the oStringFormatSub/resizeOString crash today.  I was
pushing r13 on the stack at the start of oStringFormatSub, but on exit I was
popping its value into rdi, corrupting rdi which was being used in oStringAppendFormattedMethod
to hold the 'roomLeft' value, causing it to call resizeOString with a bogus value
when it didn't need to resize the string at all.  The same error was in each of
the printf/scanf routines.  It only broke RelAsm because that was the only configuration
which used rdi to hold roomLeft.

I found and fixed multiple bugs in the printf/scanf routines, and added limited
tests for all of them.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 10 2022

I'm not sure if this is good news, but the crash in adv is now consistent across
platforms and configurations! Woohoo!
There were errors in the location script, from when I split make_loc and make_loc_hint,
which may have been a mistake.
Could this be what was causing the old oStringFormatSub/resizeOString bug?
-> nope, it still happens in the standalone test
---
I understand how the evil localRefComboOp bug was happening - the previousType
variable was never initialized before the call to GetPreviousOpcode, if the
peephole was empty (as it often is), GetPreviousOpcode doesn't modify previousType,
so the indeterminate value previousType had could be kOpLocalRef, which together
with the missing parentheses bug allowed the second half of the conditional to
be true, causing ForthOpcodeCompiler::CompileOpcode to replace the old valid
opcode with the localRefCombo opcode.  Small changes to code, especially inside
ForthOpcodeCompiler::CompileOpcode could cause the stack location assigned to
previousType to change, changing how likely it would be to have the kOpLocalRef
typecode.

So the most confusing bug I've had in years came down to missing parentheses
plus an uninitialized variable.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 9 2022

I fixed the uint problem in the 64-bit build, then I tried to get the 32-bit
build running again.  I think I switched MSDEV versions since the last time
I had 32-bit working, so all the preprocessor definitions and many of the paths
were completely wrong - thanks again Microsoft!  After getting that all worked
out, the 32-bit build pretty much just worked, except for RelAsm (of course).
I spent a long time beating on this bug, the symptom was that the last opcode
in definitions sometimes got turned into a localRefOpCombo by the peephole
optimizer.  Anything I did to try and get more info (turing on compilation spew,
adding printfs in the optimizer) would cause the bug to disappear, or appear in
a different spot.  I finally tracked it down to a multi-line if statement in
ForthOpcodeCompiler::CompileOpcode that is meant to decide if it should replace
the previous compiled opcode with a localRefOp combo op, I missed a pair of parentheses:
    && (previousType == kOpMemberRef) || (previousType == kOpLocalRef)
should be:
    && ((previousType == kOpMemberRef) || (previousType == kOpLocalRef))
I still don't understand how this caused this problem, and only in 32-bit RelAsm,
and how adding tiny amounts of code caused the bug to appear/disappear/move.
I am left with the creepy feeling that there is still something evil lurking
in the peephole optimizer.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 6 2022

RelAsm gets an exception in resizeOString when it runs adv.txt, the same thing
happened in June 6 2021, back then I said:
"The crash in adv was because its saveAdventure uses $shellRun to copy the save file."
But this crash seems to be that in oStringAppendFormattedMethod when it calls
asm routine oStringFormatSub that some of its stack variables get stomped on.
Oddly, the problem doesn't happen in DebugAsm which also uses the assembler version
of oStringFormatSub.

? is it worth figuring this out, or just switch to always using C for oStringFormatSub?

Ugh, it looks like when I did the 64-bit assembler version, I didn't really do
the implementation for 32-bit unsigned vars, look at what I did for shorts and
do that for local/member/field plus array cases.  The tests had been catching
this all along, but without the test summary working the error got lost in all
the noise of the test output.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 4 2022

64-bit DLL support was actually working, or at least SDL2 works in 64-bit mode.
I'm not sure how/when I tested it, since there weren't any 64-bit DLLs in Sandbox
before now.

I started debugging why the test.txt error summary wasn't working.  I threw out
using the aux stream, and instead implemented an error stream which defaults to
stderr.
You can temporarily redirect console out to the error stream with err{ and }err.
I changed errors from ForthShell to be sent to the error stream too.  The problem
in test.txt persisted - it was caused by ForthEngine::resetConsoleOut, which was
setting the global aux and error streams to the default console stream whenever
a new fiber was created, which makes no sense, I had picked a bad spot to make
sure the aux stream wasn't always null.

The test.txt summary is now working, there are no errors currently.  There may still
be error messages lurking in some scripts that need to be wrapped in err{...}err.

I also found that runtest was using $load to run scripts, the script isn't actually
run until the  current line has finished processing, so the stack mismatch test
was being run before the script was run.  I changed runtest to use $runFile to
fix this, and  found out that $runFile didn't handle continuation lines at all.

I got rid of all the aux stream stuff, the error stream is a better choice.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 26 2022

There was a crash in biclasstest.txt with the new memory manager when it
tried to delete a DoubleMap.  The cause was that DoubleMap inherited from LongMap,
and both DoubleMap and LongMap had delete methods defined, when the LongMap delete
method it tried to delete the already deleted STL map object.  It turned out that
DoubleMap didn't actually use any inherited methods, so I just changed it to
inherit from Iterable.

Any builtin class which inherits from another builtin class could have the same
problem.  There are 2 possible ways to avoid this:
1) only one class in inheritance chain defines a delete method
2) base class checks if delete has already occured - this might be impossible,
   since base class members aren't related to child class members
So the right way to deal with this is have only one class define delete.

o OArray.cpp, ODeque.cpp, OList.cpp, ONumber.cpp, OSocket.cpp, OSystem.cpp - no child classes
o OMap.cpp - 3 classes use inheritance, no child classes have delete methods
	FloatMap    IntMap
	StringFloatMap  StringIntMap
	StringDoubleMap StringLongMap
o OString.cpp - multiple classes inherit from InStream and OutStream, InStream
  and OutStream don't define delete methods
  o ConsoleInStream inherits from FileInStream, both define delete, but they
    do share a common instance struct definition, ConsoleInStream delete sets
	pInFile to null, FileInStream checks pInFile for null and does nothing
o ForthVocabulary, ForthThread, ForthBuiltinClasses - no child classes

test.txt works fine with no errors now, but after running test.txt showMemory
shows -304 16 byte blocks in use, so something still isn't quite right - maybe
list links are freed to the pool but not allocated from the pool?  Not that I
can see from the source code.
The -304 happens somewhere inside biclasstest.txt.
-> fixed! the pool number calculation was broken

There is a design flaw in the object.show methods - the pMethods pointer for
all objects is the same, this is probably because of how I handled showing
base class methods - I change the pMethods pointer to the methods of a parent
class while climbing the object hierarchy, so pMethods is always the methods
pointer for the Object class, since that is the class that __pMethods is
declared in.
? are there cases where builtin classes are derived from other builtin classes
  and display things twice?
-> yep, FloatMap displays its 'map' member twice. DOH!
? how many classes have this problem?
  FloatMap   StringFloatMap   StringDoubleMap
-> fixed, removed the inheritance and just copied the members

IntMap, StringIntMap, StringFloatMap have a missing comma after the "map" element,
Map and Array don't have this problem.

There are still just a few objects which are being freed to pools which weren't
allocated from the pools, it looks like it might be in global objects - in
test.txt when the HelpDeck global is forgotten, for example.
I'm not sure this hurts anything - the memory for those objects won't be freed
at shutdown when the pooled memory manager is destroyed, but does that really
matter?  I should track it down anyway.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 24 2022

The way to handle object deletion is this:
o ForthEngine::DeleteObject will handle calling each destructor from the deleted
  object to each of its superclasses, and after it reaches the end of the chain
  it will deallocate the object instance memory.
o delete methods are NOT real methods, now they are just forthops
  ? need to change ';m' to handle this
o the default delete method is 'noop'

+ change all builtin class methods
  + remove FREE_OBJECT
  + remove METHOD_RETURN
- change all scripts to never do super.delete
+ trigger an error if super.delete is executed
  -> done for non-asm version in MethodWithSuperAction
  - do for asm version (if necessary)
+ deal with ';m' for delete methods
  -> changed 'm:' to check for 'delete' and not set kEngineFlagIsMethod
  ? will this cause any problems
  it shouldn't, since forthops defined in classes can access member fields
+ delete method should NOT be inherited, it should always go back to noop
  -> I changed ForthClassVocabulary::Extends to do this

ForthFiber::FreeObjects and ForthThread::FreeObjects do FREE_OBJECT, could this
cause a problem if there are other references to the deleted fiber/thread?
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 21 2022

I put in a memory manager which allocates a few very big blocks, then allocates
pieces of it for a specific size.  When an object is freed it is added to a pool
for its specific size.  When testing it I found a bug, NoteDeck has some classes
which are derived from Object, but call super.delete.  When that happens, the
objects get added to the 16-byte free pool, since when you call a super method
the calling object methods pointer gets temporarily swapped out for its parent
class methods pointer.  The class methods pointer is also used to get the object
size for delete, causing the bug.  I need to think about how to fix this.

The motivation for adding this pooled memory manager was to reduce the cost of
allocating/deallocating the interface wrapper objects.

If a class defines its delete method and doesn't do super.delete, it will leak
memory.  If it does super.delete, and the parent class doesn't define a delete
method, the object will be deleted and returned to the correct pool.  As long
as there is a class along the delete chain which uses the default delete method
the object will be returned to the correct pool.

I really need to think about the design of object deletion.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 23 2022

I had been thinking about deleting the whole 'interface' idea, but maybe there
is a good way to implement it.  The basic idea is that when you get an interface
from an object, it returns either itself (if the requested interface is its primary
interface) or it returns a temporary object which always has 3 members:
1) refcount
2) vtable for the interface methods
3) pointer to object itself

o interfaces would not be allowed to declare any data members
o the interface objects could be allocated from a pool for efficiency
o the object getInterface method could either allocate a new interface object
  each time it is called, or it could keep a cached copy and return it to
  multiple interface requesters (ugh, there is a circular dependancy here)
o a class definition could use either 'extends' or 'implements' for its
  primary interface - whichever comes first defines the primary interface
o non-primary interface methods would need to do a double indirection to get
  to data members
  -> have an op at the start of each interface method that changes the this
     pointer to point to the real object, not the interface temp object
	 ? can this cause any problems

The way forth environment variables are planned to work:

FORTH_HOME is expected to point to a directory with:
o a bin64 or bin32 directory which has forth.exe and any required DLLs
o a scripts directory

FORTH_PATH can be defined that specifies the search path for scripts.
If FORTH_PATH isn't defined, the search path is set to FORTH_HOME;FORTH_HOME/scripts
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 11 2022

Immediate TODOs:

- add a FORTH_HOME environment variable
- add forth (Forth.exe) somewhere in the path
- deal with 64-bit vs 32-bit DLLs

not-so-immediate:
- add a 'display format' attribute to arrays/maps, that controls how values and keys are
  displayed by show method:
    default - double and float just have this
    signed/unsigned/char - byte, short, int, long have this plus default(same as signed)
    ? would a string format, which just sticks quotes around value/key, be useful?

- add Set/IntSet/FloatSet/LongSet/DoubleSet/StringSet classes in a script, built
  on top of corresponding map sets
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 5 2022

My next improvement is to add a way to define 'vocabularies' which are invoked
after all the normal symbol processing has failed to recognize a symbol.

Before I do that I need to debug 64-bit DLL support.  I wrote the code but never
actually tested or even ran it.  DOH!
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 22 2022

I revived the ARM branch on the latest version of Raspbian, it hadn't been
kept up to date for a few years, it was missing all the changes from when I
created the 64-bit version.  I still need to test it, I won't be surprised if
there are hi/lo word order problems, or problems in the scripts where the 64-bit
changes broke the 32-bit version.  I also found out that there was an old change
that added NoteDeck::getLinkIter which never got checked in that HelpDeck is
using.

On ARM test.txt fails in tree_examples.txt, it turned out to be when it tried
to execute 'labs', which got a segfault.  Any word defined with the forth
assembler, even a no-op, gets a segfault.  What could cause that?
x a bug in one of the assembler words
  -> check if no-op assembles to just 'bx lr'
  -> it generates 1e ff 2f e1, which is correct
o raspbian preventing execution of 'data'
  ? would this show up as a 'segmentation fault'?
x a bug in the native (optype 0) dispatcher
  -> nope, this is same as builtin words written in assembler, which work
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 18 2022

Thinking of a new name for my version of Forth, this came to mind:
FaaSL - Forth as a Scripting Language - pronounced like fossil
I would need to make it a better scripting language to justify the name.

On the new suffixes, I was thinking instead of x+! and x-! I could use x!+ and x!-,
this would avoid collisions with existing operators like c+!.

addrOf          &
fetch           @
store           !
addTo           !+
subFrom         !-
storeNoRef      !o
oclear          !~      or !0 (but that looks like !o)
unref           !^

Another plus to this is that it would fit with adding pre and post increment
fetches later on.

Another possible syntax addition: using pound sign with chars as a 64-bit literal.
Space ends the literal, no escaped chars are allowed, chars which would cause
collisions with formatted printing ('<' and '>') are not allowed.
? or maybe just disallow things which directly collide with known operators?

Pros:
- changes `abcd` to #abcd
Cons:
- only saves one char
- # requires hitting shift, ` does not


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 6 2022

I started the first phase, changing '->' for objects to mean store-noref and
making '->^' mean store-addref, changing the code was trivial, but when I was
converting the scripts I saw how ugly it would be, and error prone - it is a
lot better to have -> do an addref.
Maybe the best course would be:
o continue to support varaction operators
o use ! suffix for object store-addref
o use !o for object store-noref
o change & from prefix to suffix
o don't add suffixes for oclear and unref
  ? or maybe use '~' for oclear and '^' for unref?

Existing script files could be left as-is for now, and converted over whenever
I feel like it, or just left with the old syntax.

The big downside for this is that the per-fiber varmode member would need to be
kept around.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 5 2022

Long time no code!
I've been working on ditching the old varaction ops and changing the syntax to
have suffixes added to variable/field/members:
	-> a					a!
	->+ a					a+!
	&a						a&
	srcObj -> objectA		srcObj objectA^!
	srcObj ->o objectA		srcObj objectA!
	oclear objectA			objectA^-

One very annoying thing about this change is that all the script files will need
to be updated, and while it can be done automatically for some parts, the way
object store with/without addref is a problem - before a store (->) on an object
variable did an addref and there was a special store (->o) for storing to an
object without doing an addref, in the new system the store suffix (!) on an
object variable does a store without adding a ref and a new store suffix (^!)
is used to store and add a ref.
To make dealing with this easier, I will first add a new varaction op ->^ to the
existing system which does a store with addref, and change -> on objects to do
no addref, get all the scripts to work with this change, then switch over to the
new syntax using action suffixes.
In the first version using the new syntax, I will leave in support for using the
existing varaction ops just to make things easier.  Eventually I will remove the
varaction ops and the per-thread varmode entirely.

This change will allow the removal of the uncompile code for varactions and also
eliminate this problem with native arrays:
	55 -> arrayA(b)		becomes		55 -> b arrayA
So instead of storing 55 into the element specified by b, b is set to 55 and
the arrayA element selected by whatever is on TOS is accessed.
With the new code that would be:
	55 arrayA!(b)		becomes		55 b arrayA!
So the code does what you would expect.

One aspect of the new syntax I have mulled over is wether the action for no
suffix should be fetch or reference, I settled on default being fetch, but you
can also explicitly add @ to specify fetch.

The current syntax with '&' is a prefix, I don't think I used it very much, but
they will need to be fixed by hand in the scripts.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 6 2021

I scrapped the old ForthDLL and ForthDLLMain, I think maybe I defined the DLL as
an MFC extension DLL, so I recreated those projects as a plain vanilla DLL.
I also decided to replace all the StdAfx/stdafx precompiled headers with pch.ccp/h.
Things seemed to be going pretty well, the Debug and Release x64 configurations
worked with a little work.  The DbgAsm and RelAsm ones are giving me major headaches.
DbgAsm compiles for some reason are only getting some of the preprocessor definitions.
-> the Configuration Manager didn't have the correct values for DbgAsm and RelAsm
After fixing that, all x64 configurations build, and Debug, Release and DbgAsm
all run test.txt with no errors, RelAsm gets an exception in resizeOString when
it runs adv.txt.
RelAsm also has a crash if you just do 'ls'.
These problems don't happen in non-DLL ForthMain RelAsm.
_fileNo crashes - it looks like in this code:
	FILE* pFile = (FILE *) SPOP;
	int result = pCore->pFileFuncs->fileNo( pFile );
pFile has its top 32-bits set to -1 as if it was a signed 32-bit int extended
to 64-bits.  I tried the same thing in non-DLL ForthMain and there the FILE*
had its top 32-bits 0, but that might just be luck in where the iobuf was
positioned in memory.

GAH! the bug is in $shellRun in forth_autoload, it uses ints for FILE*.
Fixing that made test.txt work for both DbgAsm and RelAsm.  The crash in adv
was because its saveAdventure uses $shellRun to copy the save file.

There are probably more ints used to store pointers lurking about.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 31 2021

I was going to make a main program to act as the console for ForthDLL, and I
ran test.txt with configuration RelAsm to be sure everything was working, and
I hit an exception in maze.txt - the problem was "fetch generatorOp" which does
a fetch on an op member field, the high 32-bits was garbage.  The problem was
that localOpFetch was doing a 64-bit grab, ops are 32-bits.
When I was fixing it I realized there were a few bugs:
- all the "fetch" ops are broken, they don't clear the varop.  this probably
  only matters for the case where a fetch happens just before an op variable
  is invoked
+ the uint type is broken on 64-bits, it acts like a signed int
  -> tested for global and local simple uints, haven't checked members or arrays yet
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 31 2021

a
a@
a&
a!
a&
a--
a++
a@++
	for non-pointer int/long, returns a then increments a
	for pointer, returns @a then increments a
a++@
a@--
	for non-pointer int/long, returns value then decrements
a--@
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 24 2021

I have been thinking about getting rid of arrow operators (-> ->+ ->- ->o) and
using a syntax like this:
  abc		returns value of abc
  abc!		stores into abc
  abc+!		adds to abc
  abc-!		subtracts from abc
  abc&	returns address of abc
I think this would be very good for arrays, where the syntax currently sucks.
	5 1 -> abc
would become
	5 1 abc!

I'm waffling about if abc should return the value of abc or its address, getting
the value of a variable is much more common than getting its address.
Requiring fetching a value to append '@' would fit better with standard forth, but
it would lead to more typing and more bugs where somebody forgot the '@'.

This change would create some headaches, existing operators which contain ampersand
and exclamation point would clash with standard operators like c! and w!.

I am tempted to add additional meanings for object classes, like append to a list,
or add to a map, but that should come later, if ever.

? how would '->o' be handled - currently it uses ->+ varaction.
? how would 'unref' varaction be handled - currently it uses '->-' varaction.
? how would oclear be handled
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 10 2020

I decided to rename ForthThread to ForthFiber and ForthAsyncThread to ForthThread.
As a first step I renamed ForthAsyncThread to ForthTroll, then ForthThread to ForthFiber,
then ForthTroll to ForthThread.
There may still be a Troll or two lurking about in the source.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 3 2020

I got the midi extension working again after many years of beiung broken.  It
was still setup for the original thread implementation.  I also fixed some bugs
with thread/coreState initialization where some fields weren't initialized on
construction.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 24 2020

I got forthtest.txt to work in client/server.  There were a bunch of cases where
an input stream would get unexpectedly popped, there may still be problems there.

I added stat and fstat ops, untested, also would need custom client/server code.
It might be better to add commands for getting individual file stats, like last
modified and creation times - that would avoid problems with client and server
having different stat structure definitions.

+ client("127.0.0.1") works
- newadv doesn't work remote
- atc doesn't work remote
- console ops (setConsoleCursor/setConsoleColor/clearConsole etc.) don't work remote
- add way to switch between local and remote filesystems
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 23 2020

I'm mostly done the changes to get readdir working remotely.
I put in the changes to support local files in client/server, but it
is completely untested, and can't even be set to local mode.

+ ForthInner.h
  + ForthFileInterface
+ ForthOps
  + readdir op
+ ForthMessages.h
  + kClientMsg OpenDir/ReadDir/CloseDir/RewindDir
  + kServerMsgReadDirResult
+ ForthShell
  + readDir which copies dirent
  + ReadDir method
+ ForthServerShell
  + ReadDir method
  + opendir
  + readdir
  + closedir
  + rewinddir
+ ForthClient
  + opendir
  + readdir
  + closedir
  + rewinddir
- update all scripts which use readdir
  + forth_autoload.txt
  ? atc.txt
    can't load atc.txt

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 21 2020

I have started putting in local file mode for client/server.
I noticed that the server shell file functions openDir/readDir/closeDir/rewindDir
hadn't been implemented and started to add them to the protocol so that they
could work in both local and network file mode.  When I got to readDir I remembered
why I didn't do them earlier - readDir returns a pointer to a memory structure,
the client sending this to the server makes no sense, it can't do anything with
it.  The right way to do it would be to have the client send the contents of
the directory entry (270 or so bytes) to the server.  There remains the problem
of the server needing to buffer that entry somewhere - maybe use ForthEngine::AddTempString
to allocate the buffer entry.
-> I will need to worry about the temp buffer being properly aligned
A better solution is to change the definition of the readdir op to require it
to pass in a pointer to a dirent buffer that takes the result.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 20 2020

I decided to try to make an Electron front for Forth.  I couldn't find any
examples of node.js native modules made that included assembly language, so
I decided maybe I could do this with client-server Forth, just building the
client side as an Electron native module.

Client-server hasn't been tested in a very long time.  The first problem I had
was that the protocol passes FILE pointers back and forth as 4 bytes, I changed
just the protocol fields that were pointers to use cells instead of ints, in
the long run I'll change all the protocol fields to be cells, but for now it
looks like clib file calls only use 32-bits for sizes and offsets.

The next problem I had was that forth_autoload.txt wasn't loaded at startup.
That is because forth_autoload.txt isn't in Sandbox currently, it is only
in system.  The retry-loading of scripts from the system directory is currently
broken in ForthServerShell.  It should be easy to fix once I remember how I
implmented it in the regular shell.
-> fixed, look at openForthFile

My current problem is that script loading is broken, a script stops loading as
soon as you interpret any parenthesized expressions, because at the end of
processing the expression the input stack is popped, ForthServerShell does both
popping the input stack and sends a PopStream protocol message to the client
which doesn't know about the expression input stream, and so pops the script
file input stream.  It would be good if my solution for this works for both
normal scripts and block file scripts.
-> I changed ForthServerShell::PopInputStream to not send the PopStream message
   if the input stream is a generated stream.
I might also want to rethink the whole idea of having file IO done on the client
side, that was originally intended to support working on a minimal device like
the Nintendo DS.  For cases where client and server are on the same machine passing
all file IO through the network is a major performance loss.  Being able to
support both local and network file IO would be best.

Another thing to think about - maybe the size of file protocol members should
be settable, so the client would tell the size of its pointers to the server
at connect time.  This would only be used for network file IO.

End of the day: client-server is partially working, it does crash when I do "dir".
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 2 2020

I've done some more thinking about the problem with non-atomic refcounting and
async threads.  Instead of changing all refcounting to be atomic, maybe a better
way would be to leave refcounting as it is, and instead adopt a philosophy of
limiting how objects are shared between async threads.

*** athread means async thread in this discussion

Pros and cons:
+ less changes needed
+ not paying for atomic refcounting everywhere
+ almost all refcounts are on objects in a single athread
- easier for somebody to screw up if they don't follow the rules and get mysterious bugs

The new rules:
1 Don't share objects between athreads whenever possible
2 When sharing objects between athreads do it in a way where you know that
  refcounts won't be touched simultaneously by multiple athreads
  o when athreadA sticks objectZ in an event queue for athreadB, it clears
    any references it has to objectZ (make this part of atomic eventQueue add)
Things like event queues which communicate between athreads will need to enforce
atomicity, like having a real mutex on adding/removing events.

? maybe have special sharedAddref and sharedRelease ops which are atomic?

Another possible way of doing things is where the main athread creates and owns
all objects shared between athreads, athreads never addref/release on shared
objects.  This can work for simple situations, but it just puts you back in
the situation we had before refcounting, where you have to do manual lifetime
management and it is easy to get dangling references.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 17 2020

Should Bags be allowed to have duplicate tags?  If they are, should the json
for a Bag be an array of 2 element arrays instead of a map?  Is it legal in
json for one element of an array to be a string and the second element be something
else?
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 14 2020

I need to add atomic locks around all reference count changes.  C++ has std::atomic,
x86 assembler has the lock prefix, ARM assembler has ldrex/strex.  I'm not sure
how ldrex/strex are used to do atomic operations.

Even with atomic refcount decrement, could I have 2 (or more) threads that both
think they should invoke the destructor?  If all threads just check the refcount
after an atomic decrement, they could all see a 0 and think they should invoke
the destructor.

Thread has an Array of EventListener
Thread::waitForEvent blocks the thread until an event arrives for any of its EventListeners
each EventListener has an event source and a handlerIP

? what happens to current pstack and rstack when you call waitForEvent, and what are they
  when you come back from waitForEvent?
Other things which suspend a thread leave the thread in the same state after
it resumes as before, this doesn't - what are the rules?
Or should it be the same as other types of suspend, and require you to dispatch
to your event handler?

I was just thinking about a very different problem - thread join.  If a thread
is blocked grabbing a lock, or waiting for an event, what happens when another
thread does a join on it - I guess it is okay, because nothing happens to the
joined thread, it just continues waiting until it wakes up and eventually exits.
The only case where joining a thread would cause it to wake is when the thread
wasn't actually blocked, it was just idle.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 14 2020

I did a bunch of work on the Forth DLL project.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 26 2019

I am adding Event objects now.

Event
o has an event type member
o has an object member, may be null
? anything else

EventListener
o events are sent to this
o has an owner member - thread which owns this listener
? has a queue of events

EventChannel
o events are sent to this
o has an array of EventListener
o this sends the event to each of its listeners
? is this derived from EventListener
? should this really be in the kernel

What methods need locking?
o adding an event to a queue
o adding a listener to a channel (or removing a listener)

How should a Thread be told it has an event?  Maybe a new Thread method which takes
the EventListener as a parameter.
How can I implement something that lets a thread sleep until one of multiple
things happen, like WaitForMultipleObjects?  I guess a semaphore would work
for that, but the thread would need to poll to check what woke it.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 29 2019

The Forth/Forth64 merge is complete.
Platforms: Win32 x64
Configurations: Debug Release DbgAsm RelAsm
There is still more testing to do, but everything looks good.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 28 2019

I am working on merging the Forth and Forth64 solutions.
+ standardize the preprocessor symbols
x renamed Win32 platform to x32
  -> could not persuade visual studio to do this
+ add x64 platform
- ForthLib
  + add x64 platform
  + StdAfx.h
  + add InnerInterpAmd64.asm
  + make inner interp asm targets be ignored in opposite platforms
- ForthMain
  + add x64 platform
  + ForthMain.cpp
  + StdAfx.h
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 26 2019

I switched character constants from using single quote "'" to using accent grave "`"
to avoid collisions with the tick operator.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 15 2019

64-bit DLL loading is working well enough to run the sdlcreen test!
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 13 2019

Amd64 assembler is working well enough to implement all the extended ops I
tested, I didn't do doescode or tailRecurse yet.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 11 2019

I got the amd64 assembler to work, at least enough to define an "add" op.
One problem I had was the gforth amd64 assembler used d= and was expecting to
compare 2 pairs of elements, in my 64-bit version it just compares 2 elements,
I wonder if there are more things like this I will run into.
One thing I should check is "2," - what does it do in gforth, do I need to
swap items?

I fixed the memory corruption crash on exit - I was just setting the optypes
table to the static table in the assembler version, freeing that is a no-no.

The next big thing is DLL support.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 4 2019

I finally found the amd64 crash in helpdeck, exitML was updating the frame pointer
shadow copy in pCore, but it wasn't updating register rfp.  I am surprised at
how many things worked with this bug, maybe there are too many things that are
redundantly setting rfp from the shadow copy.

The remaining problems I know of:
- amd64 assembler isn't done
- tree_examples fails because it uses numberio which uses extops which uses assembler
- there is a memory corruption crash on exit
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 3 2019

I changed how the asm inner interpreter build is controlled, I changed it into
a different build configuration instead of needing to manually change the preprocessor
symbols to have ASM_INNER_INTERPRETER.

I also ran a quick benchmark on the various configurations, which just runs an
empty do loop a billion times:

: moo
  ms@ 
  1000000000 0 do loop
  ms@ swap - %d
;

win32:
Debug 47384
DbgAsm 1718
Release 4839
RelAsm 1605

amd64:
Debug 57673
DbgAsm 1868
Release 2708
RelAsm 1856

win32 is slightly faster than amd64 in general, and for the assembler inner
interpreter versions there is very little difference in speed for release and
debug.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 1 2019

I added an auxiliary output stream, shared by all threads, which by default points
to the default console stream.
I also added a SplitOutStream type that sends output to 2 streams.
The reason for this was to add a summary to the tests, where summary output is
written to the aux stream, and then it appears in the immediate output stream,
and if the console out has been changed to use a splitter, that output will also
appear in the summary output which is dumped after all tests have run.  The intent
is to prevent not seeing error output which appears early in the test run.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 16 2019

I finally got the amd64 inner interpreter coded up.  A fair amount of it is
working, there are several things which aren't done at all:
o most combo ops
o all the printf/scanf variants, and String format methods
o DLL support
It can successfully run forth_autoload, which is not well setup for
bringing up a new version of Forth.
There are a ton of untested things, I can't even run forthtest yet.

The hardest puzzles for the port were:
o "shadow" register storage - almost nothing mentions this, but the 64-bit
  ABI allows called routines to stomp the 32 bytes right below the return
  address.  I found one example in a blog that had it in the listing, and
  it didn't explain what it was.  I couldn't have figured it out from looking
  at disassembly of compiled code because it does a ton of strange stuff on
  entry and exit that the shadow space gets lost in.
o there are some errors that don't show up until the link phase, and they don't
  include any information about where the error occured, just messages like:
	"error: Relocation type ADDR32 is invalid without /LARGEADDRESSAWARE:NO"
  that one was because in a few places I had ported code like:
  	mov	ebx, [localObjectActionTable + ebx*4]
  and the table address in that location causes relocation problems.
  I had to use the dumpbin utility to find ADDR32 relocations in the obj file,
  then figure out their offsets and what symbol was near that offset.

I still need to make a real decision about things like l!/l@/d!/d@/2!/2@,
and I need to commit one way or the other to throw out ANSI double compatability,
or leave it as in with longs word swapped on the stack in the 32-bit version.

There were some changes I made to get running that I might not want to keep in
the 32-bit version, in particular I moved some float/double functions to just
be in C++ because I didn't know how to do them in new xmm register style code.

End of the night - fprintf works!  even with floating point!
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 24 2019

I've been concentrating on work, not a lot of time for Forth.
In 64-bit forth atc seems to work, there was a silly bug where I was using a
long to act as two ints that I fixed.

adv still crashes.  I should move adv into its own vocabulary instead of the
main forth vocabulary.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 24 2019

A lot of test.txt now works in Forth64, directory.txt displays all blank
entries, forthtest.txt shows 4 errors, and ansitest.txt gets a stack underflow
at line 86.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 20 2019

Forth64 is beginning to work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 17 2019

For some reason, when adding a symbol which has an address associated with it,
instead of first having the engine assign an opcode and then calling
ForthVocabulary::AddSymbol when you know the opcode, I have code call AddSymbol
with the address and a flag that says to add the op to the engine.  That is making
things a little ugly in the 64-bit version, I may just undo that.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 15 2019

I changed the exception handling by replacing the 2 handler IPs compiled just
after the _doTry opcode to be relative offsets to their own address.  This
will work for both 32 and 64 bits.

Forth is compiling, and runs autoload, and runs many of the scripts in test.txt,
but fails in atc, newadv and helpdeck.

helpdeck - HelpDeck:setFlags can't find NoteDeck:flagMap member
adv - Game:removeObjectFrom can't find IGame:places member
atc - atcConsoleDisplay:xyAddr can't find iAtcDisplay:text.base

The problem was that I had changed ForthVocabulary::FindSymbol to use ucell for
its serial parameter, but I didn't change FortheStructVocabulary::FindSymbol,
so it wasn't being used, so base classes weren't being searched.
-> use "override" to insure this doesn't happen again

Forth now compiles and passes all test.txt tests in both assembler and
non-assembler versions.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 14 2019

I am cleaning up the long/int/ulong datatypes used in the Forth C++ code, there
is no standard pattern here, as preparation for doing the 64-bit version of Forth.
For the 64-bit version I am planning to use 32 bits for forth opcodes and 64 bits
for everything else.
forthop is always uint32_t.
cell is int32_t or int64_t.
ucell is uint32_t or uint64_t.

Things which will be a problem:
- dictionary pointer
+ shellstack - opcodes and opcode pointers are now different sizes
+ continuation stack - continuation types and pointers are different sizes
- local variable def stack
- ForthEngine::FindUserDefinition
+ initStringArrayOp - what size for string current/max length fields?
+ exception handlers try/except/finally - handlers use full size pointers, not forthop sized offsets
- class vocabulary object pointer at methods[-1] will be 64-bits while methods are 32-bits, so code
  which gets the class object will need to be size aware
  - also change anything which allocated methods tables
+ input streams input state
- ForthVocabulary::AddSymbol - symValue was always 32 bits, now it is sometimes
  32 bits, sometimes 64 bits
- structOp - compiles vocabulary address as a longword right after doStruct op
- look at all CompileLongs to see if they need to be CompileCell
- enums - the defining vocab ptr is now 64-bits, fields below it have changed offset

Probably the right thing to do for any stacks which can have pointers should be
declared with their elements the size of pointers.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 7 2019

ARM is still crashing loading helpdeck.txt, when tracing is on it crashes trying
to get a method name.  I thought I saw that the class vocab pointer which is
supposed to be in pMethods[-1] actually contained pMethods, which suggests that
unsuper is trashing things, but the code looks right.

DOH! methodWithSuper and unsuper were fine, the problem in unref I forgot that
the refcount is now at offset 4, not 0.  Everything works on ARM now.

I couldn't get the ARM pipe based logger to work, I had to just write log output
to a file.

I can't push from the raspi to my windows machine to work.
-> I can't have arm2016 as the current branch on windows when I am pushing to
   that branch from the raspi
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 6 2019

I did the ARM assembler changes, they are almost working, I am having trouble
tracking down what is failing because for some reason the logger isn't working
anymore, even though nothing changed with the ARM logger in a very long time.
The ARM logger and OSX logger are virtually identical.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 5 2019

I brought the linux branch up to date, no changes were needed.

Visual Studio is now useless for assembly language debug.  Single stepping
through instructions will give different results from running up to a breakpoint,
along with the problem of having the wrong stuff in registers.  They must be
simulating execution, and their simulation is broken.

I found and fixed a relatively small number of bugs, now test.txt, atc and
newadv all work in assembler mode.  I got a bogus unrecognized symbol when I
did this:
load atc and run a game and quit
try loading newadv
This error existed in the previous release.
After triggering that error, exiting Forth will cause a crash in CleanupGlobalObjectVariables.
The global that it crashes on is filled with 0xdddddddd, which is freed heap memory.

The problem was a global variable that was being set with "->o", so its refcount
wasn't being bumped, and the global wasn't cleared with "null ->o" when it was
done being used, so it was deleted when its other users were done with it and
the global object was left a dangling pointer.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 4 2019

I found what was wrong with atc, when it tried to process a user command it
was using an op array that had an entry for each input state - idle, planeSelected,
ready, etc - and doOpArrayBop had a bug where it was popping the IP after the
op dispatch, it needs to be before.  After fixing that atc works.

The adventure crash was due to a bug in String:resize and a script bug in
defining adventure states.  Adventure now works.

I started debugging the assembler version.   While debugging local object stores
by single stepping in assembler I kept seeing inconsistent values in registers,
like after a "mov ecx,eax" instructions ecx wasn't changed, and other times
registers would change when stepping through an instruction that shouldn't
change that register.  One time, I saw ebx loaded from a local object
variable that I just printed out and wasn't zero, but after the load ebx was
zero, I checked the memory location and it still wasn't zero, but the code
tested ebx and took a jump zero branch as if ebx really was zero.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 3 2019

I realized why I am getting random crashes when releasing objects, always in
unsuper when it tries to set the pMethods back to its pre-super value.  When
super.delete is done and is the end of the chain, Object.delete, that memory
has been given back to the operating system and may be unmapped from forth's
memory space.  DOH!  How do I fix this for super.delete?  Maybe have Object.delete
set this to null, and check for that in unsuper before overwriting?  That won't
work for more than one level of super.delete either, since the nulled pCore.this
will be overwritten after exiting the delete method, so the next level up of
delete method will see a non-null this pointer.
Maybe if we treat delete/method0 as a special case, compile an rdrop instead
of an unsuper opcode after a methodWithThis(delete).  Delete methods shouldn't
be doing anything with the objects data or methods after super.delete anyway.

After that change, everything in test.txt appears to be working in the non-assembler
version, but I am seeing a lot of unfreed objects on exit again.

I tried running a game of atc and it crashed on start.  The problem is this line:
    ref pBase -> int pDst
The "ref pBase ->" part gets compiled into a localRefOp combo, so when "int pDst"
is compiled, it doesn't see that there was a preceeding "->", so it doesn't
compile the op for pDst, it just adds the local variable.
- check for "->" being eaten by other combo ops

Adventure hangs after printing start instructions.

I should try out atc and adv on the previous stable release.

In the master branch, atc works fine, but adv exits right after printing the
help message.

I couldn't build a release version, there are unresolved externals for some
32-bit float intrinsics which are probably usually inlined.  It is a smaller
list than the last time it happened, but the maximumBogosity hack routine in
ForthOps.cpp isn't fixing it anymore.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 2 2019

Most of test.txt runs without problems, but inconsistently.
- HelpDeck wasn't being deleted, if you fix that there is a crash while deleting
  some IntMap, that might have been there before my changes
- there are still vsnprintf warnings
- depending on the order of tests, everything can run without errors, or sometimes
  a few things in biclasstest will fail, and sometimes ansitest will have a
  few failures (2over and 2drop?) and then crash.

I also changed how MethodWithSuper works - now MethodWithSuper pushes the original
this.pMethods on the rstack before invoking the superclass method, and when
a MethodWithSuper opcode is compiled an _unsuper opcode is compiled immediately
after it.  _unsuper takes the old methods off the rstack and stores it in this.pMethods.
This allows MethodWithSuper to use ExecuteOp instead of FullyExecuteOp.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 30 2019

I ran into a wierd one today.  When running with ASM_INNER_INTERPRETER undefined,
the NATIVE_DEF macro creates dictionary entries with type CCode instead of Native.
The LocalRefOp combo opType uses the Native optype dispatch routine instead of
the CCode dispatch routine in this case.
OpZBranch and OpNZBranch were actually using CCode optype always - did they work?
Maybe they were never tested with asm interpreter turned off.

- There is a seemingly bogus error message when using String:appendFormatted:
   "Invalid parameter detected in function common_vsprintf_s."
- tree_examples is reporting some errors
- philosophers.txt crashes
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 29 2019

Still working on getting the scripts in Sandbox to run without errors.

+ look at anything that uses _allocObject, since it was dealing with 2 items
  on stack and now it has 1 item
+ look at anything which uses setNew (_allocObject covered all these already)
+ look at uses of Class.getVocabulary, it used to return vocab ptr, now it is object
+ ugh, look for all uses of 2dup/2drop/2swap/2over to dup/drop an object
+ another ugh - look for l0= l0<> uses for checking for null objects
+ dnull uses
- major ugh, sometimes I used "or" to test for null objects!
- gah! l= used for object comparison!
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 25 2019

I insanely decided to move the object method pointer to being in the object,
and having an object be represented by a single pointer.
Anything which uses changing the objects method pointer is going to be a
problem, I know of these ones:

+ the object show code used separate method pointer to easily implement recursing
  down the superclass chain, running showInner at each level
  -> I just modify the shown objects this.pMethods, are set it back to its
     original value at the end
- methodWithSuper changes this.methods to the methods for the superclass, if I
  don't do that it won't work more than one derivation level deep.
  I think the way to handle this is to have methodWithSuper push the original
  methods pointer, and compile a fixup opcode right after compiling the
  methodWithSuper opcode, the fixup opcode will pop the old methods pointer and
  stuff it into this.pMethods

I have done a first pass through all the O*.cpp files, I still need to deal with
stuff like methodWithThis/TOS/Super.

I've run into several cases where the code uses the object data pointer as a
pointer to the refcount, I need to watch out for those.

I need to look at the struct code generator, member data accesses are coded to
use drop to get rid of the object method pointer on TOS.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 23 2019

I got the arm2016 and osx branches up to date with master.
On osx I had a problem with nasm - it didn't recognize the lzcnt or tzcnt
instructions, so I had to recode using bsf and bsr.  Also, there is a crash
on osx in misctest.txt at line 311:
inFile.open("_testData.txt" "r") drop
The problem doesn't happen if you run it in xcode, and it doesn't happen if you
turn on tracing.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 21 2019

I think the next big thing to do is to switch from having an object being a
methods/data pointer pair to just an object pointer with the methods pointer
being embedded in the object.  I never really used the idea of interfaces and
it will be a bigger waste when I switch over to 64 bits.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 14 2019

Somewhere around this time I found the bug that was causing massive numbers of
memory leaks when you tried to do anything complex using objects.  The problem
happened when you had an object hierarchy more than one level deep, when you
did the right thing in your classes delete method and called super.delete at
the end, the code for the methodWithSuper opType was correctly rpushing the object
being deleted, and then invoking the delete method from the superclass, but it
wasn't actually changing this.methods, so if that super delete method also did
a super.delete, it would again use the same methods, not its parents, since it
was getting the methods based on this.methods.  Setting this.methods to the
superclass methods in methodWithThis before invoking the delete method fixed
the problem.
- check if this is happening in the ARM version
- test Linux version
- test OSX version
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 8 2019

I forgot that the *Map find method actually takes the value object, and returns
an iterator positioned at it.  I need to think about that.

I changed Map:find to take the key object instead of the value object, I need to
remember to change it back if needed.

Map:findKey takes key object, returns value object
IntMap:findKey takes key integer, returns iterator and found flag

+ replace *Map get methods with grab method which returns OBJECT FOUND_FLAG
+ change *Map find method to take key and return ITER FOUND_FLAG
+ change/rename *Map findKey to findValue method to take value object and return ITER FOUND_FLAG
- look at inconsistencies in *Array, some have tell and seek, others don't

Things that may need to be fixed:
+ biclasstest.txt - does a few StringMap:get calls that will need to change
+ rctest.txt - doesn't do get or find*
+ classtest.txt - doesn't use maps
+ notebook.txt & helpdeck.txt have map uses that will need changing
- t.txt - random tests that probably don't matter
+ forth_autoload.txt - help map
+ hersheyfont.txt - it has an IntMap mGlyphs to map from character codes to glyphs, but it isn't used
+ adv.txt - it has a StringIntMap wordMap, but it isn't used
+ help.txt
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 4 2019

I added checks for a null object to the method invocation code to catch a very
common crash cause.

I also added the notedeck to the system scripts, and a replacement for the help
system which uses it.  It is currently as functional as the existing help system,
but will allow more easily adding more features, such as adding help which isn't
just about a single operator, and adding help for classes and methods.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 3 2019

I had a bug where doing a verbose describe of class ca was showing one less
data member than what caca.show was displaying.  When I looked into it, it
turned out that there were 2 different ca class vocabularies being used.  I think
it must be because I had run the test script multiple times, redefining class ca
each time, but the caca object was being recreated by the test script each time
also, so there is still something odd going on.

One other little difference I noticed was that ShowVocab uses pVocab->GetFirstEntry,
which gets mpStorageBottom, while ForthStructVocabulary::ShowDataInner uses
pVocab->GetNewestEntry, which gets mpNewestSymbol - they are usually the same
value, I think mpNewestSymbol can be null in a few cases.

There is also a bug with the final computed size of class objects which contain
arrays of native strings, it probably isn't longword padding them properly.
The symptom of this is that when showing the class the native string array will
have one less string than it is defined to have.
-> ForthStructVocabulary::AddField adds the per-element padding to the field
   size in the vocab entry, but it doesn't add padding after the final element
   to the instance size, since the next thing after the array might have a
   looser alignment and then part of the padding would be wasted.  The show
   code determines the number of elements by dividing the distance between the
   beginning of the array and the item after the array by the vocab entry
   field size, causing the off by one error.
   ? add the padding for the final element
   ? or change the show code
   -> 
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 1 2019

Happy New Year!
I did a lot of cleanup, particularly of array show methods.
I ran into a bug when trying to report a negative indent level.  Output had
been redirected to a file when the error had occured, and after the error
happened the ok> prompt was appearing, but it didn't seem to execute anything
typed.  Maybe it was executing the commands but output was still redirected,
or at least not going to the console?
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 31 2018

I added the StructArray custom object reader, and I've tested a fair number of
cases, but there are a huge number of combinations of types of containers and
contents that remain untested.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 30 2018

I added custom object readers for the remaining map classes.  The only class
that I know of with a custom show method and no custom reader is StructArray.
Testing of custom object readers is just starting.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 29 2018

I added custom object readers for most of the array classes, lists, strings
and string maps.  I'm pretty sure there are refcount bugs in the object reader.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 28 2018

ForthObjectReader is mostly working.  There is a bug where the output object
array has entries for inner objects, and structs and builtin classes aren't
supported yet.

I've run into a mysterious bug that I think I've seen before recently.  A class
definition will have a symbol missing when shown with vd, but if that symbol is
a data member it will be displayed by show.  When it happened, the vocabulary
symbol count was one too low, which screwed up vd, but show doesn't use that
count, it iterates over vocab entries until it reaches the end pointer.

The other phantom bug like this (maybe) is a case where a method will be missing,
it looks like it hasn't been unsmudged.

And of course the bug goes away when you rearrange the source to try to nail it down.

I've gotten structs inside objects working.

For builtin classes with custom show methods, how can custom readers be added?

- add a way to specify a custom reader for classes which have custom show method
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 26 2018

I started ForthObjectReader yesterday.
I still need to figure out how to add custom readers for builtin classes.
One choice I might regret is to throw an exception whenever a parse error
occurs - this might be a problem for cases where an unknown element could
be ignored without aborting object readback.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 21 2018

I ran into a wierd bug when testing show for objects which have old style
strings and arrays (not object String or Array) members.  If a class has an
old style string, if you do a makeObject in interpret mode, the created object
will have its methods and data pointers swapped.  The problem won't happen
if you compile the same makeObject in an op definition.
-> The problem was __newOp was doing ExecuteOp instead of FullyExecuteOp on
   the class _init op.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 16 2018

I finished the show method rewrite, there are still a number of classes that
have no showInner method that might need one, stuff like Thread, System, Lock,
streams and so on.  I think none of the map iterators have showInner methods.

When I did the Map showInner, I changed it so the shown key object is shown
as an object like "@IntArray_00242288", otherwise the output couldn't be valid
JSON.  I should followup by showing any of the unshown linked objects after
showing the map itself.

I also need to redo the showContext forthops.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 15 2018

I rewrote the show methods to allow things like extending builtin classes to
work, and also to reduce the amount of repeated code, like deciding when a comma
needed to be printed between elements.  A major change was to add a showInner
method, which for a class is responsible for showing just the elements which that
level of class has added.  The show method handles iterating down the class
derivation chain, giving each level of class a chance to show the members which
it added.
Things went pretty well, I finished all the classes in OArray.cpp, OList.cpp and
ONumber.cpp, then I noticed that FloatArray was displaying the array elements first as
floats, then again as ints, and finally as bytes.  The problem is that FloatArray
is derived from IntArray, and IntArray is defined from ByteArray.  I stuck in a
check that stops going down the class derivation chain if the next lower class is
the same size as this class, that "fixed" this particular problem, but is actually
the wrong thing to do - if a user defined class just adds some methods to another
class without adding any new members, invoking show on a class instance will show
nothing, since it has no added members and will immediately exit without showing
the members defined by lower level classes.
FloatArray/IntArray/ByteArray (and a bunch of others like it) is an odd case, since
the derived classes do not add any of their own members, but instead use the
existing 'elements' member in a different way.

ShortArray - ByteArray - gets nothing but __elements
IntArray - ByteArray - gets nothing but __elements
FloatArray - IntArray - gets everything except showInner and sort
LongArray - ByteArray - gets nothing but __elements
DoubleArray - LongArray - gets about half its methods

So the fix at least for the array classes is to remove the derivation links,
and explicitly copying IntArray methods into the FloatArray methods - same for
LongArray/DoubleArray.

I'll have to look for the same situation in the map classes.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 21 2018

I finished fixing continuations.
ForthGui fails at the very end of test.txt, in the ansi test when it does 'accept',
which isn't very surprising since it isn't a console app.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 20 2018

I fixed the problem with AsyncThread::Join hanging in ForthGui, it was what
I thought, the main thread was blocked inside the OK button handler at the
point that it did the wait for the event coming from the joined thread, which
would only get delivered when the main thread had gotten back to the message pump.
Loading the adventure game has an error, because it includes continuation lines,
and those are handled in a part of ForthShell that ForthGui doesn't use.
I think I have to change the continuation handling, remove the part of it that
is in the ForthInput classes and move all of it to ForthShell - have the shell
recognize that an input line has continuations, merge and buffer continuation
lines, and finally process them when a line without a continuation arrives.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 13 2018

Life and work have kept me away for a long while.
An idea I had earlier but gave up on was having the return stack be a set of
ops, and exit would just execute the top rstack opcode.

o there would be 2 kOpUserDef optypes
  1) for user defs defined inside the dictionary memory section
    this would rpush a branch-relative-to-DP optype
  2) for user defs defined outside the dictionary memory section
    this would push the return addres with a set-IP op on top
o there would be a deallocate local frame op
o there would be a pop 'this' op

This would allow easier implementation of go-like defer sections.

The next thing I should really work on is creating objects from the stored
JSON-ish output of Object::show.  The way I implemented the show method, and
the way that a large percentage of builtin classes have very special internal
structure will require that I implement deserializers for most classes.
I'm not sure if these should be methods, I can't see a very general way of
doing that, I might need to have custom deserializers for all builtin classes,
and a general deserializer for user-defined classes.
The custom deserializers will make extending builtin classes impossible, if
it isn't already.

I tried out ForthGUI again, it took a little futzing to get it to build again,
and when I tried test.txt it hung when it got to the asynchronous pizza shop.
It is stuck in a ForthAsyncThread::Join, I think it is probably the main thread,
and there is a deadlock between the main thread message pump and the WaitForSingleObject
event that the child thread uses to signal that it has exited.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 25 2018

I added a ForthDLL project.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 2 2018

I decided to test out DLL/shared library support on non-windows versions.
The Linux version worked fine, sdl tests worked.
The Mac version failed in dlopen because the sdl2 dylib was only for x86_64
architecture, I need the i386 architecture.  I built the 32-bit sdl2 dylib,
but sdlscreen.txt also loads sdl2_ttf and sdl2_image.  sdl2_ttf has the same
missing 32-bit architecture problem.  When I tried to build a 32-bit version
of sdl2_ttf dylib, that fails because it needs freetype, which is 64-bit only.
freetype requires libpng, that might be the end of that chain.
I think the sdl2 image library requires a bunch of other libraries, for all
the different formats it can load.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 30 2018

I added the compilation of localRefOp and memberRefOp combos today.  It is
tested on Windows, OSX and ARM.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 29 2018

The compilation of the varop as part of local var opcodes breaks many things.
In particular local vars with initializers are broken:
o initializer for the first local var will have an allocLocals between -> and local
  var opcode
o initializer for local string variables can have both an allocLocals and a localStringInit
  opcode compiled between the -> and the local var opcode

I put in code that uncompiled the ->, then compiled the allocLocals, then recompiled
the -> and the local var opcode, I should remove that, it isn't worth the complexity
and brittleness.
-> I removed it

End of the day: test.txt works in assembler version and C++ version.
The C++ version already had this in it from the beginning, the only difference
is that it used 4 bits for the varop.
What is strange and worrisome is that the C++ version no longer has the crash on
exit after running test.txt.

There is a compiled OP_OFETCH, which I guess is compiled if you define a pointer
to object field or member, currently it is defined to use the 2@ op, which must
be wrong, since that will swap the two words.  I don't think it has ever been used.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 28 2018

I should scrap the numVaropOp and VaropOp combos - they make no sense.
I also never wrote down what I was going to do with the localRefOp and memberRefOp
combos, maybe they were to be used with the @@++ and @!++ ops.

More useful combo ops would be ones that combined a number, varop and a local
member int variable.  The varop would be either -> or ->+.

Or maybe just take the local and member variable optypes and have all include
a varop override, varop 0 wouldn't override the varop variable, it would be
ignored.
I did this in the windows assembler version, and it didn't break anything.
I did this for all the native types, excluding the array variations.
I still need to do the compilation side to actually activate this, plus I need
to do the C++ version and the ARM assembler version.

I should look at the case of the first local variable including an initializer,
IE "5 -> int foo", which winds up having an allocVars opcode stuck between the ->
and the local variable op and make sure that works.

I shold take a look at 2@@++ - the name implies it is for longs, but the C++
version of the code shows it using doubles.  I should probably create a
set of ones for doubles.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 27 2018

I decided to dust off the peephole compiler and combo ops idea.
There was already ifdefed code to compile the branch/zbranch combo ops, so I
reenabled that, and it caused a crash in test.txt.  I made a simplified test to
check out just branch/zbranch combo ops, but it turns out those don't get
compiled most of the time, because I had forgot that most branch instructions
don't go through CompileOpcode, they are patched into code when the destination
for the branches are known, like else or endif compiles the branch for if.

I could make the conditional compiling ops use CompileOpcode, then the ops
which fill in the branch destinations would need to use a new method which
would look at the already compiled instruction and just change the branch
part of it.  Previously an abort instruction was used as the filler op for
branches which hadn't been patched yet, this would lose that, but that isn't
as important now since there is better code for catching bad syntax earlier.

One problem is that this would put a limit on the length of conditional branches
of only +- 2048 longs, since I would be choosing to use op-zbranch combo before
I knew the destination of the branch.  I could change the op-zbranch opcode to
use 16 bits for the branch and only 8 for the opcode, since the native comparison
opcodes are all less than 256, that would give +- 32K for the branch range which
would be fine.

I should also replace the op-branch combo with a op-nzbranch combo, since nzbranch
is used by andif/orif.

At the end of the day, it is mostly working, at least in the no-asm version.
I ran into problems like these:
1) an opcode that was the last one in an else branch was combined into a
   branch for an immediately following 'until'.
2) an opcode that was compiled be a user def using 'lit' was combined into a
   following 'if'.

I added ForthEngine::ClearPeephole, which must be called at the end of any control
structure definition, and after ops which move the DP.

test.txt runs all the way through with no errors, but there is a heap corruption
exception on exit in the ForthThread destructor for the main forth thread.
It happens when it tries to delete the parameter stack.
The asm inner interpreter version does not have the heap corruption exception.

ForthOpcodeCompiler::mbCompileComboOps can be used to turn combo ops on/off.

The ARM version will need to be updated to add the op-NZBranch optype.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 21 2018

I've started adding a Socket builtin class.
As part of that, I decided to add support for builtin classes having regular
forth ops.

For regular vocabs, the vocab entry is:
  0  opcode
  1  0 for executable ops, for variables it holds the base type, and length
     for strings.

for struct/class vocabs, the vocab entry is:
  0  method index or field offset
  1  entryType - baseType for fields, return type of methods
     has a isMethod bit
  2  element size for array fields

I was planning to represent forth ops in a class with:
  0  opcode
  1  entryType - set to kBaseTypeUserDefinition
  1  unused

I was already doing this in a kludgy way for __newOp.
It works well enough to connect a client and server and send "Hello World!".

I replaced the clunky builtin class member return definitions with shorter
versions that remove the noise of always having kDTIsMethod stuck in there.
  OBJECT_TYPE_TO_CODE(kDTIsMethod, kBCIObject) becomes RETURNS_OBJECT(kBCIObject)
  NATIVE_TYPE_TO_CODE(kDTIsMethod, kBaseTypeInt) becomes RETURNS_NATIVE(kBaseTypeInt)

There are several methods which return a pointer to a native type or an array of
a native type, those should be okay.
There are a few methods which return a pointer to an object (Array base and ref
for examples), these still have to use the old clunky macros.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 17 2018

I fixed the ARM exception handling and super bugs.
The super bug was just that I forgot I needed to push/pop lr since I was calling
a regular C routine which was going to stomp lr.
The exception handling bug was that I forgot to add the exception pointer to the
ARM inner asm definition of the core struct, so when it stuck debug info in 'scratch'
each time through the inner loop, it was actually overwriting the exception pointer.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 16 2018

Bringing ARM version up to speed.

The last time I touched the ARM inner interp was to add the block floating
point ops (Nov. 28). The changes to InnerInterp.asm since then:

1) add strncmp
2) fix a bug in op variable fetch (bug doesn't exist on ARM)
3) fix super
4) add 64-bit shift and rotate ops

ARM doesn't have extended shift ops like x86, and its shift/rotate ops don't
take carry in, making things a pain.  Probably the best way to do things would
be to rotate each word, then use complimentary masks to swap bits around:

	0x0123456789abcdef -> 0x01234567 0x89abcdef
rotate left 4:
	0x23456701 0xabcdef89
apply masks: 0xffffff00 0x000000ff
	0x23456700 0x00000001 0xabcdef00 0x00000089
swap:
	0x23456700 0x00000089 0xabcdef00 0x00000001
combine:
	0x23456789 0xabcdef01

The rotate/shift ops and strncmp are tested work.
There is a crash in forthtest when it does a 'raise'.
I haven't tested super at all.
I fixed bugs in f<> and squished double literals, I don't know how those didn't
get tested before.  This all points to me using very old scripts to test ARM.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 14 2018

I brought the Linux, OSX and ARM versions up to date.
I first got the Linux thread join stuff working, then tried porting it to OSX,
but it turns out that OSX doesn't have unnamed semaphores, so I had to change
the join support to use posix condition variables, and change the AsyncSemaphore
class to use named semaphores.

There are still some problems:
- on Linux, the async dining philosophers takes twice as long as it should
- on OSX, the sync dining philosophers sometimes hangs

I found out that the OSX version of 'ms' was doing nothing - making it actually
sleep made async dining philosophers work again.  Since the only thing new on
OSX that should affect dining philosophers was join, I tried some simple tests
of join, one where the main thread did the join before the child thread was done
and another where the child finished before the parent joined, both worked.

I set the eat/digest waits in async dining philosophers to 0, with that it will
hang about one time out of five, and it looks like actual deadlock - all five
philosophers are in AsyncLock:grab.  I thought the code to make them always grab
forks in a specific order was supposed to avoid deadlock, but maybe I messed
that up.  It is odd that if I do the same thing on Windows I never get a
deadlock.
-> I hadn't done the deadlock avoidance (last philosopher grabs forks in opposite
   order of other philosophers), after fixing that it doesn't hang.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 11 2018

I added 64 bit versions of lshift, rshift and rotate.

I also changed sleepThread and Thread:sleep to set wakeup time to MAX_INT if the
input is MAX_INT, instead of just adding it to the current time.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 2 2018

I got super working as optype methodWithSuper, I have the assembler interp
call C to get the parent class methods pointer.  I may change the implementation
to have the parent methods pointer stored with the methods table so that calling
C won't be necessary.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 1 2018

I got a simple UI app running, it is just a window with an exit button that
closes the app when clicked on.  The app was just enough to test out the
UI framework for getting SDL events to UI elements.

When I was debugging the UI framework, I found out there is a major flaw in
how I implemented 'super' - it works by creating a composite object on TOS
which has the data pointer of the current this object, and the methods pointer
of super class of the this object.  I had an addChild method in UIApplication
which assigned a unique ID to the child then called super.addChild so that
UIGroup would do its thing, including setting the parent of the child.
This led to the childs parent object being UIGroup methods, UIApplication data.
This caused a failure because when the child did sendParent to send a message
up to the top app level, it invoked UIGroup::onEvent, which is really just
UIElement::onEvent, when it should have invoked UIApplication::onEvent.
To work around the problem, I changed the UIApplication method name to just add
instead of addChild.  I need to come up with a better solution to this.

To get the app running I also had to do some work in SDLScreen:
o added basic text drawing
o added settable origin mode, so that UI can specify coords with the origin
  in the top left of the screen, instead of the center of the screen.

I also ran into some crashes in draw code while debugging, it wasn't checking
for drawing beyond the surface bounds.  I added simple checking that has caught
all the crashes so far.  In top level primitive ops like drawLine or drawCircle
the code checks if the entire primitive is onscreen, if so it uses the raw pixel
store op, if not it uses an op that first does an onscreen check before calling
the raw pixel store op.

I found out that you don't have to implement window dragging, SDL does it for
you if you have an SDL_WaitEvent loop that pumps events.

I think I can fix super by replacing the super opcode with a methodWithSuper opType,
which takes the this object and finds its superclass, then invokes the method
it gets from the superclasses methods table.  Getting the superclass when all
you have is the class methods pointer is a little messy to implement in assembler
code:

superMethods = pClassObject->pVocab->ParentClass()->GetInterface(0)->GetMethods();

pClassObject is classMethods[-1]
pVocab is at offset 4 from pClassObject

Getting the parent class and interface 0 would be ugly in assembler, and it would
break easily if the C++ code changed.

I can either call a C method from assembler that gets the parent class methods
table pointer, or I could save the parent class methods table pointer at
classMethods[-2] to make grabbing super methods simple from assembler.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 24 2017

I changed async join back to using event instead of semaphore, and amazingly
it just worked.  I must have fixed something while I was doing the semaphore
version which made both work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 23 2017

After thinking about it, a semaphore is probably not the right thing for join,
since it would need to be incremented once for each thread waiting to join.

I added a Semaphore builtin class, I'm not sure if the semaphore count needs to
be positive or zero to allow a thread to not block on it, it may be different
for Windows and posix.  For windows it looks like the count needs to be positive
to allow a semaphore wait to stop blocking.

I added a new test, pizzashop which tests semaphores and join.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 22 2017

I have the join method debugged for sync threads, async threads still have a
problem in the case where a thread does a join on a thread which has been
started but hasn't actually started its run loop yet - the join lock for the
thread won't be grabbed by its owner until it starts its run loop.

To get join for sync threads to work I had to rework the handling of yield
in the inner interpreter loop wrapper.

In debugging the join/yield changes I found out that threads were being created
with 0 refCount, which was causing join to immediately execute the destructor
of the joining thread when the joined thread exited.

I tried replacing the join critical section with a windows event, but it just
didn't work.  It looked like most of the spawned async threads started their
run loop but then never returned from the inner interpreter, and there was a
crash after the async_philosophers program exited, and it exited before all but
one of the philosophers had eaten.

I changed it to use a semaphore in a way that should have been the same as the
event method, and that just worked.  Very strange.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 20 2017

I added join methods to Thread and AsyncThread.

Join should only be attempted between sync threads which have the same async
thread parent, or between two async threads.

The Thread version just adds the joining thread to a link list of threads which
are waiting for this thread to exit and sets the joining thread run state to blocked.
Thread:join first checks for the thread having already exited, in which case it
just returns immediately without blocking.

The AsyncThread version tries to grab a per-thread lock and immediately releases
the lock as soon as it get it.  Each AsyncThread grabs their join lock when they
are created and release when the thread exits.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 19 2017

There are a bunch of bugs in Map - the key object in set and get was being popped
off the stack as a 64-bit long, which swapped the methods and data fields.
This didn't cause a problem in most places, since the key isn't usually used
as an object.  I noticed when testing Map:show, since there it tries to display
the key as an object.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 18 2017

I added a simple profiler that just counts opcode and optype execution counts.
In implementing it, I found that builtin class methods were being assigned two
opcodes instead of one.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 15 2017

I added 'finally' to exception handling.
I also added a ForthExceptionFrame struct and changed the code to use that instead
of just directly manipulating slots on the rstack.

I added an exception state, it is intended to deal with the case where an
exception is raised inside a finally section.  In that case I throw a regular
error, I could instead have sent the exception to the next surrounding exception
handler, but then it makes it easier to have leaks from not completing finally
blocks, which could go unnoticed.

I should probably have the code which dumps the stacks on error also show
the exception handler chain.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 14 2017

I tried grabbing Forth from github on a different computer and it failed to
build for these reasons:
1) there is a hardcoded path E:\Apps\NASM\nasm
2) the ASM_INNER_INTERPRETER define isn't set for the assembler files
I forgot how I did this - in order to get it to work with nasm. I had to define
a user macro USE_ASM_INTERP, which is defined to be "-DASM_INNER_INTERPRETER".
That variable is defined in
 ForthLib:Properties:Configuration Properties:C/C++:Preprocessor:PreprocessorDefinitions
 select Edit
 select Macros>>
 find $(USE_ASM_INTERP) in the right hand scroll panel
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 13 2017

DOH! The problem with exception handling in forthtest.txt when run in test.txt
was because an earlier test before forthtest.txt loads numberio.txt, which loads
compatability.txt, which defines the ANSI forth throw and catch ops.

I changed catch/throw to except/raise and the test works fine now, plus ANSI
compatability is still possible.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 12 2017

I found and fixed some bugs with exception handling, and added a test for it
to forthtest.txt.  That test runs without errors when you run forthtest.txt
directly, but crashes if you run test.txt, which runs forthtest.txt.
If I run forthtest.txt from t.txt, there is no crash.

Cases to test:
o when no throw happens within try...catch (or below)
o when throw happens directly in try...catch
o when throw happens in something invoked from an op in try...catch
o exit from catch handler when exception is handled (no re-throw)
o exit from catch handler when re-throwing
o throw when there is no surrounding handler (unhandled exception)

Maybe I should add a settable global 'onError' handler op, that can be used
for testing - if defined it could decide if an error should be ignored or
should cause the current thread to reset.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 11 2017

Forth is up to date on osx, with the following problems (not new):

1) when you run it in the debugger in release mode, it doesn't respond to input
  at all, and if you try to stop running it, it kills all xcode windows (not just forth)
2) when you run it in the debugger in debug mode, characters you type are doubled up.

On the plus side, all the tests work, and even trace mode runs without crashing.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 9 2017

I added basic exception handling - try...catch...endtry and throw.
I should change recoverable errors, like bad array indices, into exceptions.
This will allow better testing of classes.
Things that should eventually be added:
o add registering exception numbers with a string message
  o register kernel exceptions like bad array index
o 'finally' clause
o use shell stack for better compile error reporting
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 5 2017

I added some more tests for Int, Long, Float, Double and String, which found
multiple bugs.
o Double and Long public 'value' member didn't work, because the compiler forced
  its alignment to 8-byte, so I had to add a dummy member to fix it
o String had many bugs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 2 2017

I added a new builtin class, Bag, which is an array of key, object pairs.
It is intended for things like small collections of optional parameters, sort
of a lightweight map.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 29 2017

I added float/double block operators to x86 and ARM.
ARM still needs the changes to do tracing within the inner interpreter.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 6 2017

I got the OSX branch working again, fixing stack misalignments in new code mostly.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 2 2017

I created a github account gnosys2u and added forth project to it with:

git remote add origingh https://github.com/gnosys2u/forth.git
git push -u origingh master

Note that I had to create a new remote 'origingh' since origin already existed.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 13 2017

I added a BlockFile builtin object.  I still need to remove block operators
from the kernel.
o kernel needs access to the 'blk' variable
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 19 2017

I merged fast-mode tracing back to the ARM build.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 16 2017

I reworked how trace is done so that now you don't leave fast mode if you go
into trace mode, you stay in the assembler inner interpreter which calls out
to the engine's trace routines.  The trace flags had to be moved into the
thread core, and another inner interpreter entry point was also added to the
thread core, this one is used when executing an op which isn't stored at the IP,
which is used by the execute op and methodWithThis and methodWithTOS optypes.

I also changed the help system to use a StringMap instead of its linked list.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 4 2017

I had to change the global object variable forget/shutdown code to do a release
instead of a delete to avoid a crash if an object was ever referenced by more
than one global variable.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 1 2017

I added automatic deletion of objects referenced by global object variables
when forgetting or shutting down forth.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 22 2017

I've done a bunch of minor fixes spurred on by debugging the O'Dwyer/Knuth
adventure program.  I added the ability to go from an enum value back to its
symbolic name.  This required a little hackery, when an enum defining word is
defined it saves the defining vocabulary, the offset into the vocabulary of the
last enum symbol entry, and the number of defined values in the enum.

I got bitten again several times by the bug where if you define the first local
variable inside a control structure the code will compile but will then crash,
usually because the allocate-variables opcode isn't always executed, but the
exitL opcode is always executed.  I added a check when defining the first local
variable to throw an error if the shell stack shows you aren't at the top level
of a definition.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 11 2017

I changed case statements to allow multiple 'of' or 'ofif' clauses for a single
case body and 'endof'.

There is still a bug in my case implementation.  I had the default case branch
have the case selector on TOS, which the default case branch code was responsible
for consuming.  I read somewhere that the default case branch code is allowed to
look at the case selector on TOS, but that it not consume, that endcase will
compile a 'drop' at the very end of the case statement.
Fixing this would require fixing every case statement in every script.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 10 2017

I added continuations last night, it came together in just a few hours.  The
best thing about it is that it has almost interaction with the other control
flow code - it doesn't use the shell stack at all.

I added elseif today, the way to do it without using parenthesized expressions is:
  else CONDITIONAL_CODE ]if BODY endif
with parenthesis it is done as:
  elseif(CONDITIONAL_CODE) BODY endif
Right now there an ugly kludge in ForthShell::ParseToken that looks for " elseif"
at the end of processed parenthesized expressions, strips the " elseif" off,
prepends " else " and appends " ]if" to make it work.  This will be replaced with
something more general and less kludgy as soon as possible.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 5 2017

I was thinking about adding 'elseif' and 'continue' flow control ops.
The elseif op is basically impossible in standard forth, because
  CONDITIONAL_CODE elseif
needs to do actions both before and after CONDITIONAL_CODE.
It would be possible with parenthesized expressions with some magic, specifically
having the expression processor recognize special starting symbols, like 'elseif'
and adding both before and after symbols to the expression result string, so
  elseif(CONDITIONAL_CODE)
would be turned into:
  else[ CONDITIONAL_CODE ]if

Each elseif collapses the branches of the preceeding if or elseif, but
each leaves behind a pending branch to the final endif.  The endif op
will need to do what it currently does (deal with last if/else) and also
iterate over all the elseifs in the shell stack until it gets to an if,
filling in the branches to the final endif for each one.

I should also look into making andif and orif work with while and until.

Adding 'continue' initially didn't look that complicated until I looked
at all the cases and saw that a lot of them didn't have an obvious value
for the continue branch destination.  do..+loop could have an arbitrary
number of ops before +loop used to compute the loop index increment,
and the same is true for the conditional in begin..until and the proper
continue spot for begin..while..repeat is also unclear - probably somewhere
shortly before the repeat statement.

I think the best way to implement continue is to add 3 ops:
  continue:
    this defines the branch destination for all continues inside a particular loop
  continue
    this causes a branch to spot defined by 'continue:'
  continueIf
    this causes a branch to spot defined by 'continue:' if TOS is true
  continueIfNot
    this causes a branch to spot defined by 'continue:' if TOS is false

Keeping all the continue addresses on the shell stack would make processing
other flow control structures messy, it might be better to have a continue
stack with the IPs of all the continue statements, and whenever a loop ending
statement is processed it would pop all the continue IPs off that stack that
fell within the range of the loop and throw an error if there were continue branches
in the loop and no 'continue:' within the loop.

Loop starting ops would need to stick the previous value of continue address on
the shell stack and zero out the current continue address to mark it as invalid.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 3 2017

I added the ability to have hexadecimal values in string and character literals
by using \xVV.

I added a StructArray builtin class.  You need to invoke its setType method
on each instance before using it so that it knows the size of array elements
and so that show works.  It would be nice if 'StructArray of Foo' would be
enough so that you didn't need to manually set the type, but I can't think of
any straightforward way to make that work.

I decided to do a playthrough of adventure to see if it had any bugs, and found
out pretty quickly that it is very incomplete - when I got to the part where
you release the bird to kill the snake it didn't recognize any way to throw
the bird or the cage.  I guess the guys who did the C++ port didn't get that
far.  I found an annotated C version by Donald Knuth, but it didn't make any
attempt at restructuring the code - it is just Fortran transcribed to C with
goto being used all over the place.  Arthur O'Dwyer took Knuth's version and
added a little more structure to it, but it is still a mess.  O'Dwyer also has
similar C versions for the 440, 550 and 551 point versions of the game which
appear to have very similar code.

I don't know if I should try to add missing stuff to the existing code, or
start over with one of O'Dwyers versions.  Another possibility would be to
port one of the interactive fiction engines like tads or acode to forth,
but that looks like a mammoth undertaking.

I added continuation lines - if a line ends in "\+" the next line will be
appended to it before any of it is interpreted.  I tested in the console and
in files, I haven't tested it for buffer input or server mode.
I also haven't tested edge cases, like where the resulting input line would
be too big for the input streams buffer - that should be very rare, since the
buffers are currently 16K bytes long.
Continuations are only really useful for long literal strings and expressions.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 20 2017

I removed the StringArray builtin class and replaced it with Array of String in
the scripts.  In doing that I had to fix a few bugs in the contained class code.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 19 2017

When I was debugging contained classes, I noticed that there are several cases
of ForthEngine::SetError happening when I run test.txt that don't abort test.txt:

- multiple instances of bad preprocessor directive when #endif is processed during skipping
- line 593 of rbtree.txt - "<)> preceeded by <if>, was expecting <paren>"

I don't think these are new errors.
I think errors that happen outside the inner interpreter don't get reported,
like syntax error or preprocessor errors.
+ make sure all errors are getting reported
+ look at preprocessor directives
  + why is #endif failing?
  - do we need both #if and [if] preprocesser directives?
-> I think this is now fixed

Oddly, if you type a garbage symbol and get an undefined symbol error report,
ForthEngine::SetError is never called.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 18 2017

I have been thinking about allowing container classes to have a 'contained' class
type, so that when you get an object from an array or map you don't have to
cast its type to use it.  

o syntax:
  local var, global var, struct field and member field syntax:
    CONTAINER_TYPE of CONTAINED_TYPE OBJ_NAME
  method return value
    m: BLAH returns CONTAINER_TYPE of CONTAINED_TYPE OBJ_NAME

o implementation:
  1. Vocabulary type descriptor change for object fields
    vocabulary type descriptor for object fields/return values changes from:
      bits 8..31 are classID
    to:
      bits 8..22 are contained classID (8192 possibilities)
	  bits 23..31 are container classID (512 possibilities)
    This does mean that there can be at most 8192 class types, and only the bottom 512
    class types can be 'containers'.

    The number of bits for container type and contained is an arbitrary choice.
    If a very small number of bits is used for the container classID, maybe all
    low classIDs should be reserved for containers.  This would require some way
    of indicating that a new class type is a container type.

    Another possible encoding:
      bit 31 selects container/no container encoding
      if bit 31 is 0, bits 8..30 are the classID
      if bit 31 is 1, bits 8..N are contained classID, bits N+1..31 are container classID
  2. Container methods which returned the contained type must be declared to return
    a special classID 'containedType' instead of Object

Look at all things which reference any of these:
  CODE_TO_STRUCT_INDEX
  kBaseTypeObject
  OBJECT_TYPE_TO_CODE

I will need to keep track of the previous fields type in the struct code generator,
currently it just has the struct vocab for the previous field, so for foo.get.blah,
when processing 'get' it just knows it should lookup the method in Array, and
when it does it finds that Array.get returns Object, and there is no Object.blah method.
The struct code generator will need to keep track of both the container and contained
vocabs now.

The makeObject op will also need to be modified to work with container/contained objects.

"ContainerType of ContainedType" won't work with the simple token stack feature.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 16 2017

I changed builtin class names to not start with 'O'.

I added does-it-compile tests of atc, adv, hersheyfont, file and rbtree to the tests.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 10 2017

I replaced method: ;method fun: ;fun with m: ;m f: ;f instead of using aliases.

I changed the single engine temp string buffer to be a ring buffer containing
multiple strings, and it is now used by blword, $word and literal strings in
interpret mode.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 18 2017

I started working on making the test.txt script include automatic validation
for scripts which don't do result validation.  The overall plan is:

o make it easy to redirect output to a file
o add a flag that scripts can check to skip doing output which is inherently
  variable, like the run times for the dining philosophers
o add a way to hide id/refCount fields in object show methods
o add extParam, which allows files to have variables with default values which can be overridden

I added file stream getSize/getPosition/seek/tell methods, all of which use
64 bits for file offsets/positions.

I added input stream GetString, which reads a line of text into an OString, which
resizes the OString if needed to fit the line of text.

I ran into an intermittent crash that was being caused by the allocLocals op
not being compiled.  It was happening on alternating compiles of a test program.
It stopped happening on its own, sadly.  I guess it is remotely possible that it
was being caused by bugs in the input file stream GetString code, but that seems
unlikely.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 15 2017

I have all the examples, including the dining philosophers, tree and sort
examples to work on the arm build without errors.

I added the ldrd and strd instructions to the arm assembler, it looks like the
ldrsb instruction was actually generating an ldrd, I think I fixed it to
actually generate an ldrsb instruction.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 14 2017

I've been mainly working in the arm2016 branch, the expanded test.txt revealed
a bunch of things that never worked on that branch.  Threads are still broken
there, and I haven't tried the sort or tree examples recently.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 8 2017

I went back and got the OSX assembler inner interpreter working, there are
probably still lurking 16-byte call alignment crashes lurking, but test.txt
runs all the way through without crashes or exceptions.

I got the arm2016 branch mostly working again, it crashes in the new thread
code, but forthtest mostly works, there are definitely failures involving
long variables.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 7 2017

I realized I was spending a lot of time testing forth on different platforms when
I made changes, so I made a global test.txt script and added a bunch of random
small test scripts to a new misctest.txt.

test.txt is a smoke test which runs most of the existing test scripts.

misctest.txt holds 'tests' which don't check their results, they are mainly there
to verify that features compile and don't throw exceptions when run.

I also fixed several bugs which my changes for threading caused - I changed
code which was calling ForthEngine::ExecuteOneMethod to use FullyExecuteMethod
instead.  These included:
o OArray.sort
o SAFE_RELEASE delete
o input and output stream IO methods
This was necessary where C++ code could execute more than a single method inside
a single forthop or method.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 5 2017

I brought the linux forth version up to date.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 3 2017

I spent the last few days trying to get the assembler inner interpreter working
on OSX.  One problem is that OSX requires any calls to system library routines
to be made on 16 byte boundaries.  The extOp routine was misaligned, so all calls
to ops defined in C++ were failing.  After I fixed that I ran into other wierd
problems, for example I get a segfault in this line in CCodeAction:
        opRoutine = (ForthCOp)(pCore->ops[opVal]);
The segfault happens because the value gotten by pCore-ops is wrong, but I have
stepped through the disassembly multiple times, and the pCore value is correct,
but when it fetches the ops field from it at offset 8, it get 0 or 2, even though
the value shown in the debugger for pCore->ops is a valid pointer, and the value
in a memory window shows the same valid value.
I have also run into wierd behavior multiple times when I was trying to align
the stack - subtracting 12 from esp actually caused 52 to be added to it.

I would just assume the debugger was showing me incorrect data, but the segfaults
caused by that incorrect data are real.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 31 2017

My nasm port broke DLL ops, I fixed it.
The OSX problem with ls and pwd was because my tmpnam op was prepending a period
before the random filename, on OSX that filename is an absolute path to /var/tmp/blah,
so adding the dot broke things.  I added that when a new version of the windows
libraries made tmpname return a filename that began with a slash, so without
the prepended dot temp files would be created in the root directory.

I thought floating-point formatting was broken, but I forgot that fprintf/snprintf
always expect doubles, and that they need to be word swapped.

I added preliminary versions of the new lock objects for OSX.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 30 2017

At the end of the day, the OSX port is working, it passes forthtest and biclasstest
and I was able to play adventure without problems.
There are some system related problems, ls & pwd fail, probably anything using $shellRun
will fail.
---
I split the assembly routines NativeAction and CallDLLRoutine out into AsmCore.asm,
they are still needed even when you don't have ASM_INNER_INTERPRETER defined.
I couldn't get MSDEV to build AsmCore.asm, I eventually resorted to editing
ForthLib.vcxproj by hand, cloning the InnerInterp.asm section to build it.
I also found out why you need to change ASM_INNER_INTERPRETER inside InnerInterp.asm
to actually exclude the inner interpreter - there is a /DASM_INNER_INTERPRETER in
the custom build rule, it doesn't get it from the preprocessor settings.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 29 2017

Because there isn't enough pain in my life, I decided to port Forth to OSX.
Most of the initial work was replacing LINUX ifdefs with LINUX or MACOSX.

I thought I would initially just get the no-assembler version to run, but I forgot
that the no-assembler version actually requires a few assembler routines for things
like printing that need to manipulate variable numbers of arguments on the system
stack.  I started with the Linux version InnerInterp.S, but that hadn't been updated
since August 21 2015, so I had to port all the newer changes from InnerInterp.asm.
After that it still didn't work, because the Xcode assembler is 'as', and it
is not compatible with gas.  GAH!  I think this leaves me with these options:

1) write yet another x86 inner interpreter, this one compatable with xcode assembler
2) get xcode to use gas for this file
3) get xcode to use nasm for this file and replace the Linux code
4) give up on porting forth to macosx, or find a way to do it without any assembler

Potentially switching over to a single nasm inner interpreter for all x86 might
be the best option.
If I do decide to continue with a Mac version, there is also the problem that
Mac requires all system calls to have the stack aligned on 16 byte boundaries.

There is also windows-only code that needs to be done for Linux for the new
thread and lock objects.

The git command to clone Forth onto the mac that worked was:
   git clone git://192.168.1.250/Forth
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 28 2017

I added goto and labels.  The engine maintains a table with an entry for each label.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 27 2017

I added 'orif' and 'andif' ops which are inspired by C's || and && operators for
early outing of if-conditionals.  They are only designed to work with 'if', not
'while' or 'until'.  The overall idea is:
o existing if/else/endif evaluate a single conditional then follow either the true flow or the false flow
o andif/orif allow modification of the true/false flows to either early out or add more conditionals
o andif/orif push the branch address and an andif/orif tag on the shellstack
o either 'else' or 'endif' will iterate through all the andif/orif tags until they reach an 'if' (branchz)
o andif and orif tags redefine one of two IPs that else maintains: the trueIP which
initially points to the 'true' body of the if statement, and the falseIP which initially
points to the 'false' body (after the else),
o orif statements redirect the false flow to point to their conditonal code, since an
  orif gives you another chance to succeed after a previous test returned false
o andif statements redirect the true flow to point to their conditional code,
  since an andif adds another conditional you must pass to continue on the true flow

Here is pseudocode for the modified 'else' and 'endif' ops:

elseOp:
  compile abort (will become branch)
  DP -> falseIP
  peekShellStack(1) 1+ -> trueIP
  true -> notDone
  false -> followedByOr
  while(notDone)
    popShellStack -> branchTag
    popShellStack -> branchIP
    if(followedByOr)
      compile branchT:trueIP at branchIP
    else
      compile branchZ:falseBodyIP at branchIP
    switch(branchTag)
      case ifTab:
        false -> notDone
        break
      case andifTag:
        branchIP -> trueIP
        peekShellStack(1) 1+ -> trueIP
        false -> followedByOr
        break
      case orifTag:
        true -> followedByOr
        peekShellStack(1) 1+ -> falseIP
        break;
  pushShellStack(DP)
  pushShellStack(elseTag)

endifOp:
  DP -> falseIP
  if(peekShellStach(0) == elseTag)
    popShellStack
    popShellStack -> branchIP
    compile branch:DP at branchIP
  else
    peekShellStack(1) 1+ -> trueIP
    true -> notDone
    false -> followedByOr
    while(notDone)
      popShellStack -> branchTag
      popShellStack -> branchIP
      if(followedByOr)
        compile branchT:trueIP at branchIP
      else
        compile branchZ:falseBodyIP at branchIP
      switch(branchTag)
        case ifTab:
          false -> notDone
          break
        case andifTag:
          branchIP -> trueIP
          false -> followedByOr
          break
        case orifTag:
          true -> followedByOr
          branchIP -> falseIP
          break;
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 23 2017

I spent the last several days porting a C++ version of Collosal Cave Adventure
to Forth.  I found several bugs in the process.
Some things that made the port harder:

o && and || in conditionals
o continue to break out of loops
o needing to cast to an object type after doing an OArray.get
o multiple return points
o returning string temps
o big chains of elseifs (case using ofif works pretty well)

I also found out that the object show method system isn't extensible at all,
you either accept the default output or get nothing.  I've added a set of ops
for manipulating the show context which allow you to correctly implement custom
show methods.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17 2017

I finished debugging and testing the soft and async threads today.  I'm not
positive there aren't still problems, but they are good enough to checkin.
I don't know if setTrace inside a user defined op will still work for instance.

Something that would probably be good to do would be to move more stuff from
the C++ thread classes into the forth objects, for example the queue of soft
threads blocked on an OLock, or the array of child threads of an async thread.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 14 2017

Yesterday I decided to stop analyzing how to implement soft threads and just
get started with my rough thoughts.  Things went pretty well, but what I am
currently stumbling on is how to execute an opcode which isn't associated with
a particular IP - the current code relies on copying the opcode into the first
element of a 2 element int array which is a declared inside ExecuteOneOp or ExecuteOneMethod
and sticking a 'done' opcode in the second element.  The inner interpreter runs
until it executes 'done' then exits because that op changes the status to done.

Cases to think about:

o executing a user-defined op in outer interpreter
o 'execute' opcode
o executing an object method

I stuck code into the ops which set the IP (mainly exit and its local/method variants)
to set result to kResultDone if the new IP is null.

ForthEngine::TraceOp(pCore) crashes if the IP is null, since it is trying to
fetch the op it is going to display from there.

Lots of things call ForthEngine::ExecuteOneOp, some of them need the op and anything
it calls to completely finish, other things just need that single op to execute.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 1 2017

I added a bunch of methods to the array classes.
I've started thinking about threads again.  My new leaning is to change the
name of ForthThread to ForthAsyncThread, but leave it comparatively unchanged.
I'll add a new ForthThread, which is a soft thread that does cooperative
thread switching.  ForthThreads are created under a ForthAsyncThread, and are
only run when that asyncThread runs its soft thread manager.

The existing main thread will be unmodified, there may be a background async
thread, and there will be a way to create soft threads that will run under the
background thread.

The existing untested OLock class will be changed to OAsyncLock and a soft OLock
class will be added.

The soft thread manager has
  a ready thread list
  a sleeping thread list
  a runThreads method which will
    move any sleeping threads which are past their wakeup time to the ready list
	run the next thread in the ready thread list

When code in a soft thread tries to get a soft lock and fails, it is removed from the ready thread list
and is put on a queue waiting for that lock.
? what if an async thread fails to get a soft lock

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 31 2017

For some reason, the ;m alias wasn't working - its dictionary entry had 0xFEEEFEEE
in it.  I rearranged forth_autoload.txt so that dump was defined before alias so
that I could dump the dictionary info while creating the alias, but that made
the problem disappear.  Ugh.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 24 2016

I added an invalid parameter handler to the window forth main program to catch
a crash which wasn't caught by the existing exception handling code, which happens
if you pass an invalid format parameter to strftime.  The docs for the function
say its behavior is undefined for invalid formats, but crashing still seems a
bit extreme.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 13 2016

DOH! When I created the system object, I forgot that 'system' was already used
as the way to execute a string in the system shell.  I changed it to be _shellRun
for the builtin op and $shellRun for the op which does output redirection, and
it works now in command line forth and in ForthGUI.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 3 2016

I fixed a bunch of bugs in object show methods, showing an object that had
circular references would loop indefinitely.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 25 2016

ForthGUI didn't work immediately, I needed to make some changes because of the
stream object changes, it mostly works now, problems:

+ forth_autoload.txt isn't autoloaded
- ops like pwd and ls don't show any output
+ input box doesn't automatically get focus

I also had to turn off safe structured exception handlers (/SAFESEH:NO) in the
link of ForthGUI.  I could have added an SEH handler to the assembly file:

.safeseh SEH_handler

SEH_handler   proc
;handler
ret

SEH_handler   endp

I replaced structIndex with typeIndex everywhere.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 24 2016

The hang in biclasstest was in SpewMethodName, which was trying to find the name
of method 0 (delete), it had a bug where if it found a vocab entry with the correct value,
but the value wasn't a method, it never advanced the vocab search point, so it found
__refCount, which has a value of 0 but is an int member, and kept looping and rejecting
that entry in an infinite loop.  I don't see how this could be a new bug, maybe I just
haven't run biclasstest with inner interpreter spew turned on since the bug was added,
which is probably when I made the reference count have a member variable.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 23 2016

I created the simplest case of a class and a derived class and the derived class
delete method doing super.delete, and it doesn't have the hang.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 19 2016

I made a lot of progress with the OSystem and OVocabulary changes.  There is
still a hang in biclasstest when it tries to delete a class object whose destructor
calls parent.delete, I'm not sure if this is a problem with using super, or if
it is because 'delete' is method 0.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 16 2016

Things that need to be fixed with removing vocabulary varop stuff:
- definitions (ref)
- _doStructType
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 14 2016

Crunch has been keeping me busy.

I foolishly started two relatively big things at almost the same time:
1) Add an OSystem class and system singleton, which will be used to access things
   like streams, threads, files and vocabularies.  The idea was to remove a bunch
   of native ops with methods on native classes.
2) I decided to replace the manual management of the structure info definitions in
   the type manager with a standard vector.

While debugging the type manager change I ran into some bugs which are because
some things were previously working by accident, and only because the struct index
for Object was defined to be 0.  I need to go through all the method and field
definitions in the builtin classes and see if there are more with this bug.

Should unref really have a return type, since it isn't intended to be chained
to a following method - you could do obj.unref.show but it isn't really the
intended use of unref, and would allow you to invoke a method on an object which
has a zero refcount.

Currently forth compiles, but gets an exception 300 lines into autoload.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 24 2016

I broke up ForthBuiltinClasses.cpp/h into OArray/OList/OMap/ONumber/OStream/OString
files.  It took a couple hours to sort out all the issues but wasn't too bad.

Later I moved the OVocabulary and OThread classes into ForthVocabulary and ForthThread.

While testing, I ran into a problem in the snake game.  There was a problem where
some combinations of parenthesized expressions and character constants were failing:

dup('a' )    would work
dup( 'a')    would fail

This was caused by a combination of a bugfix for the tick operator being used
inside parenthesized expressions and a check in character constants which invalidated
character constants if the character after the ending single quote wasn't one of
tab/space/EOL.  Oh the joy of ad-hoc parsers!

The ARM version is working pretty well, I am working on getting the atc game to
run on it.  I had to make version of the console cursor/color ops that use VT100
escape sequences, the getCursorPosition one doesn't quite work.  Also I can't
load a game map because the code that reads game files is broken (problem with dirent?).
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 18 2016

I got the x86 version of OString:printf working.  It currently uses _snprintf,
I tried to get it working with vsnprintf to be more consistent with the ARM
version, but I couldn't get it to work.
I modified the x86 version of OString:printf to automatically resize the string
if the formatted output won't fit the current buffer.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 17 2016

I got the ARM assembler versions of snprintf/sscanf/fprintf/fscanf debugged.
I had a few simple mistakes, but when debugging I found out that somehow the
C++ code had been compiled as 16-bit thumb instead of 32-bit arm, the docs
say that arm is the default for gcc, and I couldn't find anywhere I was overriding that.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 14 2016

I looked at the ARM assembly code generated for the snprintf op, I found that
it does special stuff for floating point arguments, stuffing things in FP
registers, which won't work for dynamic argument lists, so I think the only
way to fix that is to only use the vsnprintf procedure.
I should do the same thing for the fprintf, fscanf, sscanf ops.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 13 2016

I've got the pipe logger programs working on both windows and ARM.
The ARM forth assembler version is mostly working, it passes forthtest, but it
crashes when I try printf/sprintf/snprintf.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 10 2016

I added a named pipe logger program which just waits for a client to connect
to pipe ForthLogPipe and then prints everything logged to it.

Next I need to implement a similar thing for Linux and use it to debug the
ARM assembler version of Forth which currently is crashing during startup.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 22 2016

I decided to go back to getting the no-asm-inner-interpreter build working first
on rpi3.  My first step was to test it on x86, and forthtest.txt worked, but
ansitest.txt failed.
-> the c++ version of 'sp' was wrong for the fetch case - it first made room
   on the stack, which decremented sp, then stored sp in the top element of
   the stack.  This meant that on an empty stack doing "sp s0 -" would not
   return 0, so the test code failed.

I am still having the build problem where changing the custom build rule for InnerInterp.asm
to not define ASM_INNER_INTERP doesn't work - I finally tracked it down to the
fact that when I change that in the Debug configuration, the change actually
shows up in the Debug Midi configuration.  I have no idea why this happens or
how to fix it.  For now I just have to change the ForthLib defines to handle C++
and edit InnerInterp.asm and change the ifdef symbol to something other than ASM_INNER_INTERP.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 21 2016

I got my Raspberry Pi 3 working as a git client and updated the Makefile.
I got it compiling, it needs some work in the inner interpreter assembler code.
- I think datan2Bop was broken, it was only taking one argument
- a few ops are undefined, look for a TODO near the end of the file
- I haven't looked at the changes to the optypes table - there are definitely some changes there
- I haven't checked for other core changes
  ? were there output system changes that affected assembly code
- forth crashes on startup
- I think ->o may be defined to be the wrong opcode (->, should be ->+) in the windows version
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 21 2016

I changed the builtin classes to have the first character capitalized, so class
and object became Class and Object, oArray and oList became OArray and OList, etc.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 28 2015

I've been trying to get SDL_TTF to work, but I keep getting a bogus surface
back from the TTF_RenderText_XXX calls.  I've done the equivalent set of SDL
calls in a CPP program successfully.

DOH! I updated sdl_ttf.txt to match version 2, but it was still loading the
version 1 sdl_ttf DLL.  Updating it to use version 2 fixed the problems.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 6 2015

I have a mostly working implementtation of struct initialization ops.

Currently if you define structs or objects which have string fields, the strings maxLength field is uninitialized.
This change would add an automatically generated init op whenever any struct is defined which
contains strings or contains structs which themself have an init op.
A struct which contains an object member which contains strings would not need to have an init op,
when the object is created it will take care of initing its strings.
A secondary motivation for this change is to allow user explicit creation of the equivalent of C++ constructors.

Assuming we create an _init op for each struct which has either string fields or struct fields which
have their own _init op, the code generated would look something like this:

struct: structA
  int iX
  20 string sY
;struct

: _init  // for structA
  // TOS: ptr to struct
  offsetOf sY + 20 initString
;

struct: structB
  int iR
  30 string sQ
  structA m
  4 arrayOf 6 string sT
  3 arrayOf structA w
;struct

: _init  // for structB
  dup offsetOf sQ + 30 initString
  dup offsetOf m + structA:_init
  dup offsetOf sT + 4 6 initStringArray
  offsetOf w + 3 ' structA:_init initStructArray
;

struct: structC extends structA
  structB sb
  10 string baba
;struct

: _init  // for structC
  dup structA:_init		// init parent
  dup offsetOf sb + structB:_init
  offsetOf baba + 10 initString
;
  
4 types of initializations:
o string
o string array
o struct
o struct array

4 situations:
o global instance
o local instance
o struct field
o object member

+ create init op at struct/class definition time
  + save info about fields which need initialization when fields are defined
  + define new init op and compile its code when struct definition is complete
  + deal with structure extension
    + if new struct's parent struct has an init op, and this struct adds no new initable fields, use parents init op
  + if new struct has initable fields, compile parents init op at start
+ compile init op for local instances
  + string (already done)
  + string array (already done)
  + struct
  + struct array
+ execute init op for global instances
  + string (already done)
  + string array (already done?)
  + struct
  + struct array
+ invoke init op at end of 'new'

? add an op for getting the typeIndex given a struct/class name
  - have definition of "_init" in struct or class definitions

For some reason, when you start a struct definition, it doesn't change the
definitions vocab to be the new struct vocab, which is unlike class definitions,
which do change the definitions vocab.  Why did I do that?

There was a bug (I think) in memberStringArrayType and fieldStringArrayType, they
were jumping to opEntry instead of stringEntry, I can't see how that could be
right, so I changed it.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 21 2015

I have added the member variable definitions to builtin classes so that they
can be extended.  There is a remaining problem with that, if the extension
classes need there own newOp there is no builtin mechanism to do both.

Currently there are several situations where you can define an old-style string
that leaves the string max-length field uninitialized.

Working cases:
o global string
o local string
Failing cases:
o string inside a global struct
o string inside a local struct
o string members

There is a initMemberString <MEMBER_NAME> immediate op for initializing string
members, but it would be much nicer for this to happen automatically.

o a struct needs to initialize its string members
o a struct needs to initialize its struct members recursively
o an object needs to initialize its string members
o an object needs to initialize its struct members
o add an array of string field offsets to struct vocabularies

A struct can have an initializer opcode which initializes its string and struct fields.

Struct initializer:
o takes a pointer to base of struct, returns nothing
o is a sequence of ops which init either a string or a struct field

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 15 2015

I added an OVocabulary builtin class to allow searching and manipulating vocabularies.
I also updated the SDL libraries to support SDL2.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 30 2015

I changed defining words like colon, struct:, class: etc. to use the shell
stack to make tracking down nesting errors easier.
I added ops for manipulating the shell stack so it can be used in creating
other defining words.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 21 2015

I added atc to git.

I had forgotten that classes which define their own delete method need to do a
super.delete to actually free the memory malloced to the object.

There is still a mysterious 100 byte allocation leftover after running atc.

Also, I moved the atc files from the sandbox level into an atc subdirectory,
after running the game and exiting the atc subdir contains a _blocks.blk file.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 16 2015

I've been working on the atc game a bit.
There is definitely a problem with forgetting global variables, at least global
object variables.  For a simple test case, try running forthtest two times in a
row.  forthtest requires testbase.txt, which uses some OString global vars, the
second time you run it assigning to the global OStrings throws an exception.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 7 2015

I need to look at OString, define how size/length/resize relate, using
resize( length 1- ) should trim off last character of string, it doesn't.
Decide if the size of an OString should always be a multiple of 4.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 26 2015

There were 2 problems in InnerInterp.S I found while debugging forthtest on the
Linux build:

+ exitLBop was still using ECX instead of ESI
+ localStringStore - the source string pointer in ECX was getting clobbered when I
  called strlen

The second problem could happen in other places - I used to be using ESI for a
bunch of things, ESI is preserved by clib routines, now I am using ECX in its
place, ECX is not preserved by clib.

The Linux build can now run forthtest and biclasstest without any errors.

I don't know if it is a new problem, but if you run forthtest 2 times in a row,
it will crash the second time when it tries to do a testBuff.set, it could be
a problem with global object variables.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 25 2015

I'm working on getting tracing to work in fast and slow modes, mostly to make
debugging the Linux version easier.  The Linux version passes forthtest in
no-assembler mode, but crashes in assembler mode.  Knowing what opcode was
being executed at the time of crash would be a big help.  I am thinking of
repurposing the trace engine state to not just be used when switching the
fast/slow or trace flags, and having it be used for single stepping.

The problem I'm trying to figure out is how to run in slow mode with tracing
on and with the assembler inner interpreter used for native ops.  Right now
that would mean InnerInterpreter would dispatch to NativeAction
Call stack when executing a regular forth op from outer interpreter:
	ForthDebug.exe!InnerInterpreter(ForthCoreState * pCore) Line 2375	C++
 	ForthDebug.exe!ForthEngine::ExecuteOps(long * pOps) Line 1914	C++
 	ForthDebug.exe!ForthEngine::ExecuteOneOp(long opCode) Line 1884	C++
 	ForthDebug.exe!ForthVocabulary::ProcessEntry(long * pEntry) Line 634	C++
 	ForthDebug.exe!ForthEngine::ProcessToken(ForthParseInfo * pInfo) Line 2546	C++
 	ForthDebug.exe!ForthShell::InterpretLine(const char * pSrcLine) Line 597	C++
---
Who calls InnerInterpreter/ForthEngine::ExecuteOneOp/ForthEngine::ExecuteOps:

	InnerInterpreter
ForthEngine::ExecuteOps( long *)
ForthEngine::ExecuteOps( ForthCoreState* )
ForthThread::RunLoop
ForthThread::Run

	InnerInterpreterFast
ForthEngine::ExecuteOps( long *)
ForthEngine::ExecuteOps( ForthCoreState* )
ForthThread::RunLoop
ForthThread::Run

	ForthEngine::ExecuteOps( long *)
ForthEngine::ExecuteOneOp
ForthEngine::ExecuteOneMethod
ForthTypesManager::ProcessSymbol

	ForthEngine::ExecuteOneOp
objectReleaseMethod
classCreateMethod
doOpExecute - op var default action
_doOpVarop
MethodWithThisAction
MethodWithTOSAction
XXXComboAction
doMethodOp ?
newOp
doNewOp
executeBop
ForthStructVocabulary::DefineInstance ? initialization of ptr-to-struct instance?
ForthNativeType::DefineInstance ? init global single variable?
ForthNativeType::DefineInstance ? init global single string variable?
ForthVocabulary::ProcessEntry
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 19 2015

I spent the weekend getting Ubuntu running on virtual box to bring the Linux
version up to date.  It is almost compiling, the inner interpreter has a fair
number of changes since the last working x86 linux build, most notably the
change of the IP register from ECX to ESI.  There is something wierd going on
with core_gas.inc, changes to it aren't reflected when you rebuild.
Could it somehow be getting the file from a different path when it includes it?
I did copy the old forth eclipse projects from the machine I originally did the
linux version on, maybe it has some screwy include paths setup.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 12 2015

There is also a problem with forget - I forgot a colon definition, and a global
object variable which was defined before the colon definition was deleted.

The bug I spent over a day chasing was because when a release caused an object
to be deleted, the delete was done by calling ForthEngine::ExecuteOneMethod,
which had the side effect of setting the core state to 'done', which caused the
inner interpreter to exit out of display.init right after the delete, and so it
didn't execute the exitML code, so the next thing executed was trying to execute
bad data out of the stack frame of the previous ExecuteOneOp invocation.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 11 2015

End of the night: there is still a crash when running atc in no-asm mode.  The
problem is triggered by the deleting of an iterator inside a method under certain
circumstances - a method calls a method on another class of object, that method
creates, uses and deletes the iterator - the crash doesn't happen if you don't
delete the iterator and just let it leak.

I added printing out of class:method when tracing MethodWithTOS or MethodWithThis opcodes.
---
I think the 'test[' bug is because ForthShell::InterpretLine loops until a
line empty flag is set, and it ignores the input stream stack depth, so when
an expression stream inside a buffer stream reaches the end it is returning
without executing the stuff at the end of the buffer stream after the parenthesized
expression.  That doesn't explain how the stuff at the end of the buffer eventually
does get executed.

forthtest has been broken since I replaced the shell stack based parenthesis
implementation with expression streams.

The changes to fix forthtest:
+ $evaluate needed to be change to use ForthShell::RunOneStream not ProcessLine
+ the loop in ForthShell::RunOneStream needed to be changed from exiting as soon
  as the input stream changed to exiting as soon as the input stream became the
  original input stream
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 10 2015

End of a long unfinished debugging session:
forthtest is failing because 'test[' is failing sometimes when it contains a
parenthesized expression, it may have something to do with quoted characters or
strings, maybe not.  'test[' evaluates a string, so it is using a buffer input
stream, and the paren expression means it is using an expression stream inside the
buffer stream.  After the expression stream has been interpreted, it is popped and
the buffer stream should be effectively empty, so it should also immediately pop,
but it looks like instead of checking the read and write offsets on the main stream
buffer it is looking at the pointers to its input data buffer, and the src pointer
mpDataBuffer is still pointing to the start of the input data buffer.  The input data
buffer is there to permit buffer streams to contain multiple lines, I think that was
to support interpreting stuff coming from ForthGUI.  I don't know why my recent
changes triggered this bug yet.
? but ForthBufferInputStream::GetLine advances mpDataBuffer as it copies data from
  the input buffer to the main buffer
  -> GetLine isn't called for the first line in the buffer - I tried adding a
     GetLine at the end of the buffers stream constructor, it didn't fix the problem
! the '0=' after the strcmp is being executed after 'test[' has already failed
---
I tried fixing the potential 64-bit object dfetch problem, and after doing it
nothing worked.  I backed out those changes

forthtest.txt fails for both fast and slow modes:
- "string(200) svar" fails because after the end paren is parsed, "200 string"
  is interpreted, but when it tries to get the next token, it gets an empty
  string instead of "svar" because the current input stream is the string stream
  created by the parenthesized expression code, which is empty at that point.
ansitest.txt works for slow mode
atc.txt works for fast and slow mods

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 9 2015

I did more work on object show methods, and I ran into a problem with the double
map and array show methods, because I implemented them as just the long array
and show with different show methods, forgetting that longs get word reversed
when they are moved between memory and the stack to be ansi forth compliant,
but that I hadn't done that with the stack representation of doubles.  If I
want to keep the double array and map I need to give them their own implementation
methods which don't do the word reversal.

A more important problem is that I noticed that there is only one 64-bit fetch op '2@',
there is no 64-bit fetch which doesn't do word reversal, I need to check if any
code compiled for accessing object locals or fields are using 2@.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 5 2015

I added ForthShowContext, which is a lazy created member of ForthThread, to
hold info needed while showing objects, including the show depth, set of
objects which have already been shown, and in the future show options like
pretty print, hide __id, and showing objects in nested form.

I was debugging it using atc, and I ran into a weird crash where suddenly the
IP became NULL.  I finally tracked it down to another case of me putting the
first local object declaration inside an if statement, so the local frame was
not being allocated when the if true branch wasn't taken, and the exitL at
the end was corrupting the state.  This type of error is too easy to cause,
and is too hard to track down when it happens.

One good thing that came out of this is that I added a way for setTrace to
work inside of definitions - previously a setTrace inside a definition usually
had no effect during execution until the program had returned to the outer
interpreter since you were typically staying inside the assembler inner
interpreter.  I changed setTrace to set the status to kResultTrace, which
causes the asm interp to exit, and I changed the engine ExecuteOps to loop
while the status is kResultTrace.  I need to take another look at it, I think
it still doesn't do what I want, I am probably going from the asm interp right
back into it since fast mode hasn't changed.

Another problem is that the trace output is screwed up, particularly when doing
MethodWithTOS calls.  It might be that the stack trace is being shown after the
method returns, and the method has done its own stack trace on the same line?
Also look at output from delete methods which are triggered by final releases.

? is there a way to display the class/method for MethodWithTos
? is there symbolic output for CCode types
  ? is there symbolic output for BuiltinClass methods
? is MethodWithThis ever used
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 28 2015

The recursive show method works great, except when you have cyclic references,
which actually happens a lot.  To try to fix this, I am adding an optional per
thread object (ForthShowContext) which keeps track of objects which have already
been shown.

The current __type field will be replaced with __objid which will combine the
class name and an index which increments for each object shown, so if you did
show on an array the first __objid would be 'OArray_0'.  While recursively showing,
if an object is reached which has already been shown, it is displayed as an @ char
folled by the objid, so the above array would appear as @OArray_0.

When you do object.show, it either goes to objectShowMethod for user defined
types, or it goes to a builtin-class method like OArrayShowMethod.

  ObjectShowMethod
    ForthStructVocabulary::ShowData on the root object
	  ForthShowObject on any object fields

  OArrayShowMethod
    ForthShowObject on each element
	  ForthEngine::ExecuteOneMethod
	    either ObjectShowMethod or a builtin-class ShowMethod

? is ForthShowObject the right place to do the @object substitution
? how do you know when it is safe to clear the list of shown objects
  o ForthShowObject and builtin-class ShowMethods must call showContext Begin and End
    ? maybe Begin adds an object to the map
  The builtin container classes don't have to filter out already shown object,
  they just call ForthShowObject which does the filtering for them
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 6 2015

I added recursive descent to object/struct show, and also custom show methods
for all the builtin container classes.  They are mostly untested.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 5 2015

I added a first cut at 'show' for structs and objects.  The code currently just
shows the native types.

The next steps:
o add recursive descent of nested structs/objects
o add extensibility by invoking the show method for nested objects
o add show methods for builtin container classes

The show method probably should have these parameters:
o maximum nesting depth
o flag telling wether to display __refCount and __type
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2015

I wrote a parenthesized expression evaluator.  Previously if a method returned
an object and you tried to invoke a method on it, the parameters for the original
and second method were computed in the wrong order.

The code is almost working, the problems I know about are:
- double quote support is broken
- there are some cases where a space is missing when groups of tokens are combined
- there are some cases were extra spaces are added between tokens
- single quote support is untested
- multi-line support is untested
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 8 2015

My current goal is to make using client/server for debugging, having trace output
go to the server console window.

o ForthLib/StdAfx.h defines TRACE macro
  o TRACE uses CustomTrace routine, defined in ForthEngine
o Forth.h defines TRACE_PRINTS/TRACE_OUTER_INTERPRETER/TRACE_SHELL for categories
  which will have trace ability compiled in - if these are defined, SPEW_XXX
  macros are defined to be TRACE, otherwise SPEW_XXX are undefined
o ForthEngine::TraceOut sends output to either the console or to a custom defined trace output routine
  o defaultTraceOutRoutine calls TRACE
  o ForthGuiDlg defines a trace routine which sends trace output to debug pane
  o ForthEngine & ForthShell methods conditionally call TraceOut if trace enable flags are set
    o ForthEngine::TraceOp calls TraceOut
    o ForthEngine::TraceStack calls TraceOut
o Only MSDEV builds have TRACE functional, for all others it is a variadic no-op

ForthEngine::TraceOut  ->  defaultTraceOutRoutine  ->  TRACE
ForthEngine::TraceOut  ->  ForthEngine::ConsoleOut
TRACE  ->  CustomTrace  ->  OutputDebugString

ForthEngine::ConsoleOut  ->  ForthConsoleStringOut  ->  pCore->consoleOutStream->pOutFuncs->outString

Overall plan:
- change TraceOut to be variadic
? make as many things go through TraceOut as possible
  ? or should this be outside of ForthEngine, so it can be invoked before engine exists
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 13 2015

I started working on an implementation of the atc game and I quickly ran into
a major limitation of parenthesized expression support - it can't handle any
expressions like a(b).c(d) where the result of a parenthesized expression is
an object that has a method with parameters invoked on it.  That should be
compiled as "d b a.c" but currently fails as soon as it hits ".c".

This is a difficult problem, because the current outer interpreter parses a
token and immediately processes it, fixing this problem would require parsing
an entire parenthesized expression before processing any of its tokens.
It is also common to have expressions span multiple lines, which the current
implementation doesn't support.

My current planned implementation is this:
In parseToken, when you hit a left paren, enter parenthesized expression scan mode.
In this mode:
o scan input into a temp buffer, making a list of tokens found
  o scanning deals with double-slash and backslash comments, comments are
    not entered into temp buffer
  o tokens have type, buffer offset, number of characters
    o type is simple, leftParen, rightParen, characterLiteral, stringLiteral
  o keep track of parenthesized expression level
  o when paren level reaches zero, exit parenExpr scan mode
o perform multiple passes over token list, reducing the level of parenthesized
  expressions with each scan
o 
a(b.c(1).d(2) e f.g(3)).h(4).i(5 j)
5 j  4  b.c(1).d(2) e f.g(3)  a.h.i
5 j  4  2 1 b.c.d  e  3 f.g  a.h.i

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 1 2015

I moved Forth development from Visual Studio 2008 under Windows Vista to Visual
Studion 2013 under Windows 7 today.  The program was working fine, but pretty
soon I ran into strange crashes like "Access violation executing location 0x005FF7DC."
where the address was a valid address inside the dictionary.  The problem turned
out to be the Data Execution Protection feature, it was triggered whenever I
tried to execute an op which was defined in assembler.  The solution was to
allocate the dictionary memory using VirtualAlloc with flags which say to allow
execution in that memory block.

I also had to change the tmpnam op, it had been returning a filename that
started with '\', so I guess it was trying to put the temp file in the root
directory, which caused opens to fail.  My solution was to prepend a '.' to
the path, kinda hacky but it works so far.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 7 2014

I added block file support to the kernel.  It is only partially tested, I
haven't even tried 'load' or 'thru' yet.

In testing block support I found a bug in local array support - the vocab
entries for local arrays actually had the offset for the top of the array
not the base.
There was also a crash bug with the compilation of the allocLocals opcode when a
local array was the first declared local.

I added a new interpreter syntax for local variable references - &var will
now leave a local variable reference on TOS.  This is currently only implemented
for locals, I should add it at least for member variables, and maybe for
global variables.

There are multiple places where file operations are being done directly instead
of thru the shell, I need to clean those up and test client/server in general.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 29 2014

I replaced ansiMode with 'features' which is a fake variable that allows you
to change individual ansi features.
The next ansi compatability change is string variables.  I'm going to change
them from having 2 ints before the characters to having 2 bytes.  This will
limit them from being able to have strings longer than 255 bytes, but will
make compatability much easier.  I should add a builtin buffer type which acts
like the old string, with an added read offset field.
The next change after that should be floating point.  I should probably just
just change all my floating point stuff to be ansi compliant instead of adding
compatability ops and feature flags.
Most forth implementations use a separate FP stack, since this is more efficient
with hardware.  This would make moving the floating point ops out of the kernel
easy, most of the ops are just a single FP instruction.  It would make the
no assembler version a bit harder, it would need to emulate the FP stack.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 28 2014

A change I made to get tetris to work broke ansitest.  The underlying problem
is that ForthShell::ParseToken leaves the buffer pointer pointing to the
delimiter of the token it just parsed, but ForthShell::GetToken leaves the
pointer pointing at the character after the delimiter.  The tetris code builds
its tetris pieces using s" indirectly executed by ' execute
  s" abc" type
    types "abc"
  : boo ' execute ; boo s" abc" type
    types "bc"

Changing ParseToken seems dangerous, but I changed it to move past the terminating
space or tab (not null though), and it seems to work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 27 2014

I made a maze generator for work yesterday, it works, but usually fails with
a deadend because it doesn't have backtracking.  While working on it, I found
a few problems:

1) I ran into a crash because the first local variable I declared was inside a loop
2) I was getting bad opcode errors when I reloaded a file in autoforget.

The autoforget problem was because ForthForgettable::ForgetPropagate was first going
down the chain, getting each forgettable to process the forget, then going down
the chain a second time, deleting any forgettables which were above the new DP.
The problem was that a global object existed whose class had been forgotten the
first time through the forgettable chain, and on the second pass when the global
object was deleted (I think) it was trying to execute its delete method, but
the opcode was bad because the class had already been forgotten.  I tried
swapping the order of the passes, but now I'm getting other errors which seem
to be because autoforget isn't really forgetting anything. 
Undoing that change didn't fix the problem, forgetting some ops causes the ops
to be removed from the engines op table, but not removed from vocabularies.

The bug is a strange one - in ForthVocabulary::ForgetOp for some reason I had
code for processing constant entries that was causing the forget to always
terminate the first time it hit a constant (an enum in this case).  The code
was bizarre, it was trying to get the structure index from the 2nd word of
value field, which is just the kBaseTypeUserDefinition, turns it into an
opcode, and uses that to figure out if it should forget the constant.
I removed the constant case, and added to the default case to have the
forget search continue with the next entry.
After that, I put back in the ForgetPropagate change, and it appears to work.

The fcp.f chess program had been working, but failed when I tried it recently.
The problem is that I had to change how $word worked to make tetris work, $word
has always skipped all initial delimiters, and tetris created its pieces using
a bunch of string which started with multiple whitespace characters.  I changed
ForthShell::GetToken to take a skipLeadingWhitespace flag which defaulted to true,
which $word set to false.  What I didn't know is that on entry to GetToken, the
next character was actually the delimiter to the previous word, so $word was
always terminating immediately and giving back an empty word.  I changed this
to have it break out of the skip-initial-whitespace loop after the first char
if the skip flag was false.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 24 2014

Crazy idea that I've probably had before:

Move the optype bits to the bottom 8 bits, and have the optypes which have
the bottom 2 bits zero be used for native ops - that way the opcode is the
same as the actual code address.  The next code for continuing on to the
next native op is inlined, the inner interpreter branch register is used
for all non-native types.

Native ops would end with this macro:

next macro:
	mov eax, [esi]
	add esi, 4
	test eax, 3
	jnz notNative
	jmp eax
notNative:
	jmp edi
	
	
edi points to this inner interp dispatcher:

innerDispatch:
	mov	[ebp].FCore.IPtr, esi
	mov	[ebp].FCore.SPtr, edx
	mov ebx, eax
	and eax, 255
	mov ecx, [ebp].FCore.ops
	mov ecx, [ecx+eax*4]
	jmp ecx

o call this 'crack forth' for using the cracks between direct threaded
  native addresses for token threaded opcodes
  o source file type is .c4
o there is no longer any checking for a bad native opcode
o if native ops can be immediate, immediacy cannot be determined from the opcode
o we lose a level of indirection, we can't patch the ops table to change what
  native code an opcode dispatches to, which isn't currently used
o this change makes saving a relocatable image harder - it would probably
  require diffing 2 images saved with different base offsets.
o this makes compiling combo ops harder - there would need to be a table of
  the N native combo ops which can be combo-ed
  -> maybe the vocabulary entry for combo-able ops would have the optable index

A related change I've been thinking about is to replace user defined ops with
an optype with the opval being the longword offset from the base of the dictionary.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 22 2014

I've got all the ANSI test problems fixed.
Fixing the 'source' test required me to jump into the ForthBufferInputStream
code, and it is a little messed up.  It sets the buffer size to 4k, plus it
allocates another buffer that is as big as its input buffer and copies the
entire input buffer there.  The code could have gotten this messy because it
is used both for 'evaluate' which uses a single line of input just once,
and ForthGuiDialog, which has a mutli-line buffer that it keeps reusing.

I started working on making saved images, but ran out of steam.  Loading up
a fairly full kernel is instantaneous in release, it does take a while in debug,
mainly because of all the debug spew.

Before I started using the ansi compliance test, I had first ported a robots
game (robots.fth) and a newer version of the chess program (FCP.F).  The ported
version of robots was working fine, I kept running into more and more problems
porting FCP, which is what convinced me to try to get closer to ansi.
After getting ansitest working, I tried the ported version of robots again,
and it was now crashing.  The main problem was a bug in the original code,
in a few places it was using int store/fetch on a byte array, so it was clobbering
code just after the array.  It didn't fail before because I had 'allot' allocate
longs instead of bytes, when I fixed that the bug showed up.

My goal is to get ansi sources to work with little or no changes.  I've setup
a new 'external' directory for ansi sources.  The minimally modified robots.fth
still fails when you try to make your first move, it looks like it is executing
an abort opcode.
-> my '?csp' compatability word had an unterminated 'if'
A lot of debugging could have been prevented by either:
1) having ';' detect a non-empty shell stack
2) having the abort opcode have a parameter indicating 'bad-if' (combo op?)

fcp.f runs with no changes, but it crashes after a dozen or so moves, it looks
like an array of ops is getting written over by part of a string.
YOW! The bug was triggered by the source line:
  ' sortKiller2 , ' sortKiller3 , ' sortKiller4 , ' sort , ' sortNoop ,
The real cause of the bug was the multi-character constant code, which allows
character constants surrounded by single quotes of up to 8 characters, usually
they are just 1 character in length.  The tick sort near the end of the line
was being turned in a characer constant { sort , }, then sortNoop was being
executed instead of compiled, and finally comma was executed, which put the
first 4 chars of the constant { sor} in the dictionary.
The fix was to change the single quote handling code to reject the symbol
if it contains a whitespace or tab, unless it is preceeded by a backslash.
This bug could still be triggered if the user defines words like "'foo\".
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 20 2014

I've got the 64-bit integer changes for ANSI compliance in, and ansitest works
aside from the following problems:
1) a test of 'source' which seems to require that 's"' which pushes a text
   block and the result of evaluating s" source" return the exact same address
   and length
2) a test which prints 0...9 separated by a space is actually separated by two spaces 
3) a test of 'accept' which looks like it has an extra linefeed at the end

I'm not feeling good about the 64-bit integer changes - they require making
some changes that will make 64-bit float code much more messy and not screwing
up any code which tries to access a int64_t in memory directly.  I am not
willing to change 64-bit float code to embrace this madness.  The first thing
I should do is categorize all the situations where 64-bit values occur:

o on pstack/rstack
o as local vars
o as member vars
o as struct members
o as params to DLL calls
o as literals inlined in code

I need to find a simple way to make these work for ANSI compliance.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 19 2014

I've started making the changes to make 64-bit integers ANSI compliant.  The
changes aren't that hard, but I don't know how 64-bit floats should relate to
this, having them represented reversed on the stack would make using 64-bit
ops like dlit, 2@!++, and 2@@++ less error prone.

CREATE GN-BUF 0 C,
: GN-STRING	GN-BUF 1 ;
: GN-CONSUMED	GN-BUF CHAR+ 0 ;
: GN'		[CHAR] ' WORD CHAR+ C@ GN-BUF C!  GN-STRING ;

{ 1 0 GN' 1' >NUMBER -> BASE @ 1+ 0 GN-CONSUMED }

just before >NUMBER:
o GN-BUF has '1' in first pos
o stack 9s: 1 0 GN-BUF 1

after >NUMBER:
o stack is: 1 0 GN-BUF+1 0
o stack should be : 11 0 GN-BUF+1 0


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 16 2014

John Hayes ANSI compatability test has pointed out 2 somewhat major changes
I need to make:

1) ANSI forth specifies the stack word order for 64-bit numbers to be the
   opposite of what I've done, which is the 'natural' order - natural in the
   sense that it is what the C++ compiler generates and C calls expect, that
   is that the lower order word is at a lower address.
2) ANSI forth allows control flow words to be mixed and matched, I need to
   remove some of the error checking to allow this, I need to replace the
   existing tags like 'begin' and 'if' with more generic ones like 'looptop'
   and 'forward branch'.
   
I'm going to put off the 64-bit order changes for now, I'm getting the tests
to work by doing an order switch in the test.
+ modified control flow words to be more flexible

I changed the assembler inner interpreter to use ESI for the instruction pointer
instead of ECX.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 15 2014

I've made a lot of changes trying to get closer to ANSI forth compatability,
using the fcp.f chess program to expose incompatabilities.  Notable changes:

o better support for case insensitive symbol search
o more words which search vocabs search chain instead of top vocab
o $word & blword leave a byte for counted string length below returned pointer
o support of hex literals starting with '$' when all else fails
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 26 2014

I'm looking at implementing an assembler version of 'does':

: definingWord
  builds
    buildsBody
  does
    doesBody
;

: definingWord
  builds
    buildsBody
  doescode
    doesBodyInAssembler

I can think of 2 ways to do it:

1) the words created by definingWord are high-level, and begin with a
   low-level opcode, which is the 'doescode' part of the definition.  This
   opcode is defined by doesBodyInAssembler, it gets the pointer to the
   definedWord data in IP and must pop the new IP off the rstack before exiting.
2) the words created by definingWord are low-level, and begin with a call to
   doesBodyInAssembler, which gets the pointer to the definedWord data by popping
   it off the system stack.
I went with option 1.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 25 2014

I got the output stream redirection working again, at least to the point
where redirection to string works in forthtest, and there are no undeleted
objects upon exiting forth.

One notable change that occured while debugging is that previously all delete
method execution was being done using the engine primary thread/core, which would have
caused problem when delete methods were called on objects which were allocated
in other threads.

Default console out objects need to be defined as singletons which ignore
a delete triggered by release, since they will be shared by all threads in
an engine.  Default console out objects are only defined when console out is
always redirected somewhere other than the normal user console (stdout), such
as when running in client/server or in the ForthGui app.

A possible fix for the crash

- when I was getting errors while output was redirected to a string, the
  error output was still being sent to the string - the error should have
  caused output to be redirected back to the default console before printing
  error output strings
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 17 2014

I got console output using stream objects mostly working.  While I was doing it
I ran into 3 strange things:

1) When I looked at my changes with 'git dtd', when I exited out of Beyond
   compare, all my changes were being undone.  This happened at least 4 times.
2) When debugging the ForthGui app, MSDEV wouldn't let me set breakpoints after
   recompiling unless I did a full rebuild, claiming that the source had changed.
3) Redirection in ForthGui wasn't working, and I tracked it down to ForthEngine::GetCoreState
   returning an invalid value - changing it to not be inline fixed the problem,
   but does not explain it.
   
One big downside to using output stream objects is that it makes error recovery
much more likely to fail catastrophically - re-initializing after an error can
cause the release/delete of stream objects, and if they are already deleted
or corrupted, this could cause another error.

I refactored things so that OOutStream wasn't completely abstract, and output
streams have an optional pointer to a block of functions for outputting chars, blocks
or strings, and these functions can called directly without the overhead of
setting the current object to the output stream and pushing/popping arguments.
ForthGui app appears to be working.

- ops for redirecting output (replacements for outTOString/File/Screen) aren't done yet.
- reference counting when setting/resetting streams isn't right yet
- client/server is written but untested
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 5 2014

I decided to try to get single stepping threads working as a first step toward
a forth debugger.  There were a bunch of bugs in the assembler version which
were pretty easy to fix, there is a more difficult set of bugs left which
are caused by how the inner interpreter is exited whenever state isn't OK.
To avoid having the inner interpreter be checking state before every dispatch,
I have any code which sets state to non-OK branch to interpLoopExit, which
does a return which only works if the inner interpreter was entered by calling
InnerInterpreterFast, and fails if InterpretOneOpFast was called.
-> Fixed by having InterpretOneOpFast call the inner interpreter instead of
   branching to it - ops which have an error will return and get to the code
   right after the call, ops which exit normally will get to InterpretOneOpFast
   exit code which discards the return address.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 28 2014

I decided to scrap the combo op stuff for now, and concentrate on building
things using forth as it is now to determine what changes need to be made.
I had turned off the ASM_INNER_INTERPRETER define so that I could debug the
combo op code in C++, but when I turned it back on, I am now getting undefined
symbols for all the assembler implemented stuff - there is a linker error for
_InitAsmTables missing.  I tried changing the asm code to add an underscore, that
didn't fix it, maybe I somehow got the linker to now include the object file for
InnerInterp.asm?
-> the custom build rule for InnerInterp.asm wasn't defining ASM_INNER_INTERPRETER,
   and the assembly code has ifdefs that require it.
After fixing this, the debug build works, but the release build fails with
undefined externals for all the single precision float routines.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 1 2014

I moved the opcode compilation/uncompilation from ForthEngine to its own class,
ForthOpcodeCompiler, which is still part of ForthEngine.cpp for now.
While debugging it, I added setTrace( 255 ), and this made the tests crash.
The crash happened because the definition for checkResults got overwritten by
the trace text output.  I haven't chased down how that happens yet.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 12 2014

I got client/server working on both Windows and Ubuntu again.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 11 2014

I tried to get client/server working between Windows and Ubuntu, in preparation
for getting an Android build working, where client/server will be crucial, since
developing on a tablet without a keyboard would be insane.
Ubuntu in its amazing brain-deadness intentionally create /etc/hosts to have
an entry that maps your machine name to 127.0.1.1, an alternate loopback address,
so having the 'server' op print out the ip address for clients to connect to hasn't
worked so far.  I tried using the newer non-deprecated getaddrinfo call, but it
has the same problem as the deprecated gethostbyname call.  There must be a way
to do it, since ifconfig can do it.
I change 'client' to not take the ip address as a ulong on TOS to taking a string,
then found out that client/server is broken in general - it doesn't even work
with localhost between client and server on windows.  On the plus side, this
should allow using regular hostnames and even IPv6 addresses.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 13 2014

I added the missing parts of localRefOp and memberRefOp combos.
I took a stab at fixing the OpZBranch and OpBranch combo types.
Neither of these is currently used so they are both untested.
InnerInterp.S and InnerInterpARM.S are both missing squished literals and the
newer combo op types.
I should add having the combo types be used before porting them over to the
other assembler implementations.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 10 2014

I added squished long literals to the engine.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 9 2014

I added the squished float/double literals to the engine.  I haven't done the
linux or ARM versions of the assembly code

While doing it I noticed that there are some inconsistencies in the optype support:
o there is an ozbComboType which has assembly code but isn't in the optypes table,
  and doesn't have an optype assigned to it in Forth.h
o ForthInner.cpp has 2 combo op types which don't have optypes assigned to them
  and aren't in the assembler version: LocalRefOpComboAction and MemberRefOpComboAction
o ForthInner.cpp doesn't have optype handlers for squished floats/doubles or ozbComboType

Also ozbComboType looks like it won't work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 8 2014

I want to add single and double precision FP literal opTypes.  The overall idea is
that a float would be fit into 24 bits by throwing away 3 bits of exponent and
5 bits of mantissa, and a double would be done by throwing away 11 bits of
exponent and 29 bits of mantissa.

The outer interpreter will only compile the squished float/double types when
the value could be represented exactly in the compressed form.
There should be some syntax for forcing the squished format to be used - maybe
adding '~' to the start of a FP literal?

0x3f800000 == 1.0

0011 1111 1000 0000
0 01111111   0000000
+    127   1.0000000

0x41280000  == 10.5

0100 0001 0010 1000
0 10000010   0101000
+     130   1010.1000
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 7 2014

Added single precision FP ops (fsin, fcos, fpow, ...).  For some reason, I had
to add extern references to the single precision library functions to ForthMain
to make the build work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 4 2014

While trying to implement generators I realized that there was a critical
flaw in how I handle object lifetimes.  There was no safe way for a method to
create an object and return it without retaining a reference to it.
The solution was to provide a way for a container to give up its reference to
an object without deleting the object if the container was the last reference
to the object.  Effectively, this allows an object reference to be left on the
stack even though its reference count is 0, which is much like the state that
an object is in when it is first created - the only reference to it is on the
stack, not in any container.
To do this, I added a prefix operator, unref, which is an alias of '->-', and
the object varaction routines implement this by leaving the object on TOS and
decrementing the refcount, but not deleting the object if refcount is 0.
I also added unref methods to the containers and container iterators wherever
it made sense to do so.  I also removed or modified methods which would leave
a dangling object reference on the stack in the case where the container was
the only reference to the object (replaced OArray.pop with OArray.popUnref and
changed OList.removeHead and removeTail to not leave any object ref on stack).

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 9 2014

I took a long break from Forth while I played through Morrowind.  When I tried
to use forth to decode some morrowind save files to locate a missing quest
item, I found that a bunch of things were broken, just storing to a local
string caused an abort.  The problem was that the opcode for allocating the
local stack frame was stuffed into the wrong place.  After fixing that, there
is still a problem with strings, the local string init optype is stomping
other locations.  It almost looks like all local variable addresses are defined
to be the memory location just above their actual storage, but if that were
true nothing would have worked, right?  The local stack frame layout is:

RP -> last longword of last defined variable
...
FP-4 -> highest longword 
FP -> oldFP
FP+4 -> oldIP

I guess it could have gotten broken when I added the anonymous functions, since
those did change how the local frame got defined.  Changing the local var
addresses to be correct still didn't fix the test, but the test was crashing
because I had turned on full tracing and the test redirects output to a 512
byte buffer, way more than 512 bytes was generated including trace output,
trashing code just after the buffer.  Turning off tracing made the tests
run successfully.
Moral of the story: always run the tests before a checkin!
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 19 2013

Over the last month I converted the SoftSyn2 music project to use QtCreator.
As one attempt to get this to work, I tried to get Microsoft's console
debugger to work, I never did get it to work, but installing it overwrote
parts of the Windows SDK configuration so that MSDEV was using the version
6.0 includes and library directories, which were not actually installed, instead
of the 6.0A version it was previously using.  This caused all MSDEV builds
to break since it couldn't find the include files it needed in the 6.0
directories.  I tried fixing the registry entries to point back to 6.0A, but
MSDEV kept using the 6.0 versions.  To get things to build I added explicit
6.0A paths to the MSDEV Tools/Options/Projects and Solutions/VC++ Directories
settings above the ones which use the WindowsSdkDir variable.

I added an extension of ForthForgettable which is used to cleanup global
object instances when forgetting.  I started thinking about a general way for
ops to use ForthForgettable, that led me to try to define anonymous functions,
which are sequence of ops which are represented by the address of the op
sequence and have no associated opcode.  This is trivial to implement unless
anonymous functions can have local variables, in which case there needs to
be something like push/pop for local variables.
---
- engine kEngineFlagHasLocalVars flag
- engine mpLocalAllocOp
+ local vocab symbol count (and unwind for pop)
? maybe use shell stack to hold pushed info
  -> func definition could occur inside a control struct, so top of stack
     might not be colon/func tag when a nested func definition is started
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 14 2013

Over the last few weeks I added floating point support to the ARM assembler.
The only thing really left is the fp convert instructions.  I also haven't
done the vector/super scalar instructions, but I'm not even sure the RPI
actually supports these.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 29 2013

Last weekend I got DLLVocabulary support working on ARM.  It is only lightly
tested, I am especially unsure if it works when there are more than 4 arguments
to DLL routines.
I have gotten David Kuhling's MacroForth ARM assembler ported and working,
tested to the point of making a no-op and an add op that work.  One bug at
the end was that 'next,' was compiling a relative branch, not a register
branch, the opcode in David's original code was not even close to the right
value.  I don't know if the 'bx,' opcode will work for more than a simple
register argument, but that is okay for now.
A lingering non-compatability with ANSI-forth was revealed in the assembler
port - it used CREATE...DOES> instead of build...does like my version, I had
problems when I left it as create...does, I think my 'create' just makes a
variable without allocated storage, and 'does' doesn't turn it into a real
user def, it still acts like a variable not an executable user def.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 18 2013

I changed the ARM asm inner interpreter to be compiled by GCC instead of using
AS directly so that I could use the GCC preprocessor to give registers
symbolic names.

I added multi-character literal constants to the outer interpreter syntax.
A single quote delimited string of 4 characters or less is stored in one
stack entry, 5 to 8 characters are stored in two stack entries, with characters
0 to 3 on TOS in the two stack entry case.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 16 2013

The crashes in forth_autoload were in strlen and strcpy, they were because r12
isn't protected in this calling convention.  I now save/restore r12 in all ops
which call clib functions.
The forth_autoload 'ls' op fails redirecting stdout, it is probably a difference
betweens linux and windows _dup.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 15 2013

I finished the rest of the assembly optype action routines except for the combo
types for the ARM.  They are untested of course.

if..else..endif, begin..until and begin..while..repeat all work.

Some operations with local variables still crash, like this:
: boo 5 -> int aa begin aa %d %bl 1 ->- aa aa 0= until ;
This crashes, but if you make aa a global it works.

: boo 5 -> int aa 7 -> aa aa ;			// works
: boo 5 -> int aa 7 -> aa aa %d ;		// crashes
: boo int aa %bl ;						// crashes
: boo int aa 0 , ;						// crashes
-> Having a cCode op in a colon definition with local variables crashes
Doh! When going to a cCode op I wasn't saving FP in pCore shadow, and after
returing from cCode op I was restoring incorrect FP from pCore shadow, which
caused a crash as soon as anything tried to use a local variable or on exit.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 14 2013

Many of the basic operations (dup, over) didn't work because I often used the
ldmdb instead of stmdb to push data.

I noticed that 'allot' still allocates longs, not bytes, I thought I had
changed that, it looks like I changed the scripts to use allot instead of callot,
but I didn't change the actual allot op.  Changing it could break things,
because there could still be things that assume it uses longs, and worse there
could be things that are counting on DP to be longword aligned after an allot.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 13 2013

Over the weekend I have added the multitude of missing ops to the ARM inner
interpreter.  The version I started wasn't really debugged - I think I had
gotten the non-turbo version working and just started getting the assembler
version debugged when I dropped the Nintendo DS version.  Things as basic
as do-loops don't work at all.
There are still a number of optype action routines which are not in assembler.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 10 2013

I decided to get my forth running on the raspberry pi ARM machine.  I already
have an old arm7/arm9 Nintendo DS version with an assembler inner interpreter, but
to get it running initially I decided to use a C-only version, so I am getting
the windows C-only version running.

To turn C-Only mode on, you need to manually:

o remove ASM_INNER_INTERPRETER from ForthLib C++ preprocessor definitions

o remove ASM_INNER_INTERPRETER from the custom build rule for InnerInterp.asm
If ASM_INNER_INTERPRETER is not defined, the only things that are assembled
are CallDLLRoutine to allow DLL ops to work, and NativeAction, which is used 
not part of the build configuration.

Just to keep things interesting, I changed the _ASM_INNER_INTERPRETER define
to be ASM_INNER_INTERPRETER.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 5 2013

There was still a crash in biclasstest, the builtin class definition code
wasn't setting the optype of methods defined in C so they were being executed
as if they were native ops.

It looks like everything might back to where it was before the turbo changes.

I changed turbo mode so that now it is the default, and the prompt for turbo
mode is 'ok>' and non-turbo mode is 'OK>'.  The only difference between turbo
and non-turbo now should be that in non-turbo mode the inner interpreter is
still the C version, so non-native optypes will use the C optype action routines,
and native optypes will be sent to the native interpreter one opcode at a
time.  Should I get rid of the C optype action routines, and have all optypes
except the CCode optypes be sent to the native inner interpreter?
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 4 2013

I changed how turbo mode works pretty significantly:
o optype 0 is used for both builtin asm ops and user asm ops
o builtin ops defined in C are now type kOpCCode
o there are no duplicate op definitions - builtin ops are defined in asm or C, not both
o the opcode definitions in Forth.h like OP_FETCH don't need to be kept in
  sync with the order of op definitions - they are now indices into an array of
  opcodes
forthtest and chess work, there is still a crash in biclasstest.

After getting it working I realized I hadn't saved a version of the executables
from before these changes to compare to, so I backed out my changes, built
release and debug versions and saved them along with a copy of the scripts.
I re-added my changes, and decided to change the executable names from both
debug and release being named ForthMain.exe to being Forth.exe and ForthDebug.exe.
After doing this, Forth.exe crashes on startup.  I tried reverting the name back
to ForthMain.exe, but the crash is still there.  After crawling around in map
files and adding printfs, the crash was because the terminating entry of the
builtin op list had an empty string instead of a null for its name, I don't know
why it didn't crash the first time I built it.  Oh well.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 29 2013

The chess turbo mode crash was caused by rpop accessing the param stack instead
of the return stack.  I never noticed it because I use local variables instead
of pushing/popping the return stack.
I added a crash dump, which shows the stacks, frame pointers and what ops
the IPs on the return stack refer to.
I started adding a debug mode for the assembler inner interpreter, where it
saves IP & SP in the core state after every op execution.  Currently it is
always on, I need to add a way to toggle it.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 25 2013

I added the ?do op, adding this made the kforth chess game work, for the few
moves I tried at least.  The game does still crash in turbo mode.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 23 2013

In a fit of extreme stupidity, I decided to change the names of the 64-bit
stack manipulation words (ddup, ddrop, d!, etc) to be ansi compliant (2dup, 2drop),
along with changing the == and != ops to = and <>.  This required updating
every script file, or close to every.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 20 2013

I started porting the kforth chess player, one thing I noticed is that 'allot'
on standard forth systems takes a byte count, while mine takes a cell count.
Along the way I added the standard forth numeric printing system from gforth.
While doing that I found out that gforth stores 64-bit numbers on the stack
in the opposite order from my forth, which caused a bug in the sign op which
was checking the wrong word for the sign.
After a lot of mucking about, I got chess to run, but it fails shortly
after starting - if you tell it to pick the move, it makes one pawn move and
then announces that you are in check.  If you pick the move, an access violation
occurs.  I don't know if debugging it is worth the effort.
Something I might want to do is change ops like ddup, ddrop and so on to
the more standard 2dup, 2drop and so on.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 15 2013

I think it would be good to get rid of many of the builtinOps, move them to
external assembler ops.  Right now non-builtin assembler ops take an additional
6 instructions of overhead for the userCodeType dispatcher over builtin
assembler ops.  To eliminate this, I could make user assembler ops have optype 0
same as builtin ops.
I think I made user assembler ops a different type from builtin ops because that
way optype 0 in turbo mode always meant builtin assembler ops, and optype 0 in
non-turbo mode always meant builtin C ops.  This change would mean that in
non-turbo mode the C inner interpreter would need to be able to invoke user
defined assembler ops, not just C ops.

o builtin op tables would have to be expanded as user ops were added
o a UserCodeAction entry would need to be added to the C ops table for each
  user assembler op to keep non-turbo mode working
o 'forget' would need to distinguish between builtin ops and user assembler ops
  having the same optype
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 30 2013

Add unimplementedMethod op
Add remove, findNext, clone to OIter and derived classes
Add find, clone, count to OIterable and derived classes
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 26 2013

The builtin class collections operations which remove an object from the
collection and leave it on TOS need to be changed - if you do a OArray.push
of a new object, followed by a OArray.pop, it will leave an object reference
on TOS, but the object will have been deleted.
The problem is that if the collection was the only thing that had a reference
to the object, removing it from the collection will delete the object.
The options:
1) get rid of OArray.pop, OList.removeHead and OList.removeTail, and do the
   equivalent with multiple operations
2) have the 'pop' methods leave an object on TOS which has refCount 0, but has
   not been deleted - just like what happens when an object is created
3) have the 'pop' methods take a reference to the object variable which will
   receive the popped object
4) have the 'pop' methods leave the refCount alone, but add a reference to
   the popped object to the autorelease pool
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 22 2013

It looks like supporting classes that extend structs and classes that aren't
descendants of object is too painful and error prone.
+ only allow classes to extend classes and struct to extend structs
+ change class: to do an implicit 'extends object'

I had to change classtest.txt, since it used classes extending structures,
and when I did I ran into a code generation bug - if you do <CLASS>.MEMBER_INT
the code generated should be 'drop FIELD_INT:OFFSET', the drop isn't being
generated.
-> the <TYPE> code generator was not checking if TYPE was a struct or class, fixed

At the end of the day, both classtest and rctest run with no errors and no leaks.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 21 2013

+ added a OThread class

I added an enum of opcode types in forth_optype.txt, I ran into a problem
because one of the optype names was also the name of an operator with
precedence - initMemberString.  I changed the optype name to memberStringInit.

Look at ForthInner.cpp:MemberStringInitAction and ForthOps.cpp:initMemberStringOp
to verify that they match up.  Also consider changing the allocation of bits,
or at least verifying that everything is expressed in terms of longs.
-> they did match up, member offset is longs, max string len is bytes

There are memory leaks from classtest.txt, there were several global objects
that weren't being released, when I tried to fix that I couldn't because one
of the classes extends a struct, not an object.  Things that extend a struct
don't inherit objects delete method.  I guess they could define their 
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 15 2013

I did a log file scanner for work to process 600+ MB stderr files to get the
unique exceptions using the builtin classes and the file class.  I found a
few bugs, the biggest being that I forgot that delete doesn't automatically
propagate - to support this, I had a way to do 'super.delete'.  I added a
super opcode and added support for it as the first symbol to the struct code
generator.  Adding that made the number of unfreed object on exit become 0.
I added a built in hashing function to OString, the hash is generated the
first time you request it with OString.hash, and is only regenerated if it
has been invalidated by a set or append operation.
I added 'ofif', a case op which is like 'of' except it is preceeded by an
arbitrary boolean expression, not a constant.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 8 2013

I split out the struct/class code generation from ForthStructs into ForthStructCodeGenerator,
it works well enough for classtest.txt to run without crashing.
I also reintroduced the debug and trace user definitions.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 30 2013

I'm debugging some code generation bugs I found when trying to add a file class.
The current ForthTypesManager::ProcessSymbol code generation does not work if
the first token is a member object, I don't think it will work if the first
symbol is a local object or struct either.
There is already a somewhat old description of code generation in ForthStructs.txt,
but here is another take on what ProcessSymbol should do:

First symbol cases

1) name of a class or structure type in angle brackets
  a) object on TOS
  b) ptrTo structure on TOS
2) global
  a) global object
  b) global ptrTo object
  c) global structure
  d) global ptrTo structure
3) local 
  a) local object
  b) local ptrTo object
  c) local structure
  d) local ptrTo structure
4) member
  a) member object
  b) member ptrTo object
  c) member structure
  d) member ptrTo structure
5) op which returns a reference (not implemented)
  a) op returns object
  b) op returns ptrTo object
  c) op returns ptrTo structure

After first symbol is processed, TOS is one of:
  a) object
  b) ptrTo structure
? is this true - could it be ptrTo object or op?


Middle symbol cases
  1) field
  2) method which returns a reference
  3) op which returns a reference (not implemented)

  
Final symbol cases
  1) native
  2) ptrTo anything
  3) method
  4) op
  5) struct
  
To be continued...
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 29 2013

+ added 'verbose' prefix op for vlist and describe, eliminated vlistq
+ added the ability to disassemble method ops with describe CLASS.METHOD
- in file.getLine the OByteArray.resize method is getting compiled wrong, the
  opcode used to prefix global byte variables is being compiled where it should
  be putting something to fetch the OByteArray member variable
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 28 2013

I started implementing a 'file' class and ran into a few problems

+ the file class has an OByteArray member - 4 bytes were allocated for this
  member, all object references need 8 - fixed
- the getLine method includes 'new OByteArray' - forth:new isn't executed,
  instead object:new is compiled as 0x520001ef - 1ef is object:new, but the
  0x52 opType is MemberByte which makes no sense, the opType should be
  0x6C opType MethodWithThis.
  -> the object.new vocab entry type field is 0, it should at least have the
     method flag (0x40) set, so it is being compiled as a member byte access
? how to deal with object.new and forth.new confusion
-> I changed object.new to object.%_new_%
- there is no way to add non-method ops to class vocabularies - because of
  how the first entry is defined, they are treated as member variables
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 11 2013

Added 16-bit register definitions to asm_pentium and fixed defs like [edi]
which were actually using 16-bit addresses to use 32-bit addresses.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 3 2013

I tried to make a DLL vocabulary for libmysql.dll, but when I ran any DLL ops
I got a low level error with a warning about using inconsistent calling
conventions.  libmysql uses stdcall, all my previous dll vocabs used cdecl.
Also, some of the libmysql calls return a 64-bit result, the current dll optype
always returns a 32 result.
I added DLLStdCall which sets the current definition dll vocabulary to use
the stdcall calling convention.
I added DllVoid which makes the next dll op definition return nothing.
I added DllLong which makes the next dll op definition return 64-bits - this isn't
fully tested, mysql_num_rows returns a 64-bit result that looks ok, but it could
just be that it is accidentally returning 0 for the high part.
I updated the sdl and sprig libraries to use DLLVoid and tested sdltest and sprigtest.

I got ttf_test.txt working.  When I started, the sdl_ttf dllvocab definition
kept failing, saying the entry points I was requesting were undefined, this
stopped happening when I added the libfreetype and zlib dlls.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17 2013

Resurrected ForthGUI - it had a bug where any error would cause all user
definitions to be forgotten - this was because it uses ForthBufferInputStream
which was defined as 'non-interactive' and when errors occur if the main
input stream is non-interactive, they are promoted to fatal errors which was
causing the existing forth environment to be destroyed and recreated.

- the output redirection system should be replaced with something object based
- ForthGUI should display turbo status
- ForthGUI should load forth_autoload.txt
- bring Windows/CVS version in sync with Linux version and migrate to Git

Changed forthtest.txt to just print errors.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Octomber - December 2012

Worked on Linux version of Forth
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 28 2012

The client/server version was failing in forthtest.txt in the first 't[' test,
it was a weird bug whose final cause was that the server shell was written
before I added ifdef handling to the base shell, so it wasn't calling ProcessLine,
so lines weren't getting skipped when they should, and some lines like the test
string submitted by 't['were being completely ignored.

The 'dir' crash was because it was redirecting stdout and stderr, and those ops
were not going through the shell filefuncs, so file handles from the server
process were being processed by the client process, leading to too much fun.

I added more file operations - rename, mkdir, rmdir.
The mkdir op takes an access mode param which is ignored under Windows.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 25 2012

I updated the windows client and server to have the new file operations (remove,
dup, dup2, fflush etc.).  It fails when I try to do the high level version of
'system', which uses most of the new file ops.  For some reason on the server
the debugger callstack and source don't line up, even after a full rebuild.
MSDEV does warn that the source doesn't match up with the executable.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 24 2012

I replaced all occurences of _WINDOWS to WIN32, the standard windows define.
I got the client-server windows version to work, I had to specify the actual
machine IP address, localhost (127.0.0.1) wouldn't work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 20 2012

Added multiple script panes and window resizing to ForthGui.
Changed trace output to go through a settable traceOutRoutine to allow trace
output to be sent to a ForthGui pane.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 18 2012

Updated classtest.txt to do some testing of OArray, OList and OMap.
Completed changes to have refCounts be 0 at creation time and have object
variable assignment affect refCounts.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 16 2012

Fix bugs in interpret and u* .
Fix bug with handling of things like obj.method( blah )  or   vocab:op( blah ).
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 13 2012

Added a bunch of tests to forthtest.txt.  In doing so I found thatt'interpret'
was broken - it didn't invoke the outer interpreter directly, it just stuck
stuff on the input stack and so the target string wasn't interpreted until
well after exiting 'interpret'.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 29 2012

I just realized that if a class extends a struct, it can't extend object and
be refcounted.

I had been thinking about defining okeep, orelease and odrop ops.  odrop would
be used after you executed a container method that removed an object from a
container and left it on TOS.  odrop would check the refcount and delete the
object if 0, otherwise it would just decrement the refcount and remove the
object from TOS.  This wouldn't work if two containers referred to the same
object and you popped the object from one container then did an odrop - the
odrop would leave the object refcount 0 and delete it, but the second container
would still have a reference to it.
-> odrop should not affect the refcount, it should just delete the object if
   its refcount is already 0
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 28 2012

While debugging the object system changes I ran into a painful bug, that was
caused by another thing I forgot to fix:  if all objects are refcounted, then
all local object variables must be initialized to NULL, otherwise the first
time you assign to a local object variable, it will try decrementing the
refcount of whatever bogus address the local object was pointing to.
-> zero out ALL local variables when allocating a stack frame - and the same
   should be done for global variables and member variables
+ AllocLocalsAction
+ allocObjectsOp
+ global vars & arrays - ForthClassVocabulary::DefineInstance already does this
+ global structs & struct arrays - ForthStructVocabulary::DefineInstance already does this
+ assembler versions where they exist (just allocLocalsType)
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 24 2012

I'm having doubts about the new object changes - maybe they are just doubts
about how to name things.  Specifically, should the root class be called 'object'
or 'ovar' - the other containers are themselves objects, but an ovar is not an
object that contains a single object.

When I was looking through the existing container code, I kept seeing cases
where assigning an object to a container didn't do a keep on the object.

Another odd thing is OListRemoveHead and OListRemoveTail - if I make them
do a release on the removed object, it will often be destroyed, but leave a
dangling object reference on TOS - I guess the rule will be that the user
has to remember to do a release
? or should the refcount be decremented, but no delete done if it is 0 - this
  would fit conceptually with having new objects on TOS have refcount 0.
  -> but if the user wanted to just discard the object, they would first
     have to assign it to a variable and then release it, doing a release
     on TOS would fail because the refcount is already 0.
     
+ I reworked the varop handling routines for all the predefined types to use
  a common inline function rather than explicitly duplicating the code for
  each usage scenario of each type
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 30 2012

I think the next steps for object support are:

o make all objects be refcounted
o change object new to create it on TOS with a refcount of 0
o change object varop assign to do refcounting

The key idea is that all refcounting is done in terms of containers, and an
object variable must be treated as the simplest container.

I think I will make this non-backwards compatible and change names to reflect
this.

o object will become ovar
o rcXXX will become oXXX

? how should varops interact with containers
src -> dst
  increases the refcount of the src object, decreases the refcount of the
  object dst previously referred to.
src ->+ dst
  if dst is an oVar, this is either an exception, or the same as '->'
  if dst is not an oVar, add src to the container, which increases the
  refcount of src
src ->- dst
  this should probably just be an exception, since doing a remove operation
  can cause a costly linear search, and should be forced to be explicit
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 27 2012

I was working on sdl_audio, it needs an audio feed callback, I coded it in
assembler.  I tried gforth assembler (asm_pentium), but it has a bug with
instructions which load an immediate value into a register - it always
uses 2 operands on TOS, and in this case there is only one operand - the
register code.
I switched over to the kforth assembler (asm_kforth), but it has a different bug,
this one happens when you use indexed addressing with ESP, in this case it
generates incorrect opcodes.  There is a note about it not working and it
looks like it implements a workaroudnd, but the generated code is wrong.
I looked at the bigForth assembler - it is an older version of the gforth
one, it doesn't have the change which makes it access undefined data, but that
change must have been made to fix something.
I looked at the bigforth assembler, which was done by the same guy as the
gforth assembler, its mov code has a later date, and it doesn't include the
ops which access below TOS.  I applied that change and it seems to work.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 24 2012

I'm planning on implementing a set of 'combo' optypes which will do 2 or 3
common operations in a single forthop.  The planned combos:
  NUM VAROP OP		4 ->+ foo
  NUM VAROP			22000 ->
  NUM OP			6134 *
  VAROP OP			->- woof
---
NUM VAROP OP
  VAROP would need 2 bits (support only ref/->/->+/->-)
  NUM would have 11 bits
  OP would have 11 bits
This would be compiled when compiling an opcode, if the previous two ops
were an int constant in the suitable range and a varop.
---
NUM VAROP
  VAROP would need 2 bits
  NUM would have 22 bits
This would be compiled when compiling an opcode, if the previous two ops
were an int constant NOT in the suitable range and a varop.
---
NUM OP  
  NUM would have 13 bits
  OP would have 11 bits
This would be compiled when compiling an opcode, if the previous op
was an int constant in the suitable range.
---
VAROP OP  
  VAROP would need 2 bits
  OP would have 22 bits
This would be compiled when compiling an opcode, if the previous op
was a varop, but the op before that wasn't a constant.
---
+ make the c++ version of the combo optypes code
+ make the assembler version of the combo optypes code
- test by making some opcodes manually and executing
- add a peephole optimizer to the engine that compiles the opcodes
- add combo support to TraceOp/DescribeOp
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 22 2012

I took the existing implementation of 'system' which did a lot of extra stuff
like redirecting stdout and stderr to files and then spewing them back through
the forth output stream, and made it do just the call to system, and I made
forthops for the other system calls which it had been using, and finally I
implemented system$ in the autoload which did all the redirection stuff.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 19 2012

I'm waffling again about rcobject refcounts.  My current wafflation is that
all object reference counts on TOS shouldn't be refcounted
  ? then how does object creation work - putting a new object ref on TOS and
    giving the object a refcount of 1 is problematic
    o we could make the convention that all objects are created with refcount 0
      and must be immediately assigned to a variable to avoid memory leaks
    o we could also require that you could only create an object into a container,
      with rcObject being the simplest container
    o or ALL object creations add an entry to the autorelease pool
      o maybe there should be a rcObject.create object that takes a ptr on TOS
-> I think the best approach might be:
  1) explicit object creation leaves object with refcount 0 on TOS
  2) temporary object creation leaves object with refcount 1 on TOS, and adds
     an entry to the autorelease pool
I think there is still some confusion between a reference counted object and
the variable that references it in my mind.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 18 2012

I noticed that access violations were crashing forth - to fix it I
changed the ForthLib project C++ code generation exceptions settings from
"Yes" to "Yes with SEH Exceptions", otherwise it can only handle C++ generated
exceptions, not processor exceptions like divide-by-0 or access violations.
Why did this work before?  Maybe I turned it off after it worked, otherwise
the debugger doesn't break on exceptions, and when I turned it back on I didn't
choose SEH exceptions.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2012

I changed how refcounted containers worked - previously whenever an object was
added to a container its refcount was incremented, and whenever an object was
removed from a container its refcount was decremented, that was broken because
it was never treating an object reference on TOS as being counted.  Consider
this scenario:
o create an rcObject -> object reference is on TOS, obj.rc is 1
o add obj to rcArray woof -> obj.rc is 2
o delete woof -> obj.rc is 1
The end result is that the object is left dangling.
Now adding an object to an array doesn't increment its refcount.
Assigning an object to an element which already contains an object reference
does decrement the refcount of the old object reference.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 10 2012

I tried to eliminate as many of the new 'unsafe' warnings as I could.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 19 2012

I added the ability for colon-defined ops inside class definitions to access
class member variables and methods, before only methods could do so.  Colon
ops don't push/pop the this pointer, they use whatever this ptr is already
set.  I should make sure that you can't access these colon-ops from outside
of their own class (and derived) methods.

ForthTypesManager::ProcessMemberSymbol
  called whenever you are in a class definition to process class member symbols
  -> ProcessMemberSymbol does iterate down the derivation chain, which is good if
     we want derived classes to be able to access ancestors colonOps
ForthTypesManager::ProcessSymbol
  called when symbol includes a period, symbol first part is used to determine
  the class
  -> ProcessSymbol incorrectly generates an offset instruction when it is
     given "objectInstance.colonOp" .
     
If colonOps are only to affect the object already referenced by the this ptr,
then I don't think "objectInstance.colonOp" ever makes sense, so we can just
disallow that - only colonOps which have no object instance selector and are
inside a class definition should be supported.
-> it would be nice if colonOp names just weren't recognized in these cases,
   so a colonOp name wouldn't obscure a same-named member in an ancestor class
-> this would be hard to implement, since FindSymbol always just returns the
   first symbol found, there is no direct way to have it continue the search
   after it finds a symbol that the caller rejects.
   
It would be useful to have a way to continue a search after finding a match
that is reject for some reason.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 26 2011

The midi support allows you to define midi in and out callbacks which are done
as user-defined forthops.  I kept seeing that the top level op of the midi in
callback would be executed in the inner interpreter, but none of the ops in the
callback were executed - the problem is because of how threads are created.
Threads contain a ForthCoreState struct, which includes the opcode dispatch
tables and table sizes.  When the midiInCallback opcode is executed, it gets
to the kOpUserDef optype action routine, which first checks that the opcode
low 24 bits is less than or equal to the maximum defined user opcode, but in
this case it isn't, because the midi in callback runs in the midi extension
thread which was created at startup, before any user definitions were loaded.


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 25 2011

After eons of neglect, I decided to try to get ForthMidi working again.  It
turns out the reason I was getting all those strange crashes in the midi input
callback was because I didn't have the 'CALLBACK' keyword in the callback
signature.  DOH!
I also in a fit of stupidity decided to 'clean up' the msdev project/configurations,
forgetting that there is no good way to do things the way I want in msdev.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 8 2011

I renamed the class ForthBaseType to ForthNativeType because there was also
an enumerated type forthBaseType.

I added array indexing to the syntax recognized by the outer interpreter.
The syntax is SYMBOL[] where SYMBOL is one of:
  a) a literal integer
  b) a struct/class typename
  c) a native type name (excluding string)
The symantics are defined by the existing kArrayOffset opcode, which is:
INDEX ARRAY_BASE_ADDRESS TYPE[] ... ARRAY_BASE_ADDRESS+(INDEX * sizeof(TYPE))
Currently, if SYMBOL is a class name, the size is the storage size, not the
size of the object reference on stack (always 8 bytes).

Forth crashes when you create an object instance of a class which has no
methods.  AllocObjectOp gets the primary interface pointer, which exists, but
it pushes the methods pointer, which is the address of mMethods[1], and the
std::vector code in debug does bounds checking, and if there are no methods
then mMethods[1] is out of bounds.
-> fixed
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 22 2011

I started trying to create a directory iterator class and found a big bug in
class support.  Inside a method definition compound symbols like MEMBERVAR.METHOD
don't work at all.
-> I now push the new class on the vocab stack during class definition

Another problem: the chdir command leaves _system_stdout.txt & _stderr files
behind it every time and everywhere it is run.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 17 2011

There were more problems with method definition, derived classes weren't
really working before.  I think they are mostly fixed now.
I fixed the method definition problem where a non-method whose name matches
will terminate the search, potentially causing the method to be assigned a
new method index instead of the index of the method it is intended to
override, but it is untested.  As part of the fix I added the ability to
continue searching vocabularies in general.  While adding this I had to
change how the search iteration was done so that instead of ending the
iteration based on the symbol count, now it ends the iteration when the
entry pointer goes beyond the top of the vobab storage.  There was already
a mpStorageTop pointer, but nothing was initializing or using it.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 16 2011

rcMap.headIter was always crashing when it tried to assign the map.begin() to
the c++ iterator in the rcMapIterStruct.  To fix it I had to change the allocation
of the rcMapIterStruct from malloc to new, because the c++ iterator assignment
doesn't just copy data, it needs the iterator to be initialized.

rctest.txt tests the containers and their iterators for empty, one element
and multiple element cases.  If the cleanup op is run, on exiting forth in
the debugger the object dump is empty.

I made an abstract base class rcIter so that you could define ops that would
take an iterator object that would work for all three container types.  This
broke things because as part of this, I had AddBuiltinClass check for the
methodOp routine being NULL and use badOp as the opcode, which uncovered two
bugs:
1) when a class extends another class, its primary interface is overwritten
   with the primary interface of the parent class, including the interfaces
   defining vocabulary - this led to all interfaces of derived classes having
   their defining vocab be the base 'object' vocabulary
2) ForthInterface::GetMethodIndex should go through the chain of defining
   vocabularies and find the first matching symbol which has type method,
   instead it finds the first matching symbol, and if that is not a method,
   it returns NULL
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 15 2011

I finished adding refcounted containers (array, list, map) with iterators.
Map iterators are completely untested.
I had to add global variables to allow the container classes to create their
associated iterator classes.
I put in rudimentary tracking of new/delete/keep/release in global variables.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 7 2011

The main hard drive on my old work machine failed on August 19.  It took me
several days to get things transferred to my new machine.  After getting
things working.  It looked like the Forth and Music directories were okay,
except the CVS file for sdl.txt was lost.
I just noticed that somehow the change of 'addressOf' to 'ref' in forthops.cpp
got lost somehow, but the changes in the sandbox scripts are all still there.
Over the last week or so I added some refcounted containers - rcArray, rcMap,
rcList and refCounted strings.  They all need testing.

UGH! if you remove an element from an rcList its refcount is decremented, so
if the list was the only thing that referenced that object it will be deleted,
but a non-null reference to the object is left on the stack.  We can't just
look at the refcount before pushing the object, unless we are requiring that
all rcObjects have a standard way of accessing the refcount...

I started to change rcList to not expose its link elements as structs and
instead have an iterator object, but it will take some thought
? when iteration hits end of list should the user be able to reverse
  directions and iterate back
? what should be returned each iteration - just the object, or the object
  and some end-of-list indicator

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 15 2011

rcArray methods:
o delete
  for each element
    if element.methods is nonzero
      element.release
  delete rcArray
  delete rcArrayStruct

o count
  return number of elements
  
o get( index ) ... object
  if ( index < elements.size )
    return element[index]
  else
    error( invalid parameter )

o set( object index )
  if ( index < elements.size )
    oldObject = element[index]
    if object is not null
      object.keep
    if oldObject is not null
      oldObject.release
  else
    error( invalid parameter )

o findIndex( object ) ... index (-1 if not found)
  scan array for first occurence of object, return index if found else -1
  
o remove( index num )
  if ( index+num < elements.size )
    for each element to be removed
      if element.methods is nonzero
        element.release
  else
    error( invalid parameter )
    
o append( object )
o resize( size )

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 7 2011

Changed 'addressOf' to 'ref'.  Updated all scripts.
Also changed addref to keep.
Started to define rcArrary, decided I needed to think it through.  The current
object bodies are just malloced, if i am going to use stl templates to implement
this and other reference-counted containers I will be using 'new'.  My current
thinking is that the object body for a rcArray will be just the refCount and
a pointer to the std::vector object.

- add autorelease to rcObject
-> requires the definition of autorelease pool
? whan do you explicitly autorelease
  -> when you return a newly generated temporary object

rcArray methods:

INDEX OBJECT set
INDEX get ... OBJECT
INDEX ref ... PTR_TO_OBJECT
count ... NUM_ELEMENTS
N resize
OBJECT append
OBJECT find ... INDEX (-1 if not found)


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 30, 2011

Reverted ForthInner.cpp and ForthStructs.cpp array changes, had to add in
array support for unsigned byte and short also.
Added _doUByteArray and _doUShortArray ops, I added the table changes to
the assembler version, but in the assembler they are just copies of the
signed version.

I rearranged the ops which have specified positions so that the ops for global
variables and arrays have the same ordering as the corresponding optypes.
Before the unsigned byte & short global ops were not with the other ops, which
made code generation for variable and fields clunky.  To avoid reordering all
the defines I moved the varop setting ops to the end of the table.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 29, 2011

I started putting back the array opcodes, first I made a backup zip file.
I got through Forth.h and ForthEngine.cpp.

Also, the new opcodes for 64-bit integer are mixed in with the other changes
and were never checked in.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 19, 2011

The crash in classtest.txt was because the tests array operations needed to
be updated to match the change in how arrays work.
While debugging the changes to array handling, I ran into a few things that
are making me rethink the whole idea.  For one thing, things involving arrays
are a good bit clunkier since there can be no field accessors after an array
access - I didn't think about how painful this would be.
For example, this
	2 arrayOf ptrTo rgba gapo
	1 gapo.g					-> 0 gapo.r
becomes
	2 arrayOf ptrTo rgba gapo
	1 gapo @ d@ <rgba>.g		0 gapo @ d@ -> <rgba>.r
There really aren't that many extra operations being performed, it is just the
amount of typing needed that is annoying, plus the loss of clarity.

The reasons for changing arrays was:
1) it was too easy to mistakenly place a varop so that it was applied to the
   array index instead of the array element
2) getting a pointer to array elements with addressOf is a mess
? maybe just change it from 'addressOf' to 'ref'?

If I keep things the way they are, most likely when array elements are being
manipulated the element address will be gotten and then immediately assigned
to a local var whose type is a ptr to the element type.

Removing the array changes and keeping the signed/unsigned changes wouldn't
be that hard, the worst part would be rearranging the opcodes, since the
number of optypes is now 11, the tables wouldn't be arranged in neat groups
of 10 anymore.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 18, 2011

I renamed ellipse.txt to graf2d.txt since it has lines, rectangles and circles.
+ vlistq is broken, it quits well before it has listed all ops

I am going to do 2 related somewhat major changes:
o support signed and unsigned integer types
o simplify array support
---
The signed/unsigned support mainly means adding unsigned versions of the byte
and short types which will do sign extension on fetch.  There is also a isUnsigned
flag in the datatype descriptor.  This will be useful for qsort & bsearch.

One thing that might be painful is that now the mapping from native type to
optype might be more complicated, unless I define new native types for the
4 unsigned integer types.

Another gotcha is that previously I defined int and short as signed but byte
was unsigned, I did this because otherwise I ran into problems when displaying
characters when sign extension got in the way.  Now by default bytes will be
signed, so things will have to be declared ubyte to fix it.

- classtest.txt crashes
---
The array support change is that array variables/field ops will just produce
an element address, they won't pay attention to the varmode:

  5 -> 7 arrayOfBytes
    will become
  5 7 arrayOfBytes c!
  
The interaction between varmode and variables used as array indices was just
too screwed up.

The kOpLocalXXXArray/kOpFieldXXXArray/kOpMemberXXXArray optypes could all be
replaced by kOpZZZStructArray, there might be a small performance penalty.
since now there would be a multiply for any array access.  Alternatively I
could have 4 special localArray optypes that would support 1, 2, 4 or 8
bytes per element.

+ changed ForthEngine::AddLocalArray to use kOpLocalStructArray
+ changed ForthTypesManager::ProcessSymbol
  + to not allow non-final tokens to be arrays
+ ForthTypesManager::ProcessMemberSymbol
- It looks like ForthTypesManager::ProcessMemberSymbol doesn't allow you to
  access the fields of member structs, only member native types inside method
  definitions - ProcessSymbol and ProcessMemberSymbol need to be refactored
+ changed ForthNativeType::DefineInstance
  + to compile different opcodes for unsigned byte & short global vars
+ change byte & short fetches to be signed by default
+ change global array ops to ignore varops
+ remove array action optypes
+ added unsigned byte & short global var opcodes
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 15, 2011

I added generic quicksort and binary search ops.

qsort( ARRAY_ADDR NUM_ELEMENTS ELEMENT_SIZE COMPARE_TYPE SIGNED_FLAG COMPARE_OFFSET )
o COMPARE_TYPE is forth native base type
o COMPARE_OFFSET is offset into record of field to compare
o SIGNED_FLAG is 0 for unsigned, not 0 for signed for integer types
o SIGNED_FLAG is string size for string comparisons
Some sample output for signed & unsigned bytes:

ok> variable aa
ok> 0x17330483 aa ! aa 4 1 0 0 0 qsort aa @ %x
83331704
ok> 0x17330483 aa ! aa 4 1 0 1 0 qsort aa @ %x
33170483
ok> 0x17333317 aa ! aa 4 1 0 1 0 qsort aa @ %x
33331717
ok> 0x87333387 aa ! aa 4 1 0 1 0 qsort aa @ %x
33338787
ok> 0x87333387 aa ! aa 4 1 0 0 0 qsort aa @ %x
87873333

bsearch( ARRAY_ADDR NUM_ELEMENTS ELEMENT_SIZE COMPARE_TYPE SIGNED_FLAG COMPARE_OFFSET KEY_ADDR )

bsearch is a little screwy - when it doesn't find a key it pushes the negative
of the nearest index+1, which is a little confusing, but I needed some way to
indicate when something wasn't found and was less than the lowest value in
the array.  If the return value is negative, you need to insert at -(val-1).

Maybe I should change it so it always returns the insertion index, and the
caller is responisble for checking for an exact match?

The next thing this suggests is adding a way of making datatypes user visible,
so that the user can easily specify:
o type of array elements
o type of comparison fields
o offset of comparison field

Something like STRUCT_TYPE:FIELD_NAME would be nice.
This would still leave the signed/unsigned issue to be dealt with.
Bit 7 is unused in the data storage descriptor word, could be used for sign.

A way of entering literal data for records would also be handy,
maybe something like: data NAME STRUCT_TYPE ... enddata

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 10, 2011

There was a crash in sdl testEvents, it was caused by return stack corruption,
it had a SDL_Event local variable and only 8 bytes was allocated for it, it is
a union type, and some of its subtypes have more than 8 bytes (SDL_KeyEvent is
10 for example).  I'm guessing that the size of a union type isn't the size of
its largest member, it is the size of the last member added to the union.
-> yup, fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 9, 2011

I tried a test of sdl keyboard events, the key value didn't appear anywhere,
it looks like there is a mismatch of how the c++ compiler aligns structure
fields and how forth does.

typedef struct SDL_KeyboardEvent {
	Uint8 type;	/* SDL_KEYDOWN or SDL_KEYUP */
	Uint8 which;	/* The keyboard device index */
	Uint8 state;	/* SDL_PRESSED or SDL_RELEASED */
	SDL_keysym keysym;
} SDL_KeyboardEvent;

typedef struct SDL_keysym {
	Uint8 scancode;			/* hardware specific scancode */
	SDLKey sym;			/* SDL virtual keysym */
	SDLMod mod;			/* current key modifiers */
	Uint16 unicode;			/* translated character */
} SDL_keysym;
SDLKey & SDLMod are both enums, both require 16 bits to represent

0	Uint8 type;	/* SDL_KEYDOWN or SDL_KEYUP */
	Uint8 which;	/* The keyboard device index */
	Uint8 state;	/* SDL_PRESSED or SDL_RELEASED */
3	SDL_keysym keysym;
3		Uint8 scancode;			/* hardware specific scancode */
5		SDLKey sym;			/* SDL virtual keysym */
7		SDLMod mod;			/* current key modifiers */
9		Uint16 unicode;			/* translated character */

The forth declarations are:
struct: SDL_keysym
	byte scancode			// hardware specific scancode
	short sym				// SDL virtual keysym 
	short mod				// current key modifiers
	short unicode			// translated character
;struct
// I'm not sure about sym and mod size, they are enums

struct: SDL_KeyboardEvent
	byte type	// SDL_KEYDOWN or SDL_KEYUP
	byte which	// The keyboard device index
	byte state	// SDL_PRESSED or SDL_RELEASED
	SDL_keysym keysym
;struct

-> when SDL_keysym is defined, the struct code recognizes that the short sym
   field would be misaligned, so it adds a pad byte after scancode
   
key down   type=0x2  which=0x0  state=0x1  scancode=0x0  sym=0x12fc  mod=0x0  unicode=0x0
 02   00   01         00    1e  fc 12  00 61 00 00 00 00 00 00 00        ........a.......
type which state   scancode ??   sym
key down   type=0x2  which=0x0  state=0x1  scancode=0x0  sym=0x12fc  mod=0x0  unicode=0x0
00950098   02 00 01 00 1e fc 12 00 61 00 00 00 00 00 00 00        ........a.......
key up   type=0x3  which=0x0  state=0x0  scancode=0x0  sym=0x12fc  mod=0x0  unicode=0x0
00950098   03 00 00 00 1e fc 12 00 61 00 00 00 00 00 00 00        ........a.......

key down   type=0x2  which=0x0  state=0x1  scancode=0x0  sym=0x12fc  mod=0x0  unicode=0x0
00950098   02 00 01 00 30 fc 12 00 62 00 00 00 00 00 00 00        ....0...b.......
key up   type=0x3  which=0x0  state=0x0  scancode=0x0  sym=0x12fc  mod=0x0  unicode=0x0
00950098   03 00 00 00 30 fc 12 00 62 00 00 00 00 00 00 00        ....0...b.......
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 8, 2011

I put in a new optype "internalMethod" which was like "methodWithThis" except
that it didn't push TPM/TPD and on exit wouldn't pop them, then I realized
that this could be done with regular forth ops, there just has to be a
syntax that allows forth ops which are defined within a class to access the
member variables of the current 'this' object.  Maybe within an forthop
definition which is inside a class definition a leading period will cause
the following symbol to be treated as a member variable of this class.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 4, 2011

I added the ability to append forth text files to the forth executable, so
that you can create forth applications that don't need external files.

o at startup, the executable file is scanned starting at the end for markers
  that show that there are appended files and their names, the shell records
  these names and their positions in the executable file
o ForthShell::PushInputFile checks its filename parameter against the list
  of appended files and will use the appended file if it finds it instead of
  opening an external file
  * there is a potential gotcha here - ForthInputFile will read to the end of
    the file if it doesn't hit a 'loaddone', so if you append a file which
    doesn't have a loaddone it could keep reading past the end of the appended
    file and read garbage
o forth will now load app_autoload.txt if it exists instead of forth_autoload.txt.

There is a utility forth script make_archive.txt which can append files to the
forth executable in the proper format.

While debugging make_archive.txt, I kept getting a crash on 'bye' due to
heap corruption.  It was because when I made some thread support changes a
while back, I wasn't specifying the main threads param and return stack sizes
explicitly, so it was getting the defaults, which is 128 longwords for each.
This is normally enough, but the make_archive code had several long local
buffers eating up rstack space, so the return stack was overflowing and
corrupting stuff beyond it.  The outer interpreter only checks under/overflow
between top level ops, so the overflow was never caught.

I also found that files that are loaded are kept locked until forth exits, I
know that this wasn't the case until recently, because when creating scripts I
usually just keep switching between forth and the editor without exiting forth.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 2, 2011

I added the ability to append a set of files to the forth.exe image,
I changed ForthShell::SetCommandLine to gather the list of files.  I made a
test file named spud.exe in the sandbox which has forth_autoload.txt and
asm_pentium.txt appended to it, it gathered the file list successfully.

Remaining to be done:
- create a utility for appending files to the forth image
- change ForthShell::PushInputFile to check the input filename against its
  list of internal files and open an internal file if one exists with the
  same name

0x00000  forth.exe (length=0x59000)

0x59000  data from forth_autoload.txt (length=0x1332)
0x5a332  0x00001332
0x5a336  0xDEADBEEF
0x5a33a  "forth_autoload.txt" (length=0x12)
0x5a34c  0x00000012

0x5a350  data from asm_pentium.txt (length=0x6cf2)
0x61042  0x00006cf2
0x61046  0xDEADBEEF
0x6104a  "asm_pentium.txt" (length=0xf)
0x61059  0x0000000f

0x6105d  0x00000002
0x61061  0x34323137
0x61065

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 29, 2011

I got the SDL audio callback coded in forth assembler working, just producing
a tone computed by incrementing an 8 bit sample by 1 every sample time.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 28, 2011

I added the fast hash function and unsigned multiply (32*32 -> 64) ops.

While looking at the assembler version I noticed that it has implementations
for most of the file ops, but when I looked at them I realized that unlike
the C versions, they call the clib functions directly, while the C++ version
goes through the shell wrapper calls which supports client/server operation.

A bigger problem is that the C++ version ops use the GET_ENGINE, which at
some point I changed from being pCore->pEngine to ForthEngine::GetInstance(),
I don't remember why I did that.

cvs diff -r 1.3 -r 1.4 ForthInner.h
The 1.4 log message is 'More struct work' and is from 4/15/2007
The 1.3 log message is 'Start adding user-defined structure support.' from 4/7/2007

I can think of 2 probable reasons:
1) I was on a 'must use singleton pattern' kick
2) In the same change I had also changed the definition of pEngine from ForthEngine* to void*,
   maybe the change had something to do with whatever that was about
   
To fix the file op problems, I'm going to try to stick a table of file operations
in the shell, and put a pointer to them in the core state, the forth fileops
will all dispatch through the table.
The client/server version of the shell will replace that table with remote
file access functions.
After a little debugging, it works fine in regular and turbo mode.

I made the same change on the client/server version, it works fine.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 25, 2011

I was thinking of changing vocabularies to be special objects, something
like class objects.

The overall idea was:
o eliminate the vocabulary specific varops: removeEntry, entryLength, numEntries,
  and getClass, replace them with methods on the vocabulary class
o have each class object have an op that handles when the object symbol
  appears by itself (IE 'forth' or 'assembler') - most classes would use the
  standard op, which would implement just default, fetch, store and ref.
  The one for vocabularies would have its default action be setting the
  top element of the search stack to this vocabulary.  This op is what would
  be compiled as the first and only op for global instances of this class.
  ? what about local instances
  This might not be such a great idea, and the only thing it buys us is being
  able to keep support traditional forth search order ops like also/only/definitions
  
There is a similar problem here between vocabulary objects and class object -
the instances of these objects are globals, and their symbols have special
meanings - 'object' by itself defines an instance of an object reference, it
doesn't leave the 'object' class object instance on TOS.

Also, how do you declare a reference object for special classes like vocabulary?
If you use the 'vocabulary' keyword, it creates a new global vocabulary, not
an empty object reference variable like other standard class name symbols.

This requires more thought.  Maybe vocabularies are fine as is.  The way
that vocab operations are done using varops does seem like a kludge though.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 22, 2011

+ fixed the bug where global object arrays had a redundant element size field,
  it was a cut-and-paste error, ForthClassVocabulary::DefineInstance was cloned
  from ForthStructVocabulary::DefineInstance, and doStructArray DOES have an
  element byte field.
+ fixed the bug where initMemberString in turbo mode inited the string to
  contain one garbage character
  
It seems that many, if not all exceptions are causing Forth to exit.
-> the main loop was not handling the result case for kResultException, fixed.
   I'm guessing that previously an exception set the result to kResultError.
   
There is a crash in turbo mode if you do CLASSNAME.new, it doesn't happen in
non-turbo mode, and 'new CLASSNAME' works in turbo mode.

: zoo object.new ;
turbo> describe zoo
zoo: type UserDefined:4f value 0x200004f 0xa (user defined forthop)
  00d51520  00:000036    vocabToClass
  00d51524  03:000000    object
  00d51528  5b:000004    MethodWithTOS    4
  00d5152c  00:000018    _exit

Stepping through in turbo mode:

12f704	02:00004f	zoo
d51520	00:000036	vocabToClass
d51524	03:000000	object
d50068	00:00002e		_doClassType
d51528	5b:000004	MethodWithTOS(4)
d51530	cd:cdcdcd	?huh?

Somehow after MethodWithTOS(4), which should be the 'new' operator, the IP has
been incremented by 8 instead of 4.
When we get to _methodWithTOSType, IP is d5152c, which is correct.
At the end of _methodWithTOSType, it jumps to interpLoopExecuteEntry with
the allocateObject opcode 1B7 in eax, it figures out that it is a builtin op,
but that the op is only implemented in C++, so it calls extOp, which loads the
opcode from ecx-4, so it is getting 5b000004, then it masks off the top byte,
giving it opcode 4, so it executes the C++ version of 'lit', which advances the
IP by 8 instead of 4 since it has an immediate argument.

The problem is that extOp is grabbing its opcode from ecx-4 instead of using
the opcode which is already in eax.  This should fail for anything which calls
interpLoopExecuteEntry, so I'm guessing 'execute' probably has the same bug.

In this particular case, ebx has a copy of the opcode we want executed, there
must be other cases where extOp gets called and the opcode isn't in ebx.

I changed extOp to take the opcode in ebx, the optype routines already were
using ebx for the opcode, I just had to change a few spots in the inner
interpreter to use ebx instead of eax.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 21, 2011

If I execute "object.getClass" twice, the second time results in a return
stack underflow.

object.getClass  // should return the 'class' class object
class.getClass   // should also return the 'class' class object

It looks like the underflow only happens in interpret mode.
-> The bug was caused by ForthClassVocabulary::DoOp not clearing the varOp set
   by vocabToClass, so ForthTypesManager::ProcessSymbol was compiling a bogus varOp
   setting op before the last field accessor
   
It looks like global arrays have the element length stored in a long just after
the _doXXXArray opcode, but if you store to element 0 it overwrites it.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 16, 2011

Fixed the crash, in ForthInterface::SetMethod I wasn't taking into account the
fact that methods[0] now holds the class object pointer, so when 'class' overrode
method 0 (delete) it actually overwrote the class object pointer.

Class object stuff now seems to be working.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 15, 2011

While looking at supporting CLASSNAME.METHOD, I noticed a few things in
ForthTypesManager::ProcessSymbol:
- the section for handling when the first token is a pointer/array is ifdefed
  out, there is code which handles the pointer-to-object case
+ the handling for the case where the preceeding opcode was a varop setter
  should be changed to move the varop to just before the last op, not just
  after the first op
+ the vocabulary entries for methods don't have a way for a method to return nothing

At the end of the day, the class object was mostly working, but there is a
crash if you do this:

object.new -> object foo   foo.getClass.show

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 14, 2011

My current thinking on class objects and new:

Each class will not have a 'new' method, the class object for each class will
have a newOp member variable which holds the 'new' forthop for that class.  The class.new
method will just invoke the classes newOp member.

The syntax for object creation will be:

new CLASS_NAME
OBJ.getClass.new
CLASS_OBJECT.new

+ when a class vocabulary is created, it will create a class object, and there
  will be a pointer to the class object in the class vocabulary
+ class vocabulary destructor will delete class object
+ the class object will have:
  o a pointer to the class vocabulary
  o the new operator
+ there will be a class.setNew method
+ there will be a class.new method
+ the header field of each interface will point to the class object
+ there will be a default new forthop _allocObject, which will take a class vocabulary
  pointer, will use the class vocabulary to get the storage length, will
  malloc storage of that size, and will push the allocated storage address
+ the 'new' forthop will need to be implemented
+ all 'class' methods will have to be changed, since 'this' data pointer is
  no longer the class vocabulary pointer

When I tested this, there was a crash in 'implements:' because it was creating
an interface, but wasn't passing the class vocabulary to the interface constructor,
and now the interface constructor uses the class vocabulary to get the class
object since it stores the class object pointer in the methods table header.
I don't know if there are things which rely on non-primary interfaces having
a null defining class.

Bugs that came up during testing:
+ there was a slight difference between the text output of classtest.txt in
  turbo and regular mode
  -> classtest.txt prints out an uninitialized string variable
- classtest.txt had an error message complaining about structs not having
  the expected size - this may not be a new error
- classes are not automatically derived from 'object'
- the predefined classes & methods don't have the correct return types
+ CLASS_OBJECT.new does not work
  ? is CLASS_OBJECT.METHOD needed
  - this will need to work in both interpret and compile mode

CLASS_OBJECT.METHOD doesn't work because the op which has the class name
symbol is the op which defines an instance of the class.  There is no op
defined which returns the class object like a global variable.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 13, 2011

I added return types to builtin-class methods.
I have currently defined the 'new' and 'getInterface' methods to methods of
'class', I probably have to rethink that.  My thinking is that 'new' shouldn't
be in the methods table, because you would never call .new on an instance of
an object, and you need to call .new before you have any instances of an object.
Maybe 'new' is not a regular method at all, it is an op that is part of the
class object - this would argue for having a class-object that is separate
from the class vocabulary

The good thing about the current arrangement is that for a large number of
classes the existing class methods would be fine, but it won't work for all
classes.  The 'class' class methods should be universal:
  getName
  getSuper
  getVocabulary
  
class.new really doesn't belong there.
class.getInterface also isn't universal, a type might want to return a
different data pointer for different interfaces.
I really need to think about what gets compiled for the 'new' method.
To have a generic constructor, it needs access to either the class vocabulary
or some class object, or at the very least the object storage size.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 11, 2011

I added most of what is needed to have predefined 'object' and 'class' classes.
What remains:
1) Make ForthTypesManager::ProcessSymbol handle the CLASSNAME.CLASSMETHOD case
2) Change ForthTypesManager::AddBuiltinClasses to define the return types of
   the predefined class methods
? Is there a chicken-and-egg problem here - object.getClass method needs to
  be defined to return an object of type 'class', but class.getInterface needs
  to return an object of type 'object'
  -> not a problem if we predefine the classIndices for all builtin classes
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 10, 2011

I need to document how to implement methods in assembler.  I think that all
that is necessary is to pop TPD & TPM off the return stack.

Can non-public methods be coded to not push/pop this?

What is created in memory when a class is created?

'class' op compiles (also done by ForthEngine::AddBuiltinClass)
  0  _doClassType opcode
  1  ptr to vocabulary for class

In order to add the 'class' type, I need to provide some way to get to the
class vocabulary or class object from an object.  The only thing an object
reference has currently that connects it to its class is the method table pointer.
I'm thinking that the way to do this is to put either the class vocab pointer
or the class object pointer into the method table, or maybe just preceeding it.

What exactly is a class object?  Is there any reason that the data pointer
for it shouldn't just be the vocabulary pointer?
If the class/object system was separated from the forth vocabulary implementation
it might make it easier to implement/extend more of it outside the C++ kernel.

What does class.getClass do?

What are the forth objects that exist at startup?
  'object' class object
  'class' class object?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 8, 2011

I added the 64-bit comparison operators as well as lmod and l/mod.
If I ever decide to do assembler versions of the 64-bit ops, there are asm
version of multiply & divide in MS Visual Studio 2003/vc7/crt/src/intel

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 6, 2011

I added partial support for 64-bit integers:

o I added 64-bit literals to outer interpreter, add 'L' or 'l' to end of an
  integer literal to make it 64-bit
o I added 64-bit ops:
  l+ l- l* l/ i2l f2l d2l l2f l2d %lld %llx
o I added the 'long' datatype

: test10s  1 -> int v  30 0 do v 10 * -> v v %d %nl loop ;
: test10l 1l -> long v 30 0 do v 10l l* -> v v %lld %nl loop ;

Not done:
o comparison operators (needed)
o offset operators like 1+L (not needed)

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 20, 2011

Document these ops:
  class:  ;class
  method:  ;method
  returns
  doMethod
  implements:  ;implements
  union
  extends
  sizeOf   offsetOf
  new
  initMemberString

I'm thinking that methods which you want all objects to handle should be done
by adding a single method 'process', which takes:
 1) interface index
 2) method index
 3) arguments (should there be an argument count on TOS?)

Methods which all objects must support would be made a part of the 'common'
interface, and would include things like:
o get interface
o serialize
o convert to string

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
December 12, 2010

Back looking at class stuff.  I am currently thinking about how to implement
class objects.  Class objects would have methods that you would want to apply
to all objects, like construction/destruction, object display, parent class,
class name.  Generic container class implementation could be simplified if
certain operations could be handled using the same method in all classes.
It would also avoid having duplicate names for class methods in every class.

I think there is a name collision - "object" is both a builtin generic object
instance defining op (like "int" or "float"), it is also a class vocabulary.
-> it looks like the one in forthops is redundant and is never called, I commented it out

How things work as of today:

---
class: CLASSNAME
o defines a class vocabulary
o compiles:
  _doClassType
  <ptr to class vocabulary just defined>
  
When executed, _doClassType calls pClassVocab->DefineInstance, which normally
just defines a global/local variable or a field with this class type.
NOTE: this does NOT create an instance of this type, it just creates a
 methods/data pointer pair which are initialized to NULL
 
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 7, 2010

I added 2 things:

o you can now explicitly specify vocabulary name as in
	VOCABNAME:OPNAME
  Explicit vocabulary specification can be used with global structures:
	VOCABNAME:INSTANCE_NAME.FIELDS
	
o you can cast the top of stack to a class/struct pointer
	<TYPENAME>.FIELDNAME
	
I was originally going to use (TYPENAME), but that would have complicated
the current parenthesis code, which is in ForthShell and ForthEngine.  The
current cast code is isolated to ForthTypesManager::ProcessSymbol.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 30, 2010

I added assembler version of floating point comparison operators.

I had started to add thread support but wound up backing it out when 
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 28, 2010

I spent some time trying to get ForthMidiExtension to work.  There is a crash
that happens when I open a midi input port.  The overall situation is:
 ForthMidiExtension::OpenInput
  winmm.lib::midiInOpen
   ForthMidiExtension::MidiInCallback
    ForthMidiExtension::HandleMidiIn
    ... crash ..
HandleMidiIn and MidiInCallback appear to be fine, the crash happens after
MidiInCallback returns but before midiInOpen returns.
The PC is 0 and there is no valid call stack (why?)
I ifdef-ed out the forth related stuff, all forth does is call midiInOpen,
the callback doesn't do anything with forth, and the crash is unchanged.
After we return from ForthMidiExtension::MidiInCallback we are in dissassembly
land and it looks like we are in a simple wrapper, the PC becomes zero when
the next return instruction happens.  So why isn't the return address where
the callback wrapper expects it?
After I get the crash 2 or 3 times, the program hangs on startup without
ever getting to main.  The call stack shows many levels of calls in ntdll,
kernel32, winmm, xgusb and myokent dlls.  After this I can't start the task
manager and many programs won't startup either.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 21, 2010

I ported the kforth assembler to this forth, intending to replace gforth, but
I can't get it to generate the correct code for  "edi jmp," which is needed to
return to the inner interpreter.  I was interested in it mainly because I
haven't found any real documentation for the gforth assembler, particularly
how addressing modes work.  I finally gave up on the kforth assembler.

- figure out and document addressing mode syntax in gforth assembler
  - create assembler tests
- figure out and document gforth assembler control structures
  
+ fixed a bug in my port of gforth pentium assembler that was leaving zeros
  on the stack after assembling code

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 16, 2010

+ I added conditional compilation support words - #if #ifdef #ifndef #else #endif

- I tried to add inline assembly ops, but kept running into problems - I need
  to find out more about how to use the gforth assembler
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 4, 2010

I added r[ and ]r, which are used for variable numbers of arguments, and I
added some definitions which use them which build tables of the basic types.

I've mainly been working on SoftSyn2 for the past 7 months.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 1, 2009

BOOL CForthGuiAppDlg::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
  nID: id of the control
  nCode: tells how to interpret pExtra
  pExtra:
  pHandlerInfo:
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 28, 2009

Did a quick look around at ways to support dynamic dialogs.  These are the
ways I found:

1) use standard GUI wizard to create a crapload of controls which are all
   initially hidden, unhide them when you need them
   + least complicated initially
2) use OnCmdMsg handler and process the command messages
   + most flexible
   - requires a lot of knowledge about control messages
3) use ON_CONTROL_RANGE in the message of a dialog class to map a range of
   control IDs to a specific handler
   + could be combined with method 1
4) dynamically build the message map at runtime (Dr. Dobb's article tells how)
   - can't easily add a control after dialog is visible
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
October 18, 2009

Been away for a few months.

Did some thinking about adding threads to forth, in particular how this
would affect the server, and the different forth use scenarios (standalone
console app, script support in local apps, script support in remote app/game)
and I think I know how to proceed.  The details are in ForthThreads.txt and
ForthServer.txt.

The first step will be to create a good set of backups.

o The main loop in ForthShell::Run will be removed, most of its functionality
  will go into a new method ForthEngine::Update

o ForthEngine will be responsible for managing thread lists or queues

o ForthClient will be changed to do its console fgets in a separate Windows
  thread

o ForthServer methods which send messages to the clients will be broken in two,
  with the part which waits for the client response and then process it being
  removed and put in a single common client response processing method

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 1, 2009

DOHHHHHHHHHHHHHHHHHH!
The problem with the DS server is that recv always returns SOCKET_ERROR until
it gets the requested number of bytes...
Removing that made the DS server work fine...

Can't run forthtest.txt, it uses "demo" which is defined in forth_autoload.txt,
and forth_autoload.txt won't load on the DS because it uses the "system" op.
-> See if system op can be made to run easily on the DS
? Maybe make it a shell operation, like the way file operations are?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 19, 2009

A quick overview of the windows client:

  init winsock
  create ConnectSocket  (AF_INET, SOCK_STREAM, 0)
  fill in ClientService with IP address of server, port 27015
  connect to server
  if connect worked
    create pMsgPipe    ForthPipe( ConnectSocket, valid messages are in kClientMsgDisplayText...kClientMsgLimit )
    push stdin on top of inputStack
    while !done
      get a message from server
      process message
  cleanup
  cleanup winsock
  exit

A quick look at ForthDS.txt and ForthNotes.txt shows that the last known
working version of Forth.NDS was on May 31, 2009.

The source files which have been modified after that date are:
modified						rev		revDate
jun4	ForthInner.h			10		may25
jun6	ForthInput.cpp			6		jun19
jun6	ForthInput.h			6		jun19
jun23	ForthInner.cpp			16		jun27
jun28	ForthShell.cpp			18		jun27
jun28	ForthShell.h			13		jun27
jul1	ForthMessages.h			1		jun28
jul10	ForthOps.cpp			25		jun27
jul12	ForthPipe.cpp			1		jun28
jul18	ForthPipe.h				1		jun28
jun30	ForthServer.h			2&3		jun28			1	jun19
jul1	ForthServer.cpp			2&3		jun28			1	jun19
-------------------------
jun29	ForthServerMain.cpp		2		jun28			1	jun19
-------------------------
jul1	ForthClientMain.cpp		2&3		jun28			1	jun19
jul2	main.cpp				2		jun28			1	jun19

It appears that I really only have a snapshot of June 19, but the changes between
May 31 and June 19 seem to all be related to Thumb versus Arm assembler changes,
not networking changes.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 15 2009

The current use of bracket to switch into interpret mode seems like a waste
of a potentially very valuable synctactic element for a very limited use.
I think it would be better if "[" was treated like a special character by the
outer interpreter, to help disambiguate operations on array members from
operations on the array itself.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 1, 2009

Got a lot of work done in the windows version of client/server, details are in ForthNotes.txt:

o file IO goes through the shell, and works for client/server
o fixed a bunch of existing client server bugs
o broke out client/server communication into ForthPipe

Ugh, when I brought the DS forth server up, after it connects it gets an
error back from the first recv call! DOH!

------
Server									Client

connects to access point
waits for a client to connect
										connects to server
										waits for a message from Server (forever)
accepts connection
sends SendLine("ok>") message
calls recv to get reply
recv returns error

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 30 2009

Looked at the "load blah.txt" bug - what is happening is that after trying to
load a non-existant file, there is a one line delay between when you send a
line to the server and when you get the response.  This delay increases by one
line each time you try to load a bogus file.

The problem appears to be that right after the server sends a "StartLoad"
message, it sends a "SendLine" message, since it is done processing the
line that had the bogus load command on it.

+ adding a kServerMsgStartLoadResult message fixed it

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 29 2009

+ created separate solutions for ForthClient and ForthServer - it just makes
  it easier when running multiple sessions of MSDEV to do client/server debug
  
+ fixed the disconnect problem that happened after loading forthtest.txt -
  the problem was that when a "loaddone" opcode was executed, the client was
  not told to pop its input stack, so it kept on reading forthtest.txt until
  it hit the end of file, at which point it sent a "pop input stream" to the
  server, which caused it to disconnect
  ? should server ignore "pop input stream" when the input stack depth is 1 ?
  
The bug where things get screwy after you type "load blah.txt" when blah.txt
doesn't exist is probably very similar

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 28 2009

+ finished implementing the remote file operations

+ partially tested file operations locally and remotely, they work

o I had switched numItems/itemSize in fread and fwrite ops, I switched them
  back everywhere, I think...
  
o I turned off 64-bit compatability warnings because they harped about storing
  file pointers in ints...

Known differences/problems when using server:
+ sometimes the prompt doesn't appear on its own line
- sometimes there are multiple prompts printed on a line after loading a file
- if you type "load foo.txt" and foo.txt doesn't exist, if you then type in
  the correct name, it looks like the load doesn't happen right away, it
  happens after you enter another console line... maybe...
+ sometimes after loading a file, the server shows the client as disconnected,
  while the client is permanently stuck waiting for the next 8-byte message header
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 27 2009

+ Added ForthPipe abstraction which implements message passing between client
  and server, and converted over old ForthClient/ForthServer to using it, got
  it working on Windows, need to try it out on DS

+ need to add remote file operations using ForthPipe

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 26, 2009

Started reworking server/client messages to be more regular, to make
implementing remote file access easier.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 21, 2009

DS asm inner interpreter is completely switched over to ARM mode.
Also implemented many more ops in assembler.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 19, 2009

Switching DS asm inner interpreter to ARM mode gives us registers r8-r12 to
use.  I plan to use them like this:

@	R0 - R3		scratch		(R0 is pCore at start)
@	R4			core ptr
@	R5			IP
@	R6			SP
@	R7			FP
@	R8			RP
@	R9			builtinOps table
@	R10			#builtinOps
@	R11			actionType table
@	R12			0xFFFFFF (opvalue mask)

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 13, 2009

Got Desmume built on second system, copied over to this system.
What I am doing:
- double-click E:\pat\prj\NDS\Desmume shortcut, which has " --arm9gdb=1234" param
	File\Open	Forth.nds
- double-click C:\bin\devkitPro\insight\bin\arm-eabi-insight.exe
	File\Target settings
		Target:		Remote/TCP
		Hostname:	192.168.1.150
		Port:		1234
	Run\Connect to target
	File\Open E:\pat\prj\Forth\Forth.elf
	Run\Run
	If a popup comes up saying "Make breakpoint pending on future shared library load?",
		click "No" - clicking "Yes" crashes Insight.
If you reload the file in insight, you need to reload it in desmume as well
Sometimes when insight gets stuck, doing reset on desmume unsticks it

All assembler functions need to be preceeded with ".thumb_func", or else
arm-mode instructions are generated, and the cpu misinterprets arm instructions
as thumb instructions leading to crashes.
? is there a way to tell the gnu assembler that the whole file should be thumb
? should I switch the inner interpreter to be arm mode?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 5, 2009

Tried DS Forth in the iDeaS emulator, they say SWI #FD will break into the
debugger, but it didn't work for me.

-> it looks like it only works in ARM code, not THUMB code

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 1, 2009

Looking at ARM assembly language

InnerInterpreter:
	push	{r4, r5, r6, lr}
	mov	r3, #0				// SET_STATE( kResultOk )
	ldr	r5, .L146			// r5 = 0x00FFFFFF
	mov	r4, r0				// r4 = pCore
	str	r3, [r0, #64]		// r0 = pCore
.L143:
	ldr	r3, [r4, #36]		// r3 = IP
	mov	r0, r4				// r0 = pCore
	ldmia	r3!, {r1}		// r1 = next opcode, advance IP
	str	r3, [r4, #36]		// save IP in core
	lsr	r2, r1, #24			// r2 = opType (hibyte of opcode)
	ldr	r3, [r4]			// r3 = opType action routine table address
	lsl	r2, r2, #2			// turn opType into longword offset
	and	r1, r1, r5			// r1 = low 24 bits of opcode
	ldr	r3, [r2, r3]		// r3 = action routine for this opType
	blx	r3					// dispatch to action routine
	ldr	r0, [r4, #64]		// get state from core
	lsl	r0, r0, #24			// mask off top 24 bites
	lsr	r0, r0, #24
	cmp	r0, #0				// keep looping if state is still ok (zero)
	beq	.L143
	pop	{r4, r5, r6, pc}
	
	.align	2
.L146:
	.word	16777215

	
	
eForthResult
InnerInterpreter( ForthCoreState *pCore )
{
    ulong opVal, numBuiltinOps;
    forthOpType opType;
    long *pIP;
    forthop op;
    numBuiltinOps = pCore->numBuiltinOps;

    SET_STATE( kResultOk );
    
    while ( GET_STATE == kResultOk ) {
        // fetch op at IP, advance IP
        pIP = GET_IP;
#ifdef TRACE_INNER_INTERPRETER
        GET_ENGINE->TraceOp( pCore );
#endif
        op = *pIP++;
        SET_IP( pIP );
        opType = FORTH_OP_TYPE( op );
        opVal = FORTH_OP_VALUE( op );
        pCore->optypeAction[ (int) opType ]( pCore, opVal );
    }

    return GET_STATE;
}


	
	
	
// A B + ... (A+B)
// forth SP points to B
//
plusOp:
	push	{r4, lr}	// save r4 and return address
	ldr	r3, [r0, #40]	// r3 = SP
	mov	r2, r3			// r2 = SP
	ldmia	r2!, {r1}   // r1 = B, r2 = SP after popping B
	ldr	r4, [r3, #4]	// r4 = A
	str	r2, [r0, #40]	// save new SP
	add	r2, r4, r1		// r2 = A + B
	str	r2, [r3, #4]	// push r2 (result of A + B)
	pop	{r4, pc}		// restore r4 & return

	
// A B - ... (A-B)
//
minusOp:
	push	{r4, lr}	// save r4 and return address
	ldr	r3, [r0, #40]	// r3 = SP
	mov	r2, r3			// r2 = SP
	ldmia	r2!, {r1}   // r1 = B, r2 = SP after popping B
	ldr	r4, [r3, #4]	// r4 = A
	str	r2, [r0, #40]	// save new SP
	sub	r2, r4, r1		// r2 = A - B
	str	r2, [r3, #4]	// push r2 (result of A + B)
	pop	{r4, pc}		// restore r4 & return

timesOp:
	push	{r4, lr}	// save r4 and return address
	ldr	r3, [r0, #40]	// r3 = SP
	mov	r2, r3			// r2 = SP
	ldmia	r2!, {r4}   // r4 = B, r2 = SP after popping B
	ldr	r1, [r3, #4]	// r1 = A
	str	r2, [r0, #40]	// save new SP
	mov	r2, r4			// r2 = B
	mul	r2, r1			// r2 = A * B
	str	r2, [r3, #4]	// push r2 (A * B)
	pop	{r4, pc}

	
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 31 2009

I switched over to the combined build with an explicit arm7 section, but it
still didn't work, then I found an error in my accept call, fixed that and
now the DS Forth server connects to the PC client and works! Woohoo!

There is a problem when an error occurs while doing a "load", the input
stream is not sent back to the console, so you get a cascade of errors.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 30 2009

I noticed that wifi_example1 and wifi_lib_test, which I got from the dswifi site
both have an arm7 source file which sets up the network.

The DSMI examples (DS midi wifi) all have an equivalent arm7 section.

The nds-examples-20090504\dswifi examples, which I got my Forth Makefile from,
do not have arm7 sections - say huh?
? are they loading an arm7 lib from somewhere
? are they out of date
I did build and run the ap_search and autoconnect examples, and they do work.

I found a website with a NDS tutorial (http://www.double.co.nz/nintendo_ds/nds_develop1.html)
that says that libnds includes boilerplate ARM7 code, and that devKitPro includes
this, but the tutorial wasn't talking about network stuff.

The dswifi forums are down, supposed to be back up June 3 (Wednesday).

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 25 2009

+ rearranged some things to make server-client split easier
+ got client-server working on PC
+ changed build target configurations - before all executables were a single target

Client takes server address as a command line argument, uses localhost if no arguments.

! right now, ForthClientMain doesn't include any Forth files, so the definitions of
  server and client command message numbers are both in ForthClientMain.cpp and in ForthServer.h,
  they are bound to get out of sync...
  
+ got Forth server to compile for DS, but it didn't do anything when I ran it...
  -> there may be more DS wifi hardware setup required
  
server    --kClientCmdSendLine(prompt)->      client
client    --kServerCmdProcessLine(text)->     server
client    --kServerCmdPopStream->             server

server    --kClientCmdStartLoad(filename)->    client

-> means server to client
<- means client to server

-> getLine( ok> )
<- data( load blah.txt )
-> pushStream( blah.txt )
-> getLine()
<- data ( ... )

... repeat previous 2 lines for each line of file ...

-> getLine()
<- endOfFile ( ... )

-> getLine( ok> )

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 24 2009

Forth on the DS will run as a server, with a command shell client running on
the PC.  The client will be responsible for sending text to the server, and
for displaying text from the server.
The first step is to make a client-server version of Forth where both client
and server run on the PC.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 23 2009

Got Forth to compile for the DS under devkitPro.  There are a few new defines
used, _WINDOWS and _ASM_INNER_INTERPRETER.

There are still a lot of warnings when building for the DS.

Replaced MFC containers with STL containers.

+ also, replaced strtime and strdate ops with time and strftime ops, this
  allows more complex formatting and also works on the DS

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 4 2009

Got the SPriG dll to work, I forgot to do SDL_UpdateRects after drawing

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 3 2009

Tried to get SPriG, an SDL based graphics library to work, couldn't get it
to draw a line, after running there was extra junk on stack.
Several params are declared as Uint16, could this be screwing things up?
I thought short params were promoted to long on the stack

Also, sdltest.txt now leaves extra junk on stack.
-> there was an enum that was defined twice - enum definitions rely on
   the new enum symbols being undefined, since during an enum definition
   any defined symbol is just executed

Some of the SPriG functions take a callback, this brings up the question of
adding a general callback mechanism - a way to have callbacks from DLLs
execute forth code.
o it wouldn't be hard to implement this
o may need to support callbacks that return a value and callbacks that don't

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 30 2009

Making vocabularies be a kind of object has some problems - for one thing,
we would probably want them to ignore the "delete" method and "->".
I'm now leaning toward having a set of "class methods", either using a
dotted syntax like "className.new" or prefix syntax like "new className".

class methods:
	new
	parent
	size
	methods
	id
	
Use "classA.id objB.queryInterface" to get the classA interface from objB - the
result is an object - if objB does not have a classA interface, the result is
the null object (double zeros).
	
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 29 2009

I changed the initialization of the builtinOp and optypeAction tables in the
forth core to only be done once in ForthEngine->Initialize.  Previously this
was being done also in ForthEngine::SetFastMode, since those tables were used
for both fast and slow modes.  SetFastMode was not filling in any builtinOps
which were not in baseDictionary, such as builtin classes or user-defined builtins

The next challenge is defining what appears in the builtin classes.  A lot of
functionality is hard to define without making some decisions - like how do
you specify the interface you want to a queryInterface method?  I am leaning
toward defining a classVocabulary class, parented off a vocabulary class,
parented off the object class.

object : NULL
	delete
	data
	methods
	show
	class	(returns a classVocabulary object)
	size
	queryInterface

vocabulary : object
	uses
	also
	? something to undo "also" ?
	only
	definitions
	numEntries
	find
	addEntry
	removeEntry
	* some way to iterate through entries *
		* info about entries - number of longs in data section
	
classVocabulary : vocabulary
	parent
	methods
	classId
	isAbstract
	numMethods

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 28 2009

Messed around with asm version of kernel, got it to use the static tables
opsTable and opTypesTable instead of the stuff in FCore

+ change table init routines to always fill in core optypeAction and builtinOps
  with C versions
+ replace extOp macros with a single extOp routine
+ fill in FCore.numAsmBuiltinOps with # entries in opsTable, and have
  inner interp check against that, and call extOp for entries which are past
  end of table
+ rearrange opsTable to put most routines without asm versions at end, remove
  as many at end as possible
+ change FCore to just have a pointer to opTypesTable instead of the whole table
  in the structure
+ currently assembler version of opTypesTable uses badOp for all optypes for
  which there is no assember version, replace this with something that invokes
  the C version instead - if the optype is truly unimplemented, the C version
  will signal the error
  -> until this is fixed, all optypes must have an assembler version...
+ take advantage of the fact that ESI register is no longer reserved for opsTable

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 27 2009

I started putting in support for builtin classes, then I realized I hadn't
put stuff in CVS in a while

Right now when switching in and out of turbo mode the opType dispatch table
and builtinOps tables in the forth core are re-initialized - I think it would
be better to have copies of asm and c versions of the tables in the core
that were initialized once.

+ get stuff to compile with partially done builtin class support
+ bring CVS up to date
x have asm and c modes use separate tables in forth core
+ replace the extOp macro with a single asm routine that grabs the c routine
  address from the c builtinOps table
? maybe move the majority of c-only ops to the end of the builtinOps table
  and allow the size of the asm table to be smaller
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 26 2009

More fiddling with dynamic dialog creation.

There is a fair amount of functionality in the CWnd class that would be useful
to have available to derived controls - setting position, label text, styles
and so on.  The most convenient thing to do would probably to define a set of
forth classes corresponding to CWnd and the derived controls.  This would
require creating built-in classes, something I haven't done yet.

While working on ForthEngine::AddBuiltinClass I noticed that overwriting a
method probably adds a redundant symbol to its class.
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 24 2009

+ Fixed boundary cases for assembler comparison ops - this should fix "dump".

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 21 2009

Started fiddling with dynamic dialog creation.

Some simple controls could be handled by just adding a OnCmdMsg handler to the
top level generic dialog.

----------
Step 1 - Static text control
CStatic* pStatic = new CStatic;
pStatic->Create( "some text",
                 WS_CHILD | WS_VISIBLE | SS_CENTER,
                 CRect(10,100,100,130),
                 pDialogWnd,
                 controlId );

----------
Step 2 - Pushbuttons
CButton* pButton = new CButton;
pButton->Create( "button text",
                 WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                 CRect(10,100,100,130),
                 pDialogWnd,
                 controlId );
pButton->SetWindowText( "Woohoo!" );
Other button types:
	BS_PUSHBUTTON
	BS_RADIOBUTTON
	BS_AUTO3STATE
	BS_AUTOCHECKBOX
	BS_AUTORADIOBUTTON
	BS_CHECKBOX
	BS_RADIOBUTTON
	BS_3STATE 

I'm not sure what would be involved with doing radio buttons in terms of
grouping them.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17 2009

Need a way for a class to return secondary interfaces...
- implement a generic queryInterface class method
- require individual classes to implement explicit "getInterfaceX" methods

Inside secondary interface methods, how can methods from other interfaces be
accessed?  Possible approaches:

1) they can't - that is what is currently implemented - you could still do it
   manually by creating local objects with the appropriate methods/data pair

2) concatenate all interface vtables, the method number is relative
   to current interface, negative values and numbers larger than the current
   interface method count would refer to methods in other interfaces of this
   class - actually, you would only need negatives, since you could only refer
   to methods defined in previously defined interfaces
   -> that would require that all the methods for each interface are specified
      in one shot - you couldn't define some primary interface methods, then
      implement a secondary interface, then add some more primary interface methods

3) when a cross-interface method is compiled, it is compiled as code which pushes
   the object pointer pair for the target interface and then uses the MethodWithTOS
   opcode type to invoke the method
   
I decided to try out the assembler again, I found that it works, there is a
problem where some ops leave crap on stack when they are done - in particular,
the "next," op leaves 2 zeroes.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 16 2009

Methods returning an object as a non-final selector works...

Stuff to do:
- class/struct support
  - "implements" & "queryInterface"
  - class methods - new/delete/queryInterface/show/
  ? have all classes derive from a base "object" class
  - struct accessor optimizer
- testing
  - more tests of datatypes: locals, structs, classes
  - more automated tests of core forth stuff
- sample block ops
- GUI app support
- assembler documentation and test

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 14 2009

Been off doing other things...
Starting debugging methods which aren't final selectors - I really still need
to define how methods as final selectors work, in particular if the return
value is an array - should I be compiling an array accessor, and should it
use varAction?
o if you want to have varAction work on data inside an object, use an object
  data member as an accessor, not a method
o you can have methods use varAction if you want to code it that way
o when final selector is a method, do nothing about method return type
  ? it feels inconsistent/broken to allow array indexing to be done on non-final
    selectors but not on final selectors...
o a non-final method selector whose base type is byte/short/int/float/double is illegal
! maybe the right choice is to only allow "returns" to take a struct/class type,
  with no ptrTo or arrayOf modifiers.  This is actually the most flexible choice,
  since the method could take an index argument if an array is involved
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 7 2009

+ made turbo versions of most of the file operations

+ made turbo versions of doExitMOp and doExitMLOp - the rstack underflow
  checking doesn't seem to be working, though
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 5 2009

Try loading foo.txt in non-turbo mode, switch to turbo, then do "addressOf kk kookoo",
switch back to non-turbo and repeat - the namb and numb fields of kk were modified
by reading or printing them from turbo mode...

-> the problem was that the turbo version of dfetch was badly broken

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 3 2009

Bugfixing struct and class stuff.

An unrelated bug: if you do "dump" in turbo mode, it displays a different
number of rows of output - it looks like there is one extra row, as long as
the last expected row...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 2 2009

Ugh, my graphics card died yesterday, killing a day.

There is a memory trash bug, it is triggered by LocalIntArray, but I think it
is because the opVal coming in is 0x2004, when it should probably be 4.
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 28 2009

The basic class support seems to be working - I haven't tested many combinations
of member accessors, but I can access members of local and global objects,
including arrays and pointers, and I can invoke methods on objects.

There are crashes running class stuff in turbo mode.

One thing I don't think I implemented is allowing field accessors or methods
on member variables.

I added "returns" op, it doesn't work at the moment.

If you start forth, run structtest.txt, then do "bye", there is a crash
while trying to delete the parameter stack of the current thread.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 27 2009

First field code for object accessors:

+ gobj1.blah					global object
	gobj1			doObject drop
+ pgobj1.blah					global ptrTo object
	gobj1			doInt d@ drop
+ 1 gaobj1.blah					global object array
	gaobj1			doObjectArray drop
+ 1 gapobj1.blah				global ptrTo object array
	gapobj1			dOIntArray d@ drop

+ lobj1.blah					local object
					LocalObject drop
+ plobj1.blah					global ptrTo object
	gobj1			LocalInt d@ drop
+ 1 laobj1.blah					local object array
	laobj1			LocalObjectArray drop
+ 1 lapobj1.blah				local ptrTo object array
	lapobj1			LocalIntArray d@ drop

Most of the broken ones are pointer types - they are all missing the d@.

If we implemented an opcode which added an offset to TOS and then did a fetch,
that could replace the "d@ drop", and could also be useful in struct accessors
whenever a pointer field was used - these usually compile into (offset(N), @).
-> But you don't know if you should use offsetFetch until you process the next
   field, since if it is a method you need both pointers on TOS
   -> There should be a final optimization step
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 26 2009

There is a problem with local and global ptrTo array implementation - an intArray
is used, and the intArray will use the varAction which is meant for the field code...
For example:
	5 -> 4 pFoo.A
compiles into
	lit 5
	->
	lit 4
	_dOIntArray(pFoo)
	FieldInt(A)
and the varAction set by "->" is used by _dOIntArray, not FieldInt.  The code
which compiles field accesses does handle the case where the varAction symbol
is just before the field accessor, but in array access cases the array index
calculating op(s) are usually just before the field accessor.

There is also a general problem with the varAction being consumed accidentally
if there are any variables used in calculating the array index.
The general (ugly) solution to this problem is to require that the varAction
op be placed just before the field accessor:
	"5 -> 4 pFoo.A"		is replaced with	"5 4 -> pFoo.A"

A better workaround might be to use parens:
	5 ->( 4 ) pFoo.A
This looks silly in this case, but might help with cases where the index
calculation uses variables...


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 25 2009

+ added "lsize" - number of longwords in local variables
+ added "dlocals" - displays local variables

Ran into some crashes while testing class support, writing tests to check both
struct and class support.
-> all local arrays were allocating 0 bytes because ForthEngine::SetArraySize
   wasn't being called before calling ForthEngine::AddLocalVar and ForthEngine::AddLocalArray
   
First field code for struct accessors:
+ gstr1.blah					global struct
	gstr1			doStruct
+ pgstr1.blah					global ptrTo struct
	pgstr1			doInt
+ 1 gastr1.blah					global struct array
	gastr1			doStructArray
+ 1 gapstr1.blah				global ptrTo struct array
	gapstr1			dOIntArray
	
+ lstr1.blah					local struct
	lstr1			LocalRef
+ plstr1.blah					local ptrTo struct
	plstr1			LocalInt
+ 1 lastr1.blah					local struct array
	lastr1			LocalStructArray
+ 1 lapstr1.blah				local ptrTo struct array
	lapstr1			LocalIntArray
	
Here is what the rstack should look like when local variables are defined:

ok> : woo hex drstack int aa int bb int cc drstack 5 -> aa 7 -> bb 9 -> cc drstack ;
ok> woo
rstack: 12f844
rstack: 1 3 7 0 12f844
rstack: 9 7 5 0 12f844
The top 3 elements are the 3 local int variables, next is the old frame pointer,
and last is the return IP from woo.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 24 2009

? does the current structure support properly handle the case where the first
  field of an accessor is a pointer to a struct?

Ugh, some of the code assumes object variables have the native flag set,
other parts of the code require that object variables have the native flag
clear...

Why didn't I just have a typeCode bit for "array" - why is there a 2-bit
storage type field with choices none/single/array/illegal?  What does it mean
to have a storage type of none?
-> "none" had been used by enum opcodes to help with a problem with forgetting
   enums, but that had been made obsolete a while ago

I changed the typeCode around to have:
o bottom 4 bits are baseType
  o baseType are the old native types, plus struct
    o object is a baseType, but it is no longer a native
o isArray is a separate bit, there is no idea of single/none/illegal
o the top 24 bits is the stringLen/typeIndex/classIndex
? Are there any changes needed in the assembler code, or is all the typeCode
  stuff always handled by the outer interpreter or C++ only code?

The field accessor stuff will need to be changed, some of it is still treating
object fields as native...

o changed ForthStructsManager to ForthTypesManager
o changed ForthStructInfo to ForthTypeInfo
o changed most uses of Native to BaseType

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 23 2009

The existing struct support handles struct accessors in 3 stages:
1) the first token, either a local or global struct (or pointer)
  -> compile opcode which pushes the address of base of struct
2) intermediate accessors
  -> compile opcodes which add offsets to TOS, or do an indirection on TOS
     for fields which are pointers
3) the final field
  -> compile fieldAction opcode based on the type of field

Things get a little messier with classes, because:
o an object field is automatically a pointer access, a ptrTo object field
  requires a double dereferencing
o a field which is an object needs to be processed differently depending on
  wether the next accessor designates a method or a member field - a method
  will require both pointers, a member will just need one of the pointers
  
Class support status:

-------
- objG.methodB						method invocation on global object objG
	objG
	OP( methodWithTOS, B )
+ methodB							method invocation on current object within method
	OP( methodWithThis, B )
- objA.methodB						method invocation on other local object
	OP( localObject, A )
	OP( methodWithTOS, B )
- objD.methodB						method invocation on other member object
	OP( memberObject, D )
	OP( methodWithTOS, B )
- stuff.objQ.methodB
	...stuff leaving addr of objQ on TOS...
	d@
	OP( methodWithTOS, B )

+ fieldC							member access within method
	OP( memberInt, C )
- objA.fieldC						(objA is local within method)
	OP( localObject, A )
	drop
	OP( fieldInt, C )
- objD.fieldC						(objD is a member variable)
	OP( memberObject, D )
	drop
	OP( fieldInt, C )
- objG.fieldC
-------
Member access and methods outside a method:
- objL.methodB						(objL is a local object)
- objL.fieldC

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 22 2009

+ Some class support is working, I can invoke methods using doMethod, the right
  vtable opcode is executed, stacks look after it is done.
+ "extends" works for classes
- currently member fields don't work in classes

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 21 2009

The next step for class support is to create "new", possible approaches:

1 - new sets a varAction
=========================
Syntax is "new blah"
o blah must be next opcode executed
o a struct/class defining word like blah is immediate, so it can define local
  instances while compiling.  doStructTypeOp/doClassTypeOp would need to be
  modified when compiling to check if the preceeding compiled op was a
  varAction setting op, and if so just compile appropriate code.
  doClassTypeOp:
  if ( state is compile )
    // either defining a local instance, or "new blah"
    if previously compiled op is a valid varAction (IE "new")
      compile blahOp (how do I know blahOp?)
    else
      DefineInstance of blah
    endif
  else
    if varAction is valid
      
    else
      DefineInstance of blah
    endif
  endif
  
  The code to be compiled can't just be the blah opcode - when it is
  executed, 
  ? what is the appropriate code

2 - new is an immediate op
==========================
Syntax is "new blah"
o blah must be next immediate token, on same line
o new grabs next token, and interprets or compiles appropriate code
o the code compiled would be:
  doNewClassOp
  <pointer to class vocab>
  ? what is the appropriate code

3 - struct manager ProcessSymbol handles new
============================================
Syntax is "blah.new"
o stuct manager ProcessSymbol recognizes blah as a class name and new
  as a special token and interprets/compiles appropriate code
  ? what is the appropriate code

In all these cases, we are stuck with the question of what should be
compiled - it can't be the blah opcode.

The minimalist in me thinks that a varAction approach is best, but varAction is
a kludge:
o varActions look like local operations, but use globals
o varActions break making methods be part of a struct accessor chain
o a varAction could be applied to the wrong object/variable
  o the same varAction value means different things for different datatypes
Also, struct/class type ops are currently defining words which eat the
next simple token, and they have precedence

- "sizeOf" and "offsetOf" will only work in interpret mode
  ? change these into varActions too
  
Currently varAction ops are implemented with non-precedence ops, should I
change them to precedence ops?
-> No, I don't think it would really fix the general varAction problems

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 18 2009

+ changed ShowVocab to use ForthVocabulary::PrintEntry

+ Changed "describe" to display the symbols of struct or class vocabularies

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 17 2009

I debugged a bunch of the simple problems with struct support.
	point p
	ptrTo point pp
	5 -> pp.x
The above currently has an exception because it compiles into:
  5 -> pp fieldInt(x)
which results in 5 being stored into pp, leaving the stack empty, then
the fieldInt(x) call tries to get the struct base address from TOS, adds
the offset of x, and then dereferences the bogus result address since
the store varaction was cleared when pp was executed.

----
How can we differentiate between setting the pointer and setting a field in
the struct the pointer references?

A structure/object accessor has the syntax
	start.end
or	start.middle.end	where middle can be many dotted ops

o start always compiles into an opcode which pushes the base address of the data
o end always compiles into an opcode which will actually affect the data, and
  which pays attention to the current varAction
o middle is a series of ops which can:
  o add an offset to TOS
  o do a fetch - replace TOS with the address it points to
  o do an array address calculation: replace a base address and index with the
    address of the indexed element
  o (someday) execute a method with a known return type
If the opcode compiled for start is a pointer var op, it can mistakenly
use the varAction which is intended for the end op.  Also, when methods
can be in the middle ops, the methods could interfere with the varAction.
On a different note, there is a potential optimization for local structs,
where the start op, middle ops and end op are combined into a single op which
is the same as a local variable op.
---

When compiling a field reference using a global pointer, look at the opcode
just previously compiled to see if it is one of (addressOf -> ->+ ->-) and if
so, swap the order of the previous opcode and the global pointer opcode.
But what if this is interpret mode? I guess in interpret mode we could save
the varAction at the start of processSymbol, clear the varAction, and compile
the appropriate varAction op after the first field opcode.

Actually, are there any ops other than the final op which use the varAction?
Not now, but when methods can be in the middle of an accessor chain, those
methods are very likely to internally modify the varAction

The first op compiled in a field accessor is always one of:
o global struct op - just leaves base address on TOS
o global ptr op - leaves ptr contents on TOS
o local struct op - just leaves base address on TOS
o local ptr op - leaves ptr contents on TOS
-> I overwrote the previously compiled varAction op with the first op of the
   field accessor code, and put the varAction op in the first element of
   the field accessor codes, it appears to work fine

I haven't tried complicated accessors where there is more than one level of
indirection.

+ I added "comparefiles" to forth_autoload.txt.

+ Added automated test file autotest.txt, which runs forthtest.txt in
  both slow and turbo mode and compares the output of both against output
  from a known good run
  
Maybe there should be a varAction-setting opcode type...
That would require that the varAction setting opcodes in the kernel be in
their own list.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 16 2009

I started cleaning up the native type support in ForthInner, making them all
do varOp range checking and use a common code style.

When doing "op" I noticed that the old IP gets stomped, and when you execute
a local or global op var it causes an unwanted return
-> these problems don't happen in turbo mode
DOH! the problem was that it was building a 2 op program, the 2nd op was OP_DONE,
and setting this flag makes the inner interpreter exit - I changed this to
use ForthEngine::ExecuteOneOp, which handles this problem.

+ if you use tick inside a colon definition, that definition shows up in the
  vlist, but if you try to interpret, it causes an undefined symbol error
-> I was misusing tick, it doesn't have precedence, I should have used ['] or lit

OP_DO_CLASS_TYPE is the first and only op in a class defining word, it is
followed by a pointer to the class vocabulary.
doClassTypeOp just calls pClassVocab->DefineInstance() and pops the return stack.
DefineInstance will create an object instance of the class type, which could
mean any of:
o creating a global or local variable/array
o adding an object or object array field to a struct or class definition
Global instances have their vtable and data pointers initialized.
OP_DO_OBJECT is the first and only op in an object instance word.

- "ptrTo" doesn't work with global structs
It looks like ptrTo just changes a var/field to act like a dumb int var

+ structs can't be used as local variables because the ops defined by "struct:"
  don't have precedence, so they are compiled and not interpreted at local var
  definition time...
-> fixed

I need to do more testing, documenting and debugging of existing struct
support before I can advance on class support.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 15 2009

What happens at the start of invocation of a method?
The pushing of this on the rstack can't happen inside the method, since the
code which invokes the method must have already overwritten the this pointer.

Let's assume that the 64-bit object is on TOS already, and the current opcode
is a "method-on-TOS" opcode with method field equal to 5.
Pseudocode for "method-on-TOS":
	rpush TP (2 longs)
	pop TP (2 longs)
	fetch opcode for 5th entry in vtable specified by TP & execute
	

NOTE: doExitMOp and doExitMLOp currently are using a single 32-bit field for
the this pointer - that will have to become 2 fields, right?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 14 2009

+ added strdate, strtime which return current date and time as strings
+ added millitime which returns # milliseconds since forth was started

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 13 2009

+ rewrote systemOp to use stdout/stderr redirection, this should allow it to
  work in ForthGUI
-> it does work, but there is a flash of black when the shell runs...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 12 2009

Chasing the "%c" problem in turbo release mode.  To debug in release mode,
create time wasting user op that takes several seconds to run, pause the
program, chances you will be able to find your way into the inner interpreter
loop pretty quickly.  After that just set breakpoints in the dissassembly
window and look at registers.
After printCharOp returns, the top item on the stack should be the saved EBP
pointer to the forth core, instead that entry has been overwritten by the
characters of the string to be written.  The pushing of EBP was done both to
preserve it and to pass it to the C routine about to be called, in release
mode the compiler feels free to reuse the stack storage of its input params
for other uses, in this case as the character buffer to be printed.  The
solution is to push EBP twice.
This change fixed %c/%bl/%nl as well as vlist in turbo release mode.
Output from forthtest.txt looks ok in all modes now.

Idea for syntax for using TOS as a struct address or object: 
classA.method1
structB.field2

One problem with the current scheme for interfaces, where any class can be
used as an interface, is that it makes it less safe to have classes which
have public fields - the programmer is responsible for keeping track if an
object variable of class blah is:
1) referencing an object which is derived from class blah, in which case it
   is okay to access member fields for class blah
2) referencing an object which is not derived from class blah, but which
   implements the blah interface, in which case it is not okay to access
   any member fields
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 11 2009

Added a "is method" bit to the type code field (pEntry[1]) for struct vocab
symbols.  In the future this will allow the existing bits of the type code
to indicate the return value for the method, so that methods don't have to
terminate a structure accessor string.

Also added a new native type, kBaseTypeObject, which will be a 64-bit field.
When I was putting it in, I found that the global array ops had never
been used, at least in non-turbo mode - their optable entries held the
ops for single variables.

Also, before I made my changes I noticed that running release in turbo mode,
there is an unhandled exception which happens when you do "vlist".
In debug mode, vlist is okay but any immediate op has a "bad opcode"
error.

-> it looks like the assembler version never could have handled immediate
   builtin ops - did the handling of precedence change after the assembler
   version of the nucleus was written?  -> yup!
There was a similar problem with immediate user defined ops, I just made
them use the same table entry as non-immediate user define ops, and I did
the same with "user code" immediate ops, but I haven't tested those yet.

Debug version in turbo mode now runs forthest.txt with no errors and what
looks like valid output.

Release version in turbo mode still breaks on vlist and fails pretty quickly
when loading forthtest.txt
-> %c, %nl, %bl cause a "No Error" failure!  They do display the character
  %nl and %bl just push a char and call %c, %c just build a two char string
  and calls %s, so why does %s work and these other ops fail?
? What does a "No Error" failure mean?
-> the exit status from InnerInterpreterFast is something other than kResultOk
   or kResultDone, but core->error was not set to an error code
The character is always printed correctly.
The problem goes away if I change printCharOp to either use a larger character
buffer or if I remove the SPOP that copies the character from the stack to
the first byte of the buffer.
The problem does not go away if I redirect output to a file.

All of this really emphasizes the need for an automated test suite - changes I
have made in the distant past have broken things, and I have no idea what
change broke what feature.  DOH!

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 10 2009

Decided to tackle a couple of problems using forth, to see what it needs to
solve real problems.  The problems were:

1) merge two equal sized files, which have missing data (zeroes), which come
   from different torrents (rock band .flac file collections)
   mergefiles.txt & mergeall.txt
2) merge guitar pro song collections - there are multiple versions of many songs,
   and the files in different collections sometimes have the same names and
   versions
   gp.txt & narf.txt

Overall, it worked out pretty well.  The main thing that stood out is that I
need to spend some time documenting the functionality that is already implemented.

One missing thing is the ability to iterate over all files in a directory tree,
I got around this by creating a list of files using the cygwin shell and then
turning the list of files into forth files.

Dropped off Xbox-360 today at UPS to fix red-ring-of-death.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 9 2009

+ changed struct/endstruct/enum/endenum to struct:/;struct/enum:/;enum

+ got incomplete class definition time stuff to compile

- there are no examples of "union" - has it ever been tested?
-> test & document its usage

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 7 2009

The ways an interface gets defined:

o the primary interface is defined two ways:
	1) when the "extends" clause is processed, the methods of the defining
	   class are copied
	2) when a method is defined, it either replaces an existing method or is
	   added as new
o secondary interfaces are defined:
	1) when the "extends" clause is processed, the secondary interfaces of
	   the defining class are copied
	2) when the implements clause is processed, if the named interface does
	   not already exist, the new interface is initialized to have the same
	   number of methods as the named interface, and all of the methods are
	   marked as virtual and filled in with a dummy (error) method
	3) when a method is defined inside an implements clause, it replaces the 
	   named method in the interface
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 4 2009

A problem with methods and also struct op fields is that there is no concept of
a return type, so they can't be followed by a dot accessor: objectA.methodZ.fieldQ
doesn't work because we don't know the struct type returned by methodZ, so we
don't know the struct vocab to lookup fieldQ.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 3 2009

One potential gotcha with just extending struct stuff to do classes: the struct
stuff currently does allow structs to be allocated as globals or on the stack.
? Is this really a problem?
We should probably leave structs as is, it would be a pain to have them always
have a dummy vtable on TOS.

Classes should be able to extend a struct, but should a struct be able to
extend a class?  If so, it should just be taking the data members.

When a local class variable is declared, should code be generated to set its vtable?
It would be redundant, except in cases where you only set the dataAddress part of
an object variable.  In those cases the vtable would have to be explicitly
initialized.

Base methods are methods which every class implements, these are methods
in class Object.

-> make a list of class methods and base methods
class.new			...		dataAddress methodsAddress
	this should be an opcode type
struct.sizeof		...		sizeofStructInstance
class.sizeof		...		sizeofClassInstance
object.sizeof		...		sizeofObject
	this should be an opcode type, or be compiled as a constant
class.methods		...		methodsAddress
object.methods		...		methodsAddress
class.numMethods	...		numberOfMethods
object.numMethods	...		numberOfMethods
object.class		...		classDescriptor
	? what should the classDescriptor be?
		1) the struct index
		2) address of something
	what can you do with a class_descriptor? is there a class class?
object.delete
class.parent
object.print
object.queryInterface

? should base methods have a single vtable entry
Note: object.methods could either be:
1) at runtime, fetch the methods field from objects
2) fetch the methods field from the declared class of object (which might be
   a superclass of the actual class of object
We probably want object.methods to fetch the actual object methods field, and
have class.methods be used to fetch the methods field of class
Maybe there are 2 predefined classes at startup, "object" and "class", with
"class" derived from "object".

object methods: delete class methods data sizeof print
class methods: new sizeof methods name parent
Ugh - class.methods doesn't returns the vtable of the class object, it returns
the vtable of objects of its class...
Maybe it should be called "vtable"?  This is bound to cause bugs...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 1 2009

Is there any reason to create a ForthClassVocabulary and manager instead of
just expanding the ForthStruct stuff by adding methods?

Every class defines:
1) an interface
2) a data structure
The interface may be empty, in which case this is an old-fashioned struct.
The data structure may be empty, in which case this is an abstract interface.

How do extends/implements work and interact?
Maybe only the primary interface can extend another class, "implements" means
that this class implements the exact interface of an existing class as a
secondary interface.
When a class extends another class:
o it inherits its implementation
o it inherits any interfaces that it implements, but it may override any or all of the
  implementations of those methods.
When a class implements the interface of another class:
o it does not inherit any implementation from that class
o it does not automatically implement interfaces that the base class implemented

What changes are needed to ForthStructVocabulary?
- add method count
- add abstract method count
- add ?list? of interfaces

Should class methods be assigned normal opcodes, and the vtable contain opcodes,
or should the vtable just hold IP addresses?
Is there a need to have class methods be native opcodes?
o this might help implement classes which are defined in the kernel
o this might be useful when calling a method from another method in the same class
-> make vtables hold opcodes instead of IP addresses

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 31 2009

A class has a primary interface, which is the set of methods which it declares.
A class may have secondary interfaces, which can be gotten by querying.

When a class doesn't have distinct methods of its own, and just implements a
previously defined interface, will that pose a problem?  IE how can the primary
interface for a class be defined using the "implements" keyword ?
-> the endclass word will handle this when the primary interface has 0 methods

When you extend a class which has secondary interfaces, can you override or
extend the secondary interfaces?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
January 30 2009

What about making all object references be a pair of pointers, a data pointer
and a vtable pointer?  What would this look like?
+ this would allow a simple implementation of multiple interfaces
+ arrays would not need a redundant vtable field per element
o object variables are just a pointer pair
o object reference on TOS is a pointer pair (not a pointer to a pointer pair)
o "this" in thread context is a pointer pair

Maybe all interface definitions which don't have an "extends" statement implicitly
extend the interface "object".

Maybe a class definition could be like:

interface blather1
  talk
  ramble
endinterface

interface blather2
  extends blather1
  spew
endinterface

struct sBlatherer
	...
endstruct

class blahBlah blather2 sBlatherer
 ... method definitions for
-> having "extends" at the class level would make implementation easier
-> "extends" should be available in both class and interface definitions
-> it probably is better to have the class define its data members, instead of
   requiring that its data members be defined in a seperate struct
   
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 18 2008

More ForthGUI work.

Noticed that the line:   "dir" system
produced no output - the problem is that the directory was sent to standard out
for the console.
? Is there a way to redirect standard out to a function ?
SetStdHandle can be used to redirect standard in/out/error.
? Is there a way to connect a handle to a function
! The easiest thing to do might be to redirect output to a temp file
  inside the "system" op, then after interpreting the string write the output
  to the thread output routine

Also "load" does not do anything.
-> The forth console app calls shell::Run, which has a loop that keeps calling
   GetLine and interpreting it, this is what does the loading.  The forth
   GUI app doesn't call shell::Run or shell::GetLine, it interprets the edit
   buffer when the edit control OnOK handler is triggered.
   Maybe the solution would be for the GUI app to check the input stack depth
   after interpreting a line, and keep doing GetLine/interpret until the input stack reaches zero.

I added the above code to ForthGUI.  forthtest.txt has an error in it, and this
was causing a crash.  I tried to fix it by adding methods to create and delete
all the forth related objects, and these were called when InterpretLine returned
a fatal error result code.  This is currently failing because the engine constructor
saves its this pointer to a global instance pointer, and it asserts if that pointer
is already not null.
At some point I decided to treat the engine as a singleton, and for some
reason I changed the GET_ENGINE macro to use the singleton, but most cases
where it is used the code already has access to the engine, for example forthops
can get the engine from the forth core state.
For now, I am just clearing the engine global instance pointer inside the engine
destructor.  I also had to do this in the ForthTypesManager, which also used
a singleton.
I think the idea was that there should only ever be one engine object.

I get a fatal error when I load sdl.txt, then sdl2.txt, and run "test".

ForthShell::Run
  ForthShell::InterpretLine
    ForthEngine::ParseToken
    ForthEngine::ProcessToken

ForthShell::Run
	calls ForthShell::InterpretLine in a loop until it returns false

ForthShell::InterpretLine
	calls ForthShell::ParseToken and ForthEngine::ProcessToken in a loop until input line is empty
		
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2008

ForthGui program now mostly works
- "bye" does not exit program
- there is no error output
  -> look at ForthShell::ReportError
  -> fixed
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2008

+ added resetting of console output routine, so app can set default output routine
+ tried to make output more simple/unified by combining user data pointer and
  file pointer
  
It might be nice to have a way of pushing/popping an output context.  There
are 3 overall types of output context, here are their data:
1) external function
  - function address
  - function data address
2) file
  - file pointer
3) user op
  - opcode
  - data address

One way to unify these would be to have an output context structure:
	void*	function address
	void*	data address
	long	opcode

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 19 2008

+ added appending to GUI output pane

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
November 23 2007

Haven't been working on forth since June.  I did add to help.txt.
Going to to try to:
1) add a string->long map feature, use it for help
2) maybe get the Forth GUI working.

The only problem with a map is that it would make a "save state" feature
much more complicated
-> make the map output be offsets from the DP, not absolute pointers
-> come up with a general solution for dynamic data

If I remember correctly, the hangup with doing the GUI was not knowing how to
incrementally get text output to the edit output pane, I only know how to fill
the whole edit pane at creation.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
June 13 2007

Not much progress over the last month:
- I took a quick look at class support, no amazing revelations occured
- I started creating the GUI for a programmable calculator
The projects I would like to wack on this summer:
- programmable calculator
- synth2k
- graphics sandbox
  ? based on sdl, or win32 ?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 6 2007

I tried adding a lookup map to vocabularies to speedup loading.  Right now
it is ifded-ed out with MAP_LOOKUP.  It seems to be unnecessary, since in
the release version loading the pentium assembler is instantaneous.  The
slowness of loading in the debug version is probably mostly caused by all
the TRACE message output together with the slowness of debug code.

Removed "code" setting of top search vocab to "assembler".  With this gone,
there was no reason to have "assembler" vocab in kernel anymore, so I removed
it and added it to asm_pentium.txt.

Added a serial number to vocab stack searches to eliminate redundant failed
searches of the same vocabulary.  It worked for everything until I tested
sdl2.txt, and it looks like it failed the first time it tried to lookup
an enumerated type.
-> false alarm, sdl2.txt just wasn't adding sdl to the search order
? maybe make vocabulary stack always have at least 2 entries, and the
  bottom entry is always forth?
  
When this works I should rip out the vocabulary search chain since it is
no longer used.
-> No, the search chain is still used, but only by the structs vocabulary.
-> Move the search chain down to the structs vocabulary
  -> I should probably create a chained vocabulary type, since classes will
     probably want to be able to extend another class, like structs
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 5 2007

Added fprintf/sprintf/fscanf/sscanf - they work except that fprintf/sprintf
can't print floating point numbers - there may be some expectation that
fp numbers will be passed in fp registers, but that would seem to be a
pain for variable numbers of arguments.
One hokey thing is that you have to pass the number of variables to be
printed as the last argument.
Example: stdout "%d,%d" 5 7 2 fprintf

Eliminated precedence vocabulary - it didn't work well with the vocabulary
stack.

Starting debug of pentium assembler.

source:
	code andy dx ) ax mov,  4 # dx add, ax dx ) and, next,
generated:
	011842F8  mov         eax,edx 
	011842FA  add         edx,4 
	011842FD  and         edx,eax 
	011842FF  jmp         edi  
should have generated:
	mov	eax, [edx]
	add	edx, 4
	and	[edx], eax
	jmp	edi

-> The ")" op is never being executed - it may be getting eaten by the shell
-> changed all uses of ")" to "]"
	code andy dx ] ax mov,  4 # dx add, ax dx ] and, next,

Assembler is now generating the correct code for "andy", and the op performs
correctly with both fast & slow interpreters.

DLL support was broken, because it relied on the op for a vocab to push
its address on TOS.

I'm changing vocabularies to act like variables, where a prefix op is used
to set the operation the vocabulary will do when invoked.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 4 2007

Working on switching over to the ans forth vocabulary stack.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
May 3 2007

Updated CVS.

The GForth assembler is ported, it loads but it is untested.
The GForth package doesn't seem to have any examples of its usage in actual
code, but the assembler is almost identical to the assembler in BigForth,
maybe it has some examples.  The file gforth.050/doc/gforth.i9 has a
"386 Assembler" section which spells out the syntax.

One problem area was that GForth is not case sensitive.

Another was that there was a partially implemented relocation scheme which
remapped forth builtin ops which compile stuff or manipulate the DP to a set of
proxy ops which mostly did exactly the same thing - presumably this was
preparation for swapping out the proxy ops for another set which did something
like assembling to an address offset from the intended run address.

One odd thing was that "," was remapped to "c,", and it looked like "," was
being used to compile byte data, not longs.  Perhaps the intent was that in
the source for the assembler, "," was used to compile stuff that needed to
be relocated and "c," was used to compile stuff that didn't.

The next step would be to create a way to make a user-defined op in
assembler.  This could be tricky, especially if we want the fast inner
interpreter to be able to execute these ops without passing them off to
the slow inner assembler.
-> The user defined code ops would be setup to work with the fast interpreter,
   and create a piece of glue code which the slow interpreter uses to execute
   user defined code ops
   -> We could also use this for builtinOps which have no C++ version (with a small mod)
User defined code ops should live in userOps dispatch table, and therefore
share the opValue space of other user defined ops, which will make "forget"
easy to implement for them.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 30 2007

Working on adapting the GForth assembler

: within  ( u1 u2 u3 -- f )
 over - >r - r> u< ;

: t5a 5 -5 within . ;  ok
: t5b -5 5 within . ;  ok

-6 t5a -1  ok
-5 t5a 0  ok
4 t5a 0  ok
5 t5a -1  ok

-6 t5b 0  ok
-5 t5b -1  ok
4 t5b -1  ok
5 t5b 0  ok

With arguments in low,high order result is true for numbers between low & high-1
With arguments in high,low order result is false for numbers between low & high-1

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 28 2007

Initial debug of new DLL support - it works!

Integrated with old CVS system

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 26 2007

Wrote the assembly side of support for DLL via a special opcode type.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 25 2007

+ look at usage of CompileLong versus CompileOpcode
  -> replaced CompileLong with CompileOpcode where appropriate

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 24 2007

+ see if initialization of local strings works, it might not since it looks like this:
  -> 100 string myName
  The "100" compiles into a constant op, which is then removed by "string", but it
  might make string ignore the "->" and not do the initialization...
  -> added mpLastIntoOpcode to engine, to track last "->" compiled in
     current definition
     
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 23 2007

I moved the replacement of kResultDone with kResultOk into ForthEngine::ExecuteOps.
This centralizes the fix for ops which execute an op variable from exiting
the inner interpreter prematurely.
There is one drawback to fixing this bug, it could make the "done" op useless
except as an internal to the outer interpreter.

+ if "->" has been executed before a native global or local variable declaration,
  initialize the new variable from TOS
  
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 22 2007

The current state of forth output:

ops which produce output invoke CONSOLE_STRING_OUT, passing a core ptr & a char buffer ptr
CONSOLE_STRING_OUT is defined as: pCore->pThread->consoleOut( A, B )
consoleOut is set by the SET_CON_OUT_ROUTINE macro.

outToScreenOp
  sets consoleOut = consoleOutToFile
  sets output file = stdout

outToFileOp
  sets consoleOut = consoleOutToFile
  sets output file = file on TOS

outTOStringOp
  sets consoleOut = consoleOutTOString
  sets output file = NULL
  sets output string = string ptr on TOS

outToOpOp
  sets consoleOut = consoleOutToOp
  sets consoleOutOp = TOS

SET_CON_OUT_FILE( FILE_POINTER )
SET_CON_OUT_ROUTINE( OUTPUT_ROUTINE )
SET_CON_OUT_STRING( A )
SET_CON_OUT_OP( OUTPUT_OP )

consoleOutTOString just appends the string to the end of the buffer, it should
be changed to use the string current length & max length fields.

Got outToOp working, but found an apparent bug in local variables - if I
define a local pointer variable with "ptrTo byte" I get an exception when
it tries to print what is at that address, but it works if I change that
variable to be "int".
-> the local variable defining code was ignoring the "isPointer" flag.

There is still a bug in the output code - if you use a user-defined op,
any output generating op will end the execution of a calling op.
It almost looks like the "done" flag is being set.
-> duhh, yeah, since consoleOutToOp calls ForthEngine::ExecuteOneOp,
   that does a "done" after executing the output op...
-> fixed

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 21 2007

One way to improve DLL support would be to dedicate an opcode to DLL calls.
The address of the DLL entry point would be held in the user defined op
dispatch table.  The op value field would hold 2 things:
1) the dispatch table index
2) the number of arguments the op takes
As mentioned yesterday, Each DLL would have a dedicated vocabulary.

+ fixed a bug in structure support - any forget was wiping out all structs,
  because it was comparing the forgotten op's value field to the structs
  entire opcode

+ added extends, sizeOf and addressOf

+ add "union" to structure definitions

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 20 2007

The SDL_LoadBMP exception happened because SDL_LoadBMP isn't one of the DLLs
exports - the real export is SDL_LoadBMP_RW.  The defining words for DLL
interface words should check for getProcAddress returning NULL.

Maybe we should create a special type of vocabulary for DLLs, where the
vocabulary would know the path to the DLL and its symbols would be the
DLLs entry points - this would allow saving the forth state and restoring
the DLL linkage on coldstart.

Before you call a C routine you push arguments right-to-left, so the first
argument is on top of the stack (lowest memory address).  When we call a
DLL routine, we push arguments left-to-right, so the last argument is on
top of the stack.  This forces us to have to copy between the parameter
stack and the PC stack to reverse the order.  If that wasn't the case we
could do a trick in assembler where we just set the PC stack pointer to the
parameter stack before the DLL call.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 19 2007

Tried to implement SDL dll interface - got an exception in SDL_LoadBMP

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 16 2007

I took the 11 forth.zip files dating back to February 2004 and entered them
into CVS.  Unfortunately, most of them didn't have the assembler inner
interpreter, just one right after I started writing it and the most
recent version.

I added a recursive search option to FindSymbol and FindSymbolByValue.
The recursive search happens if you pass an optional pointer to a pointer
to a vocab.  This is filled in with the vocab the symbol was found in.
This gets around problems caused by the format of entries being different
in different vocabularies - for example, where the name begins depends on
the number of value fields, which can vary between vocabularies.

I also changed the ForthPrecedenceVocabulary::GetNextSearchVocabulary
to return the engine's current search vocab, so you can just do a recursive
search on the precedence vocab instead of searching it and then searching
the search chain.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 15 2007

Found the "dir" exception - it was in string store code.  String store and
append were stomping multiple registers, and cleaning up by jumping to
the main interpreter entry point to reload the registers from FCore.
Unfortunately, the IP had not been saved out to FCore, so after returning
from the string store, the IP was set back to the return point after the
last user defined word executed.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 14 2007

I tried making symbolic constants forgettable by using the pEntry[1] field
to hold the next user defined op number for forgetting, but that just
doesn't work reliably - many symbolic constants can share the same op
number in this scheme, and there is no way to know which constants were
defined before other constants, since the constants could be in multiple
vocabularies.

I'm switching over to having each enum set having a user-defined op and
having forget only work on user-defined ops.  The user-defined op for an
enum set will act as a defining word that is funtionally the same as the
"int" op.

I added "describe" op which disassembles user ops.
Here is an example:

: dir
  blword -> _aa
  "dir" -> _bb
  strcmp( _aa "" )
  if
    // user specified a directory
    strcat( _bb " " )
    strcat( _bb _aa )
  endif
  _bb system drop
;

dir: type UserDefined:9 value 0x1000009 0x0
0118041c  00:00011d    blword
01180420  00:000012    ->
01180424  01:000001    _aa
01180428  0a:000001    "dir"
01180430  00:000012    ->
01180434  01:000002    _bb
01180438  01:000001    _aa
0118043c  0a:000001    ""
01180444  00:0000b6    strcmp
01180448  04:000007    BranchFalse    0x01180468
0118044c  01:000002    _bb
01180450  0a:000001    " "
01180458  00:0000b2    strcat
0118045c  01:000002    _bb
01180460  01:000001    _aa
01180464  00:0000b2    strcat
01180468  01:000002    _bb
0118046c  00:00010c    system
01180470  00:000001    drop
01180474  00:000016    _exit

There is an exception if you execute "dir" in turbo mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 13 2007

Added "enum definition" mode - this is an interpreted mode, where:
o recognized symbols including numbers are executed like normal
o unrecognized symbols become new enumerated value definitions
o stack depth is recorded at start of enum definition, when a new enumerated
  value definition is created, it will pop its value off TOS if TOS is above
  the level at the start of enum definition
o enumeration value is incremented after each definition
o if possible, enumerated value definitions are created as kOpConstant ops,
  if they are outside the possible range a user-defined constant op is
  defined instead

When testing enums, I found an interesting forget bug: if you try to
forget a kOpConstant definition, nothing appears to happen, the constant ops
still show up in vlist, but if you then forget a user op, the constant ops
will also be forgotten, even if they were defined before the user op.
? Is this a problem just for constant ops, or would if affect any ops which
  do not have an entry in the engine dispatch table ?
-> the problem is because forgetting only works for user defined ops (kOpUserDef)
-> we could make symbol constants unforgettable (this wouldn't work for
   constants which were too big for symbol constants, since they are user ops)
-> maybe there should be a dummy symbol for each enum set that is used just
   for forgetting
-> we could use the unused "struct" field, make it type kDTNone, with the
   value field holding the value of the next user op at the time the
   symbolic constant was defined...  the forget would have to be
   modified to take this into account
   
With enums and structs, I can start making an interface for the SDL DLL.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 11 2007

Got structures working, just did a few simple tests, didn't test arrays or
nested structures or anything complex
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 8 2007

Maybe the first attempt at structures should skip all optimizations, just
compile an op for each symbol in a structure access compound op

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
April 7 2007

Struct defining stuff is in.  Extension to outer interpreter to handle
stuff like a.b.c is not in yet.

I'm not completely sure that the handling of pointers is correct.
I got rid of ForthNativeStringType, merged it back into ForthNativeType.
I'm not convinced that was a good idea, the code is messy, I was trying to
avoid duplicating DefineInstance.  Most of the ugliness is because strings
need to get the maximum string length, and how that is done is different
in interpret mode and compile mode.

Strings and string arrays in structs is probably not a great idea anyway,
since the maximum length field is not set in that case, so it would be easy
to use an uninitialized string and get a buffer overrun.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 31 2007

Added ForthNativeType

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 26, 2007

Added initStringArrayOp

Added code for arrays to defining words

Added ptrTo support to variable/array defining words
Right now, any variable/array defined with ptrTo is the same as an int
variable/array.
When both arrayOf and ptrTo appear in the same declaration the result is
an array of ints.

Increased length of vocabulary value field for user-defined ops to 2 longs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 25, 2007

Added initString op

How should local & global arrays be supported?
Should they use varOps?  Should they be just like variables except always
doing an array indexing operation?

Simplified existing global/local variable code.  Previously there was code
for each combination of varOp and local/global/field vars.  Now local/global/field
use common code for each varOp.  This is slightly less efficient when running
with the c++ inner interpreter but cuts down the amount of code by a factor
of 2, which makes adding array support easier.

Added support code for all types of arrays

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 23, 2007

Removed remaining vars/endvars dead code
Added field action types
The c++ field action code was using the field offset as longs, changed it
to be using bytes

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 22, 2007

Added dummy entries for struct support ops, just to avoid having to add
them an op at a time to c++ and assembler versions
Added sp, s0, rp, r0, fp ops
Added tuck, pick, roll ops
Changed vocabulary stuff to use long* instead of void* for symbol entry pointers

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 20, 2007

Added byte, short, op data types

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 18, 2007

Added compilation of initLocalStringOp for local string vars

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 17, 2007

Added byte & short types
Added local string support to turbo mode
Changed string store & append varOps to use max & current length fields
Added output redirection
Added ArrayOffset optype

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 16, 2007

Been working on structure stuff in ForthStructs.txt

A potential problem with using DLLs from forth ops is anything that requires
a callback.  A possible solution would be to define an interfacing DLL that
goes between the windows DLL and forth.

? could we define a generic callback into forth, and accessors on the forth
  side that gave access to the callback arguments on the stack ?
-> wait until we run into a case where we need a callback

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 15, 2007

Added varAction! and varAction@
Added memcpy and memset

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 14, 2007

Added simple help system to forth_autoload.txt
Still need to add op definitions for builtin ops

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 4, 2007

Started integrating forth into ForthGui

It is at the point where I can pass a line of text from an edit control to
the forth shell, and it processes it correctly.

The next step is to change the output system so that it can be sent back to
ForthGui for display in another edit window.

The way it currently works is that forthOps that generate output call a
local procedure named stringOut.

stringOut writes its output to the current output file if one exists,
otherwise it pushes the string address on param stack and invokes an internal
op called ConOutOpInvoke, which pops the string and appends it to the console
output string buffer.

OutTOStringOp sets the current output file to NULL.
OutToScreenOp sets the current output file to stdout.
OutToFileOp sets the current output file to the specified file.

It would be good to change this so that output can be sent to:
1) a specified routine
2) a user op

printCharOp (%c) also uses ConOutOpInvoke.

? does anything currently use output to buffer?

It looks like nothing uses output to buffer, and the console output buffer
is always NULL unless the user executes the "outTOString" op.

I should probably implement the changes to strings which set the current
and maximum length fields for local strings before doing the output ops.
The only ops which 
strcpy			->
strncpy			->
strcat			->+
strncat			->+
strlen    strchr    strrchr    strcmp    stricmp    strstr    strtok

I started adding maxLength/curLenth to strings, it is done for global varibles,
but it is probably broken for local variables...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 26, 2007

Added chdir (couldn't use "system" for this)

Added autoforget - just a version of "forget" that doesn't complain if
  symbol to forget doesn't exist

Added interpret - takes a string and gives it to outer interpreter

Added automatic loading at startup of forth_autoload.txt

Added a bunch of string operators (strncpy, strncat, strrchr, stricmp)

Added a bunch of tests to forthtest.txt

Added sc@ & sw@	- signed byte & word fetch
Added c2l & w2l - byte & word sign extension to long

Added ability to specify double float constants by appending a "d": 1.0d
You can specify single float constants by 1.0f, but this is the default

Fixed bug with "0 word"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 21, 2007

Broke out stuff in this file into seperate files in ForthDocs.

Tried out builds... does with:
	: plusser builds , does @ + ;
	5 plusser p5
	20 p5
Normal mode returns 25, but turbo mode returns 40.
	: minusser builds , does @ + ;
	5 minusser m5
	20 m5
Normal mode returns 15, but turbo mode returns 0.

-> got it working, but I should go through and verify that it is right
  It feels like there is another level of indirection than is correct...
-> there was a bug in @ - it wasn't doing any indirection, so it was a no-op,
   and I had added an extra level of indirection to the asm doDoes code

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 18, 2007

Fixed offset optype.

Changed local var stuff so that local vars can be declared anywhere,
vars...endvars are not needed and should be removed.
One case which was a problem was strings:

: anExample
  55 string anyName
;

In this example, the 55 which was intended to be the length param to "string"
had been compiled.  To deal with this, I added a method to the engine which
checks if the last compiled opcode was a literal constant and returns its
value if so.  The "string" implementation backs the DP over this constant.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 17, 2007

When I looked at converting the string ops into assembler, I started thinking
about string variables, in particular about detecting and avoiding string
buffer overruns.  Three main possibilities came to mind:

1) do like C does, just ignore the problem and always assign bigass buffers
2) add a max length field to string variables
  a) add a current length field to string variables
3) go to a scheme where strings are handled more abstractly
  a) suppose a string was a base pointer and a length
  b) or maybe a pointer, current length and writable length (0 means const string)

One problem with making strings more complex than simple uninitialized
buffers is that it would make implementing local strings more complicated

The max length field isn't important for ops that don't modify a string, so
stuff like strlen, strcmp. strstr and strchar could be implemented as they
are now by just calling the C library routines.

Another problem with making strings something other than a simple set of
bytes is if you want to use them in a disk record structure, you probably
don't want the extra length fields taking up space.

I went off on a tangent about eliminating the need for vars/endvars, allowing
you to declare variables anywhere in a user defined word.
  You would probably want to compile the allocLocals op at the first occurence
  of a local variable.  There are many ways that a user could shoot themself
  in the foot doing this, especially if they were manipulating the return
  stack, but it would be mostly safe.
  One consequence of this is that when a string local var is declared, it would
  have to see if a literal constant was just compiled to determine its size.
  -> maybe we could leave that literal constant op where it was compiled, and
     then compile an opcode immediately after it which would store that constant
	 in the local string vars max length field and zero its current length field.

I tried adding an offset optype, it works fine in interpret mode, but not in compile mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 16, 2007

Got most of the floating point ops defined
int, float & double global & local variables are working

- need to test builds...does

- change string variables to include a current length & max length

? make an optimized case branch, where the opcode includes the case value
  and branch offset?

+ added the ability to add 'd' or 'f' to the end of real literals to control
  generation of single or double precision constants

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 13, 2007

Assembler version of forth is mostly working.

I added a macro to allow assembly-code ops to invoke c-code ops.

I added an op "turbo" that allows switching between using c-code
and asm-code inner interpreters on the fly.

c-code is setting ForthCoreState->state @(002F4948 + 434) = 1
asm-code is checking (002F4948 + 432)
? Say huh ?

I auto-generated core.inc from core.h to define the FortheCoreState structure
for asm-code.  One problem area is enumerated types.  Maybe both the c-code
and asm-code structures should be defined strictly in terms of simple types
with a known storage size.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 4, 2007

Worked on writing assembler versions of optype dispatch routines.

Got to LocalIntAction

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 3, 2007

In preparation for switching over to using assembler for inner interpreter,
I changed the inner interpreter to use a 2-stage dispatch scheme, and broke
out the portion of the state that the assembly code will use into a new
structure, the ForthCoreState.

o There is a single ForthCoreState, which is contained in the ForthEngine.
o The ForthCoreState is associated with a single thread at any time.

I had done a similar state breakout of ForthThreadState from ForthThread a
while back.  The big difference is that ForthCoreState contains the
optype dispatch table and other ForthEngine related stuff.

One other related change which caused some bugs is that before both builtinOps
and user defined ops shared a single dispatch table, now they each have their
own table.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Assembler version

7 general purpose registers available:
eax, ebx, ecx, edx, esi, edi, ebp

Things to keep in registers:
IP
SP
optype dispatch table
? builtinOp dispatch table
inner interpreter PC
thread ptr (RP, FP ...)

this would only leave one general purpose register available for stuff...

EAX	free
EBX	free
ECX	IP
EDX	SP
ESI	builtinOp dispatch table
EDI	inner interp PC
EBP	core ptr

? maybe combine opType and builtinOp tables - have bottom 256 builtinOp codes
  be used for opType dispatchers
-> it would not be "free" to detect situation where you compile an opcode in 0..255, which
   would cause an optype handler routine to be executed as if it were a builtinOp
   -> detecting this would require an extra compare & branch instruction pair, which could
      be included in the debug version of the inner interpreter

Maybe the engine ptr should be in a register, and the engine should have a notion
of a current thread, and the threads state is stored in the engine...


Maybe EBP register should point to a new structure, which has:
  1) current thread state (RP, FP, etc)
  2) ptr to engine
  3) ptr to current thread
  4) opType dispatch table
  5) builtinOp dispatch table
forthOps can reuse ESI or EDI, but if they do they either reload them from the EBP struct
or they branch to an alternate inner interpreter entry point that reloads ESI & EDI
Some of this structure is global engine state, some of it is a copy of the current thread state.

innerInterp
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins		; numBuiltins includes the 256 opType dispatchers
	jge	notBuiltin
	mov	eax,[esi+eax*4]
	jmp	[eax]

innerInterpDebug
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins
	jge	notBuiltin
	cmp	eax,256
	jlt	badOpcode
; we should add checking of SP, RP etc. here
	mov	eax,[esi+eax*4]
	jmp	[eax]

notBuiltin
	mov	ebx,eax			; leave full opcode in ebx
	shr	eax,24			; eax is 8-bit optype
	mov	eax,[esi+eax*4]
	jmp	[eax]

;
; builtinOp code
;

addOp
	mov	eax,[edx]
	add	edx,4
	add	[edx],eax
	jmp	[edi]
	
	
+ I broke out the part of the forth machine state the inner interpreter uses
  from the ForthThread class into a structure.
- Change the dispatch table to combine the optype and builtinOp tables
- Move most of ForthThread::InnerInterpreter into a c function, get that
  working and then use the generated assembly entry and exit code
- Remove the user-defined (high level) ops from the builtin op table
- Put the pointer to the dispatch table into the inner interpreter struct
- Don't have 256 opType dispatchers, the top 128 are for method stuff...
- Change the current opType action routines from ForthEngine methods to
  standalone routines
- Move the inner interpreter and the opType action routines into their
  own source module
  -> need to disentangle the intOp/doIntOp/intActionRoutine stuff first

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 8, 2006

+ added ForthForgettable class, changed ForthVocabulary to be based off it

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 5, 2006

+ added input buffer processing ops word/blword/fillInBuffer...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 2, 2006

+ added support for loading DLLs and accessing procedures in DLLs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 30, 2006

+ fixed a bug with parenthesized expressions - the token length byte wasn't
  being set in a few places, so tokens coming off the shell stack disappeared

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 17, 2006

- definition of an interface
- definition of a structure
- definition of a class
- representation of an object on stack
- method invocation
- local objects
  - automatic constructor/destructor
- global objects
- objects as members of other objects
- constructors
- class static data members
- arrays of objects

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 3, 2006

+ added shell stack
+ converted control structures to use control stack
+ added parenthisized expressions using control stack
+ added better error messages for control structure syntax errors

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 12, 2005

I haven't done much with this project in a while.
Current things to add:

1) Shell stack - holds info used while compiling control structures and
   for error checking
2) Add ability to use parenthesized expressions like this:
   sin( x 2 * )
   When "sin(" is parsed, the "sin" token is pushed on the shell stack,
   and when ")" is parsed, the "sin" token is poped and compiled.
   This needs to support parens which have no associated function.
   This should work in interpret and compile mode.
3) Add default input and output files to a thread, and ops for doing
   binary IO with them - formatted IO will probably still use the
   existing IO operators and stream redirection
4) Add support for loading DLLs and accessing their entry points
5) Add a message passing/event system - a thread can have a chain of
   listeners that are informed when a significant event occurs
6) Add support for basic windows calls


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth Implementation Classes

ForthEngine
  tools for building forthops
  code space management
  DP
  inner interpreter
  outer interpreter (token-level interpretation)
  action routines for forthOpTypes

ForthShell
  parsing
  line-level interpretation
  input stream management

ForthVocabulary
  symbol table management
  vocabulary search

ForthThread
  storage for stacks
  SP, RP, IP

ForthInputStack
  current input stream
  pushing and popping streams
  input buffer management

ForthInputStream
  input fetching

ForthParseInfo
  setup for fast vocabulary matching
  interface between ForthShell and ForthVocabulary

ForthForgettable
  does propagation of "forget" to all vocabularies and memory cleanup after forget


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth opcode types

kOpBuiltIn          // low 24 bits is builtin opcode

kOpUserDef          // low 24 bits is opcode

kOpBranch,          // low 24 bits is signed branch offset
kOpBranchNZ,
kOpBranchZ,
kOpCaseBranch,

kOpConstant,        // low 24 bits is signed symbol value

kOpString,          // low 24 bits is immediate string length in longs

kOpAllocLocals,     // low 24 bits is frame size in longs

kOpLocalInt,        // low 24 bits is frame offset in longs
kOpLocalFloat,
kOpLocalDouble,
kOpLocalString,

kOpMethodWithThis,  // low 24 bits is method number

kOpMemberInt,       // low 24 bits is object offset
kOpMemberFloat,
kOpMemberDouble,
kOpMemberString,

kOpLocalUserDefined,             // user can add more optypes starting with this one
kOpMaxLocalUserDefined = 127,    // maximum user defined optype

kOpUserMethods  = 128
// optypes from 128...255 are used to select class methods    

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-


forth extensions for syn2k:

- operations for stating what synops are in a patch,
  and what order they are to be executed in
- operations for initializing synops - settings parameters
  and input and output buffers
- operations for getting note frequency and velocity
- operations for building up sets of patches which are
  selected by midi program number
= operations for defining envelopes and connecting them
  to synops
? is there a way to define the interface so that when
  a new synop is added to syn2k another op doesn't have
  to be added to forth?


table <TABLENAME>
endtable

<TABLENAME> tableLen    leaves number of entries in table on stack

synPatchSet <SETNAME>

synPatch <PATCHNAME>
endPatch



//       11111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890
<############################# Last Line In File ##############################>
