autoforget forth_autoload
: forth_autoload "This is the forth_autoload.txt tools module" %s ;

0x7FFFFFFF -> int MAXINT
0x80000000 -> int MININT

: autoload
  blword find
  if( 0== )
    blword load$
  else
    blword drop
  endif
;
  
200 string _aa
200 string _bb

: $,
  // TOS is ptr to nul terminated string at DP
  here over strlen 1+ callot
  swap strcpy
;

0 -> int helpChain
: addHelp
  here helpChain , -> helpChain		// link new entry into help chain
  blword $,		// compile new symbol
  0 word $,		// compile symbols help definition
  align
;

false -> int _helpfileLoaded

: $help
  -> ptrTo byte s
  helpChain	-> int pNext
  if( s strlen 0== )
    // line was empty, just list all help
    begin
    while( pNext )
      pNext 4+ dup %s "	" %s
      dup strlen 1+ + %s %nl
      pNext @ -> pNext
    repeat
    exit
  endif

  begin
  while( pNext )
    if( pNext 4+ s strcmp 0== )
      pNext 4+ dup strlen 1+ + %s
      exit
    endif
    pNext @ -> pNext
  repeat
  s %s " not found!\n" %s
;


: help
  blword -> _aa
  _aa
  if( _helpfileLoaded not )
    "help.txt" load$
    true -> _helpfileLoaded
    // there is a help$ at end of help.txt that will complete the lookup
  else
    $help
  endif
;

addHelp addHelp	addHelp SYMBOL REST_OF_LINE		add help entry
addHelp $,	STRING_ADDR $,		compiles string (can leave DP unaligned)
addHelp help	help BLAH		show help for BLAH

addHelp cd	cd BLAH			change working directory to BLAH
: cd
  blword chdir
  if "cd failed!\n" %s endif
;

addHelp pwd	pwd			display working directory
: pwd "chdir" system drop ;

addHelp dir	dir BLAH		display directory (BLAH is optional filespec)
: dir
  '\n' word -> _aa
  "dir" -> _bb
  if( strcmp( _aa "" ) )
    // user specified a directory
    strcat( _bb " " )
    strcat( _bb _aa )
  endif
  _bb system drop
;

addHelp sys	sys REST_OF_LINE	run rest of line in a DOS shell
: sys 0 word system drop ;

addHelp	ds	ds			dump stack
: ds dstack ;

addHelp fileExists	"FILEPATH" fileExists ... true/false		tell if a file exists
: fileExists "r" fopen dup if fclose drop true else drop false endif ;


int dumpWidth
16 -> dumpWidth

// ADDR LEN OFFSET _dump
: _dump
  -> int offset		// offset is subtracted from the actual data address before display
  -> int len
  -> int addr
  int columns
  int endAddr
  int ch

  addr len + -> endAddr
  len -> columns
  begin
  while( addr endAddr < )
    addr offset - "%08x" %fmt "   " %s
    if( len dumpWidth > )
      dumpWidth -> columns
    endif
    do( columns 0 )
      addr i + c@ "%02x " %fmt
    loop
    "    " %s
    // why do we have to add 1 to dumpWidth here?
    dumpWidth 1+ columns - 0 do %bl %bl %bl loop
    do( columns 0 )
      addr i + c@ -> ch
      if( ch ' ' >  ch 127 < and )
        ch
      else
        '.'
      endif
      %c
    loop
    columns ->+ addr
    columns ->- len
    %nl
  repeat
;

addHelp	dump		ADDRESS LEN dump	dump memory
: dump
  0 _dump
;

addHelp fdump	FILENAME OFFSET LEN fdump	dump file contents
: fdump
  -> int len
  -> int offset
  "rb" fopen -> int infile
  int buff

  if( infile 0== )
    "open failure" %s %nl
    exit
  endif
  if( len 0== )
    // read entire file
    infile flen -> len
  endif
  len malloc -> buff
  infile offset 0 fseek
  if( 0 != )
    "fdump fseek failure" %nl exit
  endif
  buff len 1 infile fread
  if( 0== )
    "fdump read failure" %s %nl
  else
    buff len buff _dump
  endif
  infile fclose drop
  buff free
;

addHelp comparefiles	FILENAME1 FILENAME2 comparefiles TRUE_IF_EQUAL
: comparefiles
  -> ptrTo byte fname2
  -> ptrTo byte fname1
  
  fname2 "rb" fopen -> int infile2
  if( infile2 0== )
    "failed to open " %s fname2 %s %nl
    false exit
  endif
  
  fname1 "rb" fopen -> int infile1
  if( infile1 0== )
    "failed to open " %s fname1 %s %nl
    infile2 fclose drop
    false exit
  endif
  
  // opened both files successfully
  1 -> int linenum
  begin
    infile1 fgetc -> int b1
    infile2 fgetc -> int b2
    if( b1 b2 != )
      infile1 fclose drop
      infile2 fclose drop
      "mismatch at line " %s linenum %d %nl
      false exit
    endif
    if( b1 '\n' == )
      1 ->+ linenum
    endif
  until( infile1 feof )
  infile1 fclose drop
  infile2 fclose drop
  true
;

addHelp numLocals	returns number of longwords of local variables in current stack frame
: numlocals fp if fp rp - 4 / 1- else 0 endif ;

: dlocals
  fp if
    rp 4+
    fp 4-
    do
      i @ %x %nl
    -4 +loop
  else
    "no locals defined\n" %s
  endif
;
addHelp dlocals		display the local variables in current stack frame

addHelp demo	 demo is used to both display and interpret a line of text
: demo getInBufferPointer %s %nl ;
precedence demo


enum:	WIN32_FILE_ATTRIB
  0x00001	FATTRIB_READONLY
  0x00002	FATTRIB_HIDDEN
  0x00004	FATTRIB_SYSTEM
  0x00010	FATTRIB_DIRECTORY
  0x00020	FATTRIB_ARCHIVE
  0x00040	FATTRIB_DEVICE
  0x00080	FATTRIB_NORMAL
  0x00100	FATTRIB_TEMPORARY
  0x00200	FATTRIB_SPARSE
  0x00400	FATTRIB_LINK
  0x00800	FATTRIB_COMPRESSED
  0x01000	FATTRIB_OFFLINE
  0x02000	FATTRIB_NOT_INDEXED
  0x04000	FATTRIB_ENCRYPTED
;enum

struct: FILETIME
  int	lowDateTime
  int	highDateTime
;struct

decimal

enum:	WIN32_CONSTANTS
  windowsConstants 4+  @ TCHAR_SIZE
  windowsConstants 8+  @ MAX_PATH
  windowsConstants 12+ @ WIN32_FIND_DATA_SIZE
  windowsConstants 16+ @ CRITICAL_SECTION_SIZE
;enum

struct: WIN32_FIND_DATA
  int		attributes
  FILETIME	creationTime
  FILETIME	lastAccessTime
  FILETIME	lastWriteTime
  int		fileSizeHigh
  int		fileSizeLow
  int		reserved0
  int		reserved1
  MAX_PATH arrayOf byte fileName
  14 arrayOf byte shortFileName
;struct

loaddone
