Generated Code

controls structures
variables
  local variable allocation & initialization
  global variable allocation & initialization
structures
objects
builds does
colon definitions
anonymous functions
shell stack
combo ops

         1         2         3         4         5         6         7
1234567890123456789012345678901234567890123456789012345678901234567890123456789
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

This file contains info about the code generated by forth including:

o code optimization and combo ops
o the code generated for builds...does words
o the code generated for control structures
  o if...else...endif
  o do...loop
o the code generated for local variables

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Shell stack usage:

do
	pushes OP_DO_DO
	pushes DP
	pushes kShellTagDo
	compiles OP_ABORT, 0 at DP

?do
	pushes OP_DO_CHECKDO
	pushes DP
	pushes kShellTagDo
	compiles OP_ABORT, 0 at DP

loop/+loop
	pops kShellTagDo
	pops OLD_DP
	pops opcode
	compiles opcode at OLD_DP
	compiles kOpBranch(DP - OLD_DP) at OLD_DP+1 (branch used by 'leave')

if
	pushes DP
	pushes kShellTagBranchZ
	compiles OP_ABORT at DP

else
	pops kShellTagBranchZ
	pops OLD_DP
	pushes DP
	pushes kShellTagBranch
	compiles OP_ABORT at DP
	compiles kOpBranchZ(DP - OLD_DP) at OLD_DP

endif
	pops kShellTagBranch/kShellTagBranchZ
	pops OLD_DP
	compiles kOpBranch/kOpBranchZ((DP - OLD_DP) - 1) at OLD_DP
	
begin
	pushes DP
	pushes kShellTagBegin

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Code optimizations and combo ops.

Compilation of combo ops:

Combo ops are a set of optimizations that

A circular peephole buffer is kept of pointers to previous opcodes compiled.

The peephole buffer is cleared whenever looking at previous opcodes would be invalid:
o at the start of compiling an op or method
o after compiling an exit opcode
o after compiling a branch opcode
o after executing ']' to return to compile mode
o ...

---
Uncompilation
  There is already code which removes compiled code for these cases:
o uncompile int literal in 'SIZE arrayOf TYPE NAME' local array declaration
o uncompile int literal in 'SIZE string NAME' local string declaration
o uncompile last varop before a structure access expression in case where varop
  needs to be moved inside the structure access code
---  
The combo op types are:

 NUM VAROP OP      bits 0:10 are signed integer, bits 11:12 are varop-2, bit 13 is builtin/userdef, bits 14-23 are opcode
 NUM VAROP         bits 0:21 are signed integer, bits 22:23 are varop-2
 NUM OP            bits 0:12 are signed integer, bit 13 is builtin/userdef, bits 14:23 are opcode
 VAROP OP          bits 0:1 are varop-2, bit 2 is builtin/userdef, bits 3:23 are opcode
 OP ZBRANCH        bits 0:11 are opcode, bits 12:23 are signed integer branch offset in longs
 OP BRANCH         bits 0:11 are opcode, bits 12:23 are signed integer branch offset in longs
 LOCAL_REF OP      bits 0:11 are local var offset in longs, bits 12:23 are opcode
 MEMBER_REF OP     bits 0:11 are local var offset in longs, bits 12:23 are opcode

CompileOpcode def:
  if opcode type is builtin:
    if opcode is a varop
      if previous opcode type is NUM
      
    else
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

How builds...doescode is implemented		 October 26 2014

: con
  builds ,
  doescode
    ecx ] eax mov,
    4 # edx sub,
    eax edx ] mov,
    rpop,
    next,
    
5 con aha
: woof dup aha + ;

memory after executing above lines of forth:

ADDR(con):  OP( builds )
        +1  OP( , )
        +2  OP( _endBuilds )    this op was compiled by "doescode"
        +3  OP( _con )          this was compiled by "doescode"
ADDR(_con): move eax, [ecx]
			sub edx, #4
			mov [edx], eax
			rpop
			jmp [edi]

ADDR(aha):  OP( _con )          this op was compiled as op 0 by builds, then set to _con by _endBuilds
        +1  DATA_STORAGE( aha ), contents == 5

ADDR(woof): OP( dup )
        +1  OP( aha )
        +2  OP( + )
        +3  OP( exit )

before executing "woof":
    ps: 7
    rs: <empty>
    ip: OLD_IP_VAL
start of executing woof opcode:
    ps: 7
    rs: OLD_IP_VAL
    ip: ADDR(woof)
start of executing aha opcode:
    ps: 7 7
    rs: ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(aha)
start of executing _con opcode:
    ps: 7 7
    rs: ADDR(aha)+1 ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(_con)
after executing doDoes:
    ps: ADDR(aha)+1 7 7
    rs: ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(_con)+1
after executing @ and exit (leaving _con):
    ps: 5 7 7
    rs: OLD_IP_VAL
    ip: ADDR(woof)+2
after executing + and exit (leaving woof):
    ps: 12 7
    rs: <empty>
    ip: OLD_IP_VAL

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
How inline assembly works

asm[ does:

  compile _inlineAsm opcode
  push DP on rstack
  compile 0 (will be filled in by ]asm)
  push assembler vocab on top of search stack
  set state to interpret

]asm does:

  compile jmp DI instruction
  round DP up to nearest longword
  pop address off rstack, store DP there
  set state to compile
  pop search stack

_inlineAsm

  on entry, IP points to longword with IP after the inline code
  set inlineAddress = IP + 4
  set IP = @IP
  non-turbo version will have to save & setup registers with SP, IP, inner interp re-entry point
  jump to inlineAddress

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

How builds...does is implemented		 before 2005

: con builds , does @ ;
5 con aha
: woof dup aha + ;

memory after executing above 3 lines of forth:

ADDR(con):  OP( builds )
        +1  OP( , )
        +2  OP( _endBuilds )    this op was compiled by "does"
        +3  OP( _con )          this was compiled by "does"
ADDR(_con): OP( _doDoes )       this op was compiled by "does"
        +1  OP( @ )
        +2  OP( exit )

ADDR(aha):  OP( _con )          this op was compiled as op 0 by builds, then set to _con by _endBuilds
        +1  DATA_STORAGE( aha ), contents == 5

ADDR(woof): OP( dup )
        +1  OP( aha )
        +2  OP( + )
        +3  OP( exit )

before executing "woof":
    ps: 7
    rs: <empty>
    ip: OLD_IP_VAL
start of executing woof opcode:
    ps: 7
    rs: OLD_IP_VAL
    ip: ADDR(woof)
start of executing aha opcode:
    ps: 7 7
    rs: ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(aha)
start of executing _con opcode:
    ps: 7 7
    rs: ADDR(aha)+1 ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(_con)
after executing doDoes:
    ps: ADDR(aha)+1 7 7
    rs: ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(_con)+1
after executing @ and exit (leaving _con):
    ps: 5 7 7
    rs: OLD_IP_VAL
    ip: ADDR(woof)+2
after executing + and exit (leaving woof):
    ps: 12 7
    rs: <empty>
    ip: OLD_IP_VAL

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

code generated for if...else...endif

: iffy if 1 else 0 endif . ;

ADDR(iffy): branchZ +2
        +1  intLit( 1 )
        +2  branch +1
        +3  intLit( 0 )
        +4  OP( . )
        +5  OP( exit )

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

code generated for do ... loop

: looy 5 0 do i . %bl loop ;

ADDR(looy): intLit( 5 )
        +1  intLit( 0 )
        +2  OP( _do )
        +3  branch +4
        +4  OP( i )
        +5  OP( . )
        +6  OP( %bl )
        +7  OP( _loop )
        +8  OP( exit )

TBDs:
- show how leave works
- show how unloop works
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

: fur vars int a float b endvars 5 -> a 2 ->+ a a . ;

ADDR(fur):  allocLocals( 2 )
        +1  intLit( 5 )
        +2  OP( -> )
        +3  localInt( 0 )
        +5  intLit( 2 )
        +6  OP( ->+ )
        +7  localInt( 0 )
        +8  localInt( 0 )
        +9  OP( . )
        +10 OP( exit )

allocLocals pushed a special IP on the stack which points to an _unravelFrame
opcode, which will remove the local variable stack frame and return to the
caller of "fur"

TBDs:
- show how vars...endvars have been made unnecessary






//       11111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890
<############################# Last Line In File ##############################>
