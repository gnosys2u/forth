? change class stuff so that class table holds opcodes, not IPs, since
  forget is done in terms of opcodes? or do special class forget code which
  forgets classes based on DP after normal forget is done?  how do you
  forget a class?

? is vars/endvars really needed ?
-> its only absolute necessity is to leave room for the "allocVars" opcode
? why can't this be compiled when first local-var-defining word is executed
-> gotcha: now inside vars...endvars state is interpret, and this is used
   to allow the size of string vars to be specified
-> potential gotcha: if the allocVars opcode occured in a branch of an
   "if" construct


- add peephole optimizer that recognizes combinations of op pairs
  where the first op is a varOperation setting word, like "->+" or
  "addr_of" and the next word is an op, and combines them into a single op
  -> ugh, notice that this can't be done if op is a local variable...
     -> so maybe make classes for int, float, double, string?
  -> wasn't this what LocalStore32 and LocalStore64 were intended for?

- add "ref" modifier for vars

- add opTypes/var modifiers for @++, ++@, @--, --@

- add branch ops which include the comparison
  we already have branch, branchZ
  single param branches: branchZ, branchNZ, branchGZ, branchGEZ, branchLZ, branchLEZ
  two param branches: branchEQ, branchNE, branchGT, branchGE, branchLT, branchLE

- add directory search iterator ops
- add "key"
- add multiple vocabularies
- see what would be needed to have a real GUI for forth shell

- check what happens if an error happens during compilation of a word - is there a
  smudged half defined word left dangling?
- add more string operations
- add buffer end checking for parse/token buffers
- look at class dependancies and who-makes-who
- add user definable types
? add labels (what about forward references?)
- add a way to compile "external scripts" - these are
  definitions which are compiled somewhere outside of the
  normal dictionary, and do not have a symbol in normal
  forth vocabularies.
  -> this can be done with current ops
- add obj.method "class" support
  ? how does shell know if an op is a class instance, and how
    does it know what class it is in?
? make vocabulary entry value field be full 32 bits?

+ change ForthVocabulary::AddSymbol to take addToEngineOps flag
+ change how "exit" and ";" work so that they compile the proper
  exit op, based on if there are local vars, if the current definition
  is a method - this will eliminate need for "unravelIP" silliness
+ change how local var frames are implemented - don't stack the oldRP,
  have FP point to oldFP, and have variable offsets be subtracted from
  FP
+ rewrote inner interpreter to use a case statement for simple immediate
  optypes like branches, constants
+ changed user-defined-op type to not be 128 (default class method)
+ should "precedence" be implemented by putting all precedence ops
  in a special vocabulary instead of assigning special precedence
  opcode types
+ move "forget" logic from ForthVocabulary into ForthEngine, handle
  forgetting when there are multiple vocabs
+ added vocab "static" chain, which links all vocabularies
+ added distinction between definition and search vocabs
+ changed optypes so that there is no precedence bit, userdefs
  have optypes of 128...255 - in preparation for optypes of 128
  or more being used to invoke methods
+ added case...of...endof...endcase
+ added runtime support for forth classes
+ add stack & rstack dump ops
+ add directory list op
+ add leave - need to change do/loop so that it can be exited immediately
  -> look at the basic word set in FORTH 83 manual...
+ check that "if"..."endif" with no "else" actually works
+ solve problem of user-defined builtins not tracing...
  -> replace mpOpTable with table of baseDict structs
+ look at do...+loop when the loop increment is negative
+ add forget
  !!! the vocabulary is searched in the wrong order now...
  + change vocabulary to build from the top down...
  + need to remove ops from engine op table too
  + need to make sure that built-in ops can't be forgotten
+ refactor ForthInputStream out of ForthInputStack
+ add use of "base" for numeric input
+ add vars...endvars for local definitions, and make int, float & double
  not have precedence, vars sets state to compile
  -> this will allow local string vars like "32 string someName"
+ add a way for engine to return last token after an error
+ move stack checking from inner interpreter to outer interpreter
+ change outer interpreter to compile a done opcode, remove
  opcode count from inner interpreter
+ work on error trapping - print something on stack errors,
  flush the stacks, have a way to bail out of a "load" on
  error
+ add negate, and, or, xor, not, true, false, mod, /mod, lshift, rshift,
  [, ], again
+ add malloc and free operations
+ get builds...does working
+ fix "load" bug caused by not switching to new stream until
  current line buffer is empty
+ add the "end script" opcode for external script users
+ add a vocabulary to hold local variables
+ change system to use real addresses, not relative to base of dictionary



Interactive Execution Call Flow:

ForthShell::Run
ForthShell::InterpretLine
ForthEngine::InterpretToken
ForthEngine::InnerInterpreter

