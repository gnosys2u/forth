
//       11111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
TBDs:

- vocabulary support
- structure support
- windows support
  - gui stuff
  - graphics

- rewrite kernel in assembler


C++ code is setting ForthCoreState.state @(002F4948 + 434) = 1
We are checking (002F4948 + 432)
? Say huh ?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth Implementation Classes

ForthEngine
  tools for building forthops
  code space management
  DP
  inner interpreter
  outer interpreter (token-level interpretation)
  action routines for forthOpTypes

ForthShell
  parsing
  line-level interpretation
  input stream management

ForthVocabulary
  symbol table management
  vocabulary search

ForthThread
  storage for stacks
  SP, RP, IP

ForthInputStack
  current input stream
  pushing and popping streams
  input buffer management

ForthInputStream
  input fetching

ForthParseInfo
  setup for fast vocabulary matching
  interface between ForthShell and ForthVocabulary

ForthForgettable
  does propagation of "forget" to all vocabularies and memory cleanup after forget

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

[ARRAY_INDICES] STRUCT_PTR [FIELD_SELECTORS]

INDEX STRUCT_PTR int[]

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

vocabulary NAME

forth definitions
forth uses

SYMBOL_NAME SYMBOL_VALUE SYMBOL_TYPE VOCAB addSymbol	ENTRY_PTR
SYMBOL_NAME VOCAB  findSymbol	ENTRY_PTR

! this isn't very flexible - for example, how would this be used to make
  a vocabulary which would recognize fixed point numbers?


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 18, 2007

Fixed offset optype.

Changed local var stuff so that local vars can be declared anywhere,
vars...endvars are not needed and should be removed.
One case which was a problem was strings:

: anExample
  55 string anyName
;

In this example, the 55 which was intended to be the length param to "string"
had been compiled.  To deal with this, I added a method to the engine which
checks if the last compiled opcode was a literal constant and returns its
value if so.  The "string" implementation backs the DP over this constant.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 17, 2007

When I looked at converting the string ops into assembler, I started thinking
about string variables, in particular about detecting and avoiding string
buffer overruns.  Three main possibilities came to mind:

1) do like C does, just ignore the problem and always assign bigass buffers
2) add a max length field to string variables
  a) add a current length field to string variables
3) go to a scheme where strings are handled more abstractly
  a) suppose a string was a base pointer and a length
  b) or maybe a pointer, current length and writable length (0 means const string)

One problem with making strings more complex than simple uninitialized
buffers is that it would make implementing local strings more complicated

The max length field isn't important for ops that don't modify a string, so
stuff like strlen, strcmp. strstr and strchar could be implemented as they
are now by just calling the C library routines.

Another problem with making strings something other than a simple set of
bytes is if you want to use them in a disk record structure, you probably
don't want the extra length fields taking up space.

I went off on a tangent about eliminating the need for vars/endvars, allowing
you to declare variables anywhere in a user defined word.
  You would probably want to compile the allocLocals op at the first occurence
  of a local variable.  There are many ways that a user could shoot themself
  in the foot doing this, especially if they were manipulating the return
  stack, but it would be mostly safe.
  One consequence of this is that when a string local var is declared, it would
  have to see if a literal constant was just compiled to determine its size.
  -> maybe we could leave that literal constant op where it was compiled, and
     then compile an opcode immediately after it which would store that constant
	 in the local string vars max length field and zero its current length field.

I tried adding an offset optype, it works fine in interpret mode, but not in compile mode.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 16, 2007

Got most of the floating point ops defined
int, float & double global & local variables are working

- need to test builds...does

- change string variables to include a current length & max length

? make an optimized case branch, where the opcode includes the case value
  and branch offset?

+ added the ability to add 'd' or 'f' to the end of real literals to control
  generation of single or double precision constants

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 13, 2007

Assembler version of forth is mostly working.

I added a macro to allow assembly-code ops to invoke c-code ops.

I added an op "turbo" that allows switching between using c-code
and asm-code inner interpreters on the fly.

c-code is setting ForthCoreState->state @(002F4948 + 434) = 1
asm-code is checking (002F4948 + 432)
? Say huh ?

I auto-generated core.inc from core.h to define the FortheCoreState structure
for asm-code.  One problem area is enumerated types.  Maybe both the c-code
and asm-code structures should be defined strictly in terms of simple types
with a known storage size.

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 4, 2007

Worked on writing assembler versions of optype dispatch routines.

Got to LocalIntAction

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
February 3, 2007

In preparation for switching over to using assembler for inner interpreter,
I changed the inner interpreter to use a 2-stage dispatch scheme, and broke
out the portion of the state that the assembly code will use into a new
structure, the ForthCoreState.

o There is a single ForthCoreState, which is contained in the ForthEngine.
o The ForthCoreState is associated with a single thread at any time.

I had done a similar state breakout of ForthThreadState from ForthThread a
while back.  The big difference is that ForthCoreState contains the
optype dispatch table and other ForthEngine related stuff.

One other related change which caused some bugs is that before both builtinOps
and user defined ops shared a single dispatch table, now they each have their
own table.



name STRUCT [[alignment]] [[, NONUNIQUE]]
      fielddeclarations
      name ENDS

fcore STRUCT
	
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
Assembler version

7 general purpose registers available:
eax, ebx, ecx, edx, esi, edi, ebp

Things to keep in registers:
IP
SP
optype dispatch table
? builtinOp dispatch table
inner interpreter PC
thread ptr (RP, FP ...)

this would only leave one general purpose register available for stuff...

EAX	free
EBX	free
ECX	IP
EDX	SP
ESI	builtinOp dispatch table
EDI	inner interp PC
EBP	core ptr

? maybe combine opType and builtinOp tables - have bottom 256 builtinOp codes
  be used for opType dispatchers
-> it would not be "free" to detect situation where you compile an opcode in 0..255, which
   would cause an optype handler routine to be executed as if it were a builtinOp
   -> detecting this would require an extra compare & branch instruction pair, which could
      be included in the debug version of the inner interpreter

Maybe the engine ptr should be in a register, and the engine should have a notion
of a current thread, and the threads state is stored in the engine...


Maybe EBP register should point to a new structure, which has:
  1) current thread state (RP, FP, etc)
  2) ptr to engine
  3) ptr to current thread
  4) opType dispatch table
  5) builtinOp dispatch table
forthOps can reuse ESI or EDI, but if they do they either reload them from the EBP struct
or they branch to an alternate inner interpreter entry point that reloads ESI & EDI
Some of this structure is global engine state, some of it is a copy of the current thread state.

innerInterp
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins		; numBuiltins includes the 256 opType dispatchers
	jge	notBuiltin
	mov	eax,[esi+eax*4]
	jmp	[eax]

innerInterpDebug
	mov	eax,[ecx]		; eax is opcode
	add	ecx,4			; advance IP
	cmp	eax,numBuiltins
	jge	notBuiltin
	cmp	eax,256
	jlt	badOpcode
; we should add checking of SP, RP etc. here
	mov	eax,[esi+eax*4]
	jmp	[eax]

notBuiltin
	mov	ebx,eax			; leave full opcode in ebx
	shr	eax,24			; eax is 8-bit optype
	mov	eax,[esi+eax*4]
	jmp	[eax]

;
; builtinOp code
;

addOp
	mov	eax,[edx]
	add	edx,4
	add	[edx],eax
	jmp	[edi]
	
subOp
	mov	eax,[edx]
	add	edx,4
	sub	[edx],eax
	jmp	[edi]
	
andOp
	mov	eax,[edx]
	add	edx,4
	and	[edx],eax
	jmp	[edi]
	
orOp
	mov	eax,[edx]
	add	edx,4
	or	[edx],eax
	jmp	[edi]
	
xorOp
	mov	eax,[edx]
	add	edx,4
	xor	[edx],eax
	jmp	[edi]
	
	
+ I broke out the part of the forth machine state the inner interpreter uses
  from the ForthThread class into a structure.
- Change the dispatch table to combine the optype and builtinOp tables
- Move most of ForthThread::InnerInterpreter into a c function, get that
  working and then use the generated assembly entry and exit code
- Remove the user-defined (high level) ops from the builtin op table
- Put the pointer to the dispatch table into the inner interpreter struct
- Don't have 256 opType dispatchers, the top 128 are for method stuff...
- Change the current opType action routines from ForthEngine methods to
  standalone routines
- Move the inner interpreter and the opType action routines into their
  own source module
  -> need to disentangle the intOp/doIntOp/intActionRoutine stuff first
-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Structure Support

Cases to consider:

1) struct is pointed to by TOS
2) struct is local var
3) struct is global var
4) struct is object member
5) struct is struct member
6) struct member is an array
7) struct member is an object

--------------------------
The easiest way to implement structures is:

a) all read/write to struct elements is done via pointer ops (@ ! c@ c! ...)
b) structures are always represented by a pointer on TOS
c) structure member ops just add in offsets to pointer on TOS

Positives/negatives:
+ this is the most general way to do this
- this can be very inefficient (lots of ops with little computing & much overhead per op)
+ this is very easy to implement
+ this is the way it has been done in many previous versions of forth
- this can be a pain to program in (lots of ops, easy to make a mistake)
? does this pose problems for object support?
- doesn't solve name collisions between members in different structs
--------------------------
Another way to implement structures is:

a) read/write to struct elements is done like local vars, use "->" to indicate writing, else reading
b) compound symbols are used to specify the structure instance and member (struct.member)

Positives/negatives:
+ should make the code look neater
+ some errors can be caught at interpret time (using member accessor on wrong type of struct)
+ allows disambiguation of member names by struct type (several structs could have members "x" or "index" for example)
+ potentially more efficient code
- much more work to implement
- very different from normal forth approach

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 8, 2006

+ added ForthForgettable class, changed ForthVocabulary to be based off it

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 5, 2006

+ added input buffer processing ops word/blword/fillInBuffer...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
September 2, 2006

+ added support for loading DLLs and accessing procedures in DLLs

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
August 30, 2006

+ fixed a bug with parenthesized expressions - the token length byte wasn't
  being set in a few places, so tokens coming off the shell stack disappeared

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 17, 2006

- definition of an interface
- definition of a structure
- definition of a class
- representation of an object on stack
- method invocation
- local objects
  - automatic constructor/destructor
- global objects
- objects as members of other objects
- constructors
- class static data members
- arrays of objects

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
July 3, 2006

+ added shell stack
+ converted control structures to use control stack
+ added parenthisized expressions using control stack
+ added better error messages for control structure syntax errors

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-
March 12, 2005

I haven't done much with this project in a while.
Current things to add:

1) Shell stack - holds info used while compiling control structures and
   for error checking
2) Add ability to use parenthesized expressions like this:
   sin( x 2 * )
   When "sin(" is parsed, the "sin" token is pushed on the shell stack,
   and when ")" is parsed, the "sin" token is poped and compiled.
   This needs to support parens which have no associated function.
   This should work in interpret and compile mode.
3) Add default input and output files to a thread, and ops for doing
   binary IO with them - formatted IO will probably still use the
   existing IO operators and stream redirection
4) Add support for loading DLLs and accessing their entry points
5) Add a message passing/event system - a thread can have a chain of
   listeners that are informed when a significant event occurs
6) Add support for basic windows calls


-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

How builds...does is implemented


: con builds , does @ ;
5 con aha
: woof dup aha + ;

memory after executing above 3 lines of forth:

ADDR(con):  OP( builds )
        +1  OP( , )
        +2  OP( _endBuilds )    this op was compiled by "does"
        +3  OP( _con )          this op was compiled by "does"
ADDR(_con): OP( _doDoes )       this op was compiled by "does"
        +1  OP( @ )
        +2  OP( exit )
ADDR(aha):  OP( _con )          this op was compiled as op 0 by builds, then set to _con by _endBuilds
        +1  DATA_STORAGE( aha ), contents == 5
ADDR(woof): OP( dup )
        +1  OP( aha )
        +2  OP( + )
        +3  OP( exit )

before executing "woof":
    ps: 7
    rs: <empty>
    ip: OLD_IP_VAL
start of executing woof opcode:
    ps: 7
    rs: OLD_IP_VAL
    ip: ADDR(woof)
start of executing aha opcode:
    ps: 7 7
    rs: ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(aha)
start of executing _con opcode:
    ps: 7 7
    rs: ADDR(aha)+1 ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(_con)
after executing doDoes:
    ps: ADDR(aha)+1 7 7
    rs: ADDR(woof)+2 OLD_IP_VAL
    ip: ADDR(_con)+1
after executing @ and exit (leaving _con):
    ps: 5 7 7
    rs: OLD_IP_VAL
    ip: ADDR(woof)+2
after executing + and exit (leaving woof):
    ps: 12 7
    rs: <empty>
    ip: OLD_IP_VAL

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

code generated for if...else...endif

: iffy if 1 else 0 endif %

ADDR(iffy): branchZ +2
        +1  intLit( 1 )
        +2  branch +1
        +3  intLit( 0 )
        +4  OP( . )
        +5  OP( exit )

code generated for do ... loop

: looy 5 0 do i . %bl loop ;

ADDR(looy): intLit( 5 )
        +1  intLit( 0 )
        +2  OP( _do )
        +3  branch +4
        +4  OP( i )
        +5  OP( . )
        +6  OP( %bl )
        +7  OP( _loop )
        +8  OP( exit )

: fur vars int a float b endvars 5 -> a 2 ->+ a a . ;

ADDR(fur):  allocLocals( 2 )
        +1  intLit( 5 )
        +2  OP( -> )
        +3  localInt( 0 )
        +5  intLit( 2 )
        +6  OP( ->+ )
        +7  localInt( 0 )
        +8  localInt( 0 )
        +9  OP( . )
        +10 OP( exit )

allocLocals pushed a special IP on the stack which points to an _unravelFrame
opcode, which will remove the local variable stack frame and return to the
caller of "fur"

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Forth opcode types

kOpBuiltIn          // low 24 bits is builtin opcode

kOpUserDef          // low 24 bits is opcode

kOpBranch,          // low 24 bits is signed branch offset
kOpBranchNZ,
kOpBranchZ,
kOpCaseBranch,

kOpConstant,        // low 24 bits is signed symbol value

kOpString,          // low 24 bits is immediate string length in longs

kOpAllocLocals,     // low 24 bits is frame size in longs

kOpLocalInt,        // low 24 bits is frame offset in longs
kOpLocalFloat,
kOpLocalDouble,
kOpLocalString,

kOpMethodWithThis,  // low 24 bits is method number

kOpMemberInt,       // low 24 bits is object offset
kOpMemberFloat,
kOpMemberDouble,
kOpMemberString,

kOpLocalUserDefined,             // user can add more optypes starting with this one
kOpMaxLocalUserDefined = 127,    // maximum user defined optype

kOpUserMethods  = 128
// optypes from 128...255 are used to select class methods    

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

  user defined classes in forth
---------------------------------

The outer interpreter will be changed to recognize the syntax
objectName.methodName as a method invocation.

Idea: instead of using the hibit of the optype to denote precedence, have
the hibit set denote a method op, and the other seven bits designate the operation
to be performed - this would allow roughly 128 methods to be easily represented
without needing to use bits in the ops 24-bit value field.

1) object representation
 a) object representation in memory
   object is represented by a pair of pointers (vtable, this)
 b) object representation on stack
   object is represented on TOS by a pointer to a pair of pointers (vtable, this)
2) object method invocation opcodes
 a) 

there will have to be a way to designate both local and global objects
-> use hibit of value field to specify if the value field is global, in
   which case it is referenced using the optable, or is in stack

global objects:
  optable holds pointer to pointer pair
  first pointer points to class descriptor
  second pointer is object storage (this pointer)
local objects:
  local var holds pointer pair
  first pointer points to class descriptor
  second pointer is object storage (this pointer)
  first field of storage is pointer to class vtable
? how should object arrays be handled
-> maybe optable points to longword pair, first field is vtable ptr, second
   field is storage pointer - local vars are similar

  class descriptor table
--------------------------
class descriptor table is table of longwords with the following layout:

long[0]    pointer to ForthClass object for this class
long[1]    "magic" value CLASS_MAGIC_NUMBER for error checking
long[2]    number of methods in this table
long[3]    IP for method 0
...
long[N]    IP for method (N-3)


? maybe have an "epilogue" compiled at end of a method (or word which uses
  local variables).  Epilogue includes:
  o code for destroying local objects
  o code for freeing stack frame
  o code for restoring "this" ptr
  -> keep track of "return" ops while compiling, turn them into branches to
     epilogue
     ? maybe make "exit" illegal inside class methods and words with local variables

? where is vtable ptr?
-> first field in any obj is classObj pointer
-> whenever an obj is created, its classObj pointer must be filled in
  -> declaration of a local obj requires constructor code to be compiled
-> have all objects be implemented thru references, so when a global obj is
   declared, the op for it is a global obj ptr

? how can public member variables be implemented?
-> maybe allow only methods to be public, accessor methods have to be used if
   you want to read/write member variables
? do seperate set/get operations need to be added, or can member variable ops
  act like local vars, where a preceeding "->" or "->+" can modify how they
  act?  If so, built in types like int and float can't be treated like
  other classes, "->" couldn't be a method.

  "this" pointer
------------------
The "this" pointer is a thread variable (TP).  Upon entry to a
class method, the old "this" pointer is on top of the return stack.
? How does invoking another method of the same class from inside a
  method work?
-> maybe add a new forthOpType, where the value field is the
   method number

  class defining words
------------------------
class CLASS_NAME

private
public
protected

isa BASE_CLASS_NAME

vars
...
endvars

method METHOD1_NAME ... ;
...

endclass

? need to think about how "forget" interacts with class stuff
? have class private definitions be held in temp vocab until endclass, then flushed
  ? this would screw up decompilation
? how to implement protected definitions

? is there a vocabulary of classes?  think of CLASS_NAME.new
? what other methods on class objects are there?
? when you see OBJ_NAME.METHOD, how do you find the right class vocabulary to
  lookup METHOD in, using OBJ_NAME?
  -> when A.B token is seen, assume A is an object instance, lookup its opValue
     in symbol table, lookup in opTable to find

? support static variables
    -> nope
? support static methods
    -> nope
? support friend classes
    -> not like c++, no access to class private stuff, but maybe allow a
    way for friend classes to invoke protected methods without having to
    be derived from base class
    -> this would require having a way to search multiple class vocabs

ADDR_OF(OBJ_A): OP( _objInstance
                LONG( ptr to object )
first file in object is vtable ptr, followed by storage...
                LIT(classPointer)
                data storage

isa CLASS_NAME
    public inheritance from named class

inherits CLASS_NAME
    private inheritance from named class


new CLASS_NAME  (? or CLASS_NAME.new)
    leaves addr of new object on TOS

CLASS_NAME NEW_OBJ_NAME
    creates a new object of type CLASS_NAME

class CLASS_NAME

method METHOD_NAME
    add METHOD_NAME to new class vocabulary
    compile code which sets this pointer?
    ? or does inner interpreter do this for us
    -- ugh, this pointer will need to be stacked somehow
    ? do methods ALWAYS have stack frames ?
    set state to compile

? do we need "endmethod" or will ";" work?

endclass
    build vtable
        first copy baseclass vtable
        overwrite any methods this class redefines
        add on any new methods
    add new class vocabulary to list of class vocabularies
    add new class defining word to main class vocabulary


-> replace ForthEngine::InVarsDefinition with a more general execution mode,
   with modes like:
   - interpret mode
   - compile mode
   - vars definition mode
   - class definition mode
   ? are there cases where more than one mode can be active at a time,
     like "compile while in class definition" mode?
  bits:
    compile mode
    definition in progress
        ? how are "compile mode" and "definition in progress" different
        -> you can be compiling an unnamed table
    class definition in progress
    definition uses local vars

  Cases to think about
------------------------
A) method invocation
  Need to specify object, method
  1) on object referenced by local pointer
        opcode bit 31 is 1
        opcode bit 30 is 1
        opcode bits 29:15 is 15-bit method number
        opcode bits 14:0 is 15-bit frame offset of local pointer var
  2) on object referenced by a member pointer
        opcode bit 31 is 1
        opcode bit 30 is 0
        opcode bits 29:15 is 15-bit method number
        opcode bits 14:0 is 15-bit member offset of pointer var
  3) on object referenced by global pointer
        opcode bits 31:24 is method_on_global opcode
        opcode bits 23:10 is 14-bit opcode of global pointer var
        opcode bits 9:0 is 10-bit method number
  4) on "this" object
        opcode bits 31:24 is method_on_this opcode
        opcode bits 23:0 is 24-bit method number
  5) on object pointed to by top-of-stack
        opcode bits 31:24 is method_on_tos opcode
        opcode bits 23:0 is 24-bit method number

B) member access
  Need to specify object, offset, type
  1) on object referenced by global pointer (global.foo)
        opcode bits 31:24 is global_member_TYPE opcode
        opcode bits 23:12 is 12-bit opcode of global pointer var
        opcode bits 11:0 is 12-bit offset
  2) on object referenced by local pointer (local.foo)
        opcode bits 31:24 is local_member_TYPE opcode
        opcode bits 23:0 is 24-bit offset
  3) on "this" object (foo)
        opcode bits 31:24 is this_member_TYPE opcode
        opcode bits 23:0 is 24-bit offset
  4) on object referenced by a member pointer (memberVar.foo)
        opcode bits 31:24 is other_member_TYPE opcode
        opcode bits 23:12 is 12-bit offset of pointer in this object
        opcode bits 11:0 is 12-bit offset of member

  ? maybe member access on other than "this" is a two-step process, where
    the object ptr is put on the stack, then an opcode which encodes type
    and offset is used?

? what about ->+ or ->- operations ?

member
method
member:method
member.member
gvar:method
lvar:method
lvar.member
lvar.member.member.member
lvar.member:method
lvar.member:method.member
-> lvar.member:method.member
... life gets complicated real fast ...


Idea:
  If class vtable holds opcodes instead of IP addresses, member access could
  be done by using member access opcodes in the vtable - you already have the
  object pointer by the time you get to the vtable, and the member access
  opcode optype tells the member type, and the value field is the offset
One potential drawback:
  If public member vars are assigned a vtable slot each, since member vars are
  defined before methods it would be easy to go beyond the first 128 slots of
  the vtable without intending to.
  -> maybe member vars are not assigned vtable slots initially, but are
     assigned vtable slots at the end of class definition
     ? should vtable slots be assigned to methods before end of class def?
? what do vocabulary entries hold, there is only one value field, and it
  must specify: method/member, opcode, vtable slot
  -> during class definition, value field holds the opcode, after definition
     it holds vtable slot number
? should private or protected methods be in the vtable, or should there be
  a "method on this" optype?
  -> probably two "method on this" optypes, one for builtin ops and one for
  user defined ops - the "method on this" value field is the actual optable
  number, NOT the vtable slot number, since when "method on this" ops are
  compiled the vtable hasn't been made yet...

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-

Adding classes to Forth
 
Cases to think of:
1. Global objects
2. Local objects
3. Global object arrays
4. Local object arrays
-> object arrays could mean 2 things:
  1. a single object which is an array of elements
  2. an array whose elements are objects
One significant difference between these is that <1> has only vtable pointer,
while <2> has a vtable pointer per array element.

On Stack:
type		vtable ptr at base of object
method		in opcode
instance	frame offset in opcode

Globals:
type		vtable ptr at base of object
method		in opcode
instance	object ptr


<invokeMethodN> <objectOp>

<methodDesignator> <instanceAddress> <classOp>    (ugh)

<instanceAddress> <classMethodOp>

A forthOpType for class operations could be assigned.  There are 24 bits
which could be used to specify which object instance, and which method
-> assign 2 forthOpTypes - one for global object instances and one for
   local object instances 
   for global object instances, use 14 bits to specify the opcode of the
   object and 10 bits to specify the method number
   for local object instances, use 14 bits to specify the stack offset
   of the object and 10 bits to specify the method number

? how to deal with automatic local object deletion?

-|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|-


forth extensions for syn2k:

- operations for stating what synops are in a patch,
  and what order they are to be executed in
- operations for initializing synops - settings parameters
  and input and output buffers
- operations for getting note frequency and velocity
- operations for building up sets of patches which are
  selected by midi program number
= operations for defining envelopes and connecting them
  to synops
? is there a way to define the interface so that when
  a new synop is added to syn2k another op doesn't have
  to be added to forth?


table <TABLENAME>
endtable

<TABLENAME> tableLen    leaves number of entries in table on stack

synPatchSet <SETNAME>

synPatch <PATCHNAME>
endPatch



//       11111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890
<############################# Last Line In File ##############################>
