autoforget PHILOSOPHERS
: PHILOSOPHERS ;

mko Array philosophers
mko Array forks

100 -> int helpingsToEat
2 -> int eatingTime
2 -> int digestionTime
5 -> int defaultNumPhilosophers
true -> bool useForks

true -> bool usePrintLocks
AsyncLock printLock
: p[
  if(usePrintLocks)
    printLock.grab
  endif
;

: ]p
  if(usePrintLocks)
    printLock.ungrab
  endif
;

class: Philosopher
  Thread eatingThread
  Lock firstFork
  Lock secondFork
  int id
  int timesFed
  int timesHungry
  
  m: delete
    oclear eatingThread
    oclear firstFork
    oclear secondFork
  ;m

  m: isHungry
    //timesFed helpingsToEat <
    eatingThread.getRunState kFTRSExited <>
  ;m
  
  m: run
    //"philosopher " %s id %d " starting\n" %s
    begin
    while(timesFed helpingsToEat <)
      d[ "philosopher " %s id %d " grabbing first fork(" %s firstFork.id %d ")\n" %s ]d
      firstFork.grab
      d[ "philosopher " %s id %d " grabbing second fork(" %s secondFork.id %d ")\n" %s ]d
      secondFork.grab
      1 ->+ timesFed
      d[ "philosopher " %s id %d " ate " %s timesFed %d " time, going to sleep\n" %s ]d

      sleepThread(eatingTime)
      
      d[ "philosopher " %s id %d " ungrabbing first fork(" %s firstFork.id %d ")\n" %s ]d
      firstFork.ungrab
      d[ "philosopher " %s id %d " ungrabbing second fork(" %s secondFork.id %d ")\n" %s ]d
      secondFork.ungrab
      
      sleepThread(digestionTime)
      
    repeat
    "philosopher " %s id %d " done\n" %s
    exitThread
  ;m

  m: init
    -> secondFork
    -> firstFork
    -> id
    -> eatingThread
  ;m
  
;class

: philosopherLoop
  -> Philosopher phil
  phil.run
  oclear phil
;
  
: diningLoop
  "let the feast begin!\n" %s
  ms@ -> int feastStart

  philosophers.count -> int numPhilosophers
  do(numPhilosophers 0)
    philosophers.get(i) ->o Philosopher phil
    phil.init(createThread(lit philosopherLoop 1000 1000) i forks.get(i) forks.get(i 1+ numPhilosophers mod))
   //"philosopher " %s i %d %bl phil.eatingThread.__thread %x %nl
    
    phil.eatingThread.startWithArgs(r[ phil ]r) drop
  loop
  
  do(numPhilosophers 0)
    philosophers.get(i) ->o phil
    phil.eatingThread.join
  loop
  
  "all philosophers stuffed!\n" %s
  ms@ feastStart - %d " milliseconds elapsed\n\n\n" %s
  
  philosophers.clear
  forks.clear
;

: diningPhilosophers
  -> int numPhilosophers
  Philosopher phil
  philosophers.clear
  forks.clear
  
  do(numPhilosophers 0)
    new Philosopher -> phil
    i -> phil.id
    philosophers.push(phil)
    oclear phil
    
    new Lock -> Lock fork
    i -> fork.id
    forks.push(fork)
    oclear fork
  loop

  diningLoop
;

: go
  defaultNumPhilosophers diningPhilosophers
;
  

class: AsyncPhilosopher
  AsyncThread eatingThread
  AsyncLock firstFork
  AsyncLock secondFork
  int id
  int timesFed
  int timesHungry
  
  m: delete
    oclear eatingThread
    oclear firstFork
    oclear secondFork
  ;m

  m: isHungry
    eatingThread.getRunState kFTRSExited <>
  ;m
  
  m: run
    begin
    while(timesFed helpingsToEat <)
      if(useForks)
        d[ p[ "philosopher " %s id %d " grabbing first fork(" %s firstFork.id %d ")\n" %s ]p ]d
        firstFork.grab
        d[ p[ "philosopher " %s id %d " grabbing second fork(" %s secondFork.id %d ")\n" %s ]p ]d
        secondFork.grab
      endif
      1 ->+ timesFed
      d[ p[ "philosopher " %s id %d " ate " %s timesFed %d " time, going to sleep\n" %s ]p ]d

      ms(eatingTime)
      
      if(useForks)
        d[ p[ "philosopher " %s id %d " ungrabbing first fork(" %s firstFork.id %d ")\n" %s ]p ]d
        firstFork.ungrab
        d[ p[ "philosopher " %s id %d " ungrabbing second fork(" %s secondFork.id %d ")\n" %s ]p ]d
        secondFork.ungrab
      endif
      
      ms(digestionTime)
      
    repeat
    p[ "philosopher " %s id %d " done\n" %s ]p
    exitAsyncThread
  ;m

  m: init
    -> secondFork
    -> firstFork
    -> id
    -> eatingThread
    id -> eatingThread.id
  ;m
  
;class

mko Array of AsyncPhilosopher asyncPhilosophers
mko Array of AsyncLock asyncForks


: asyncPhilosopherLoop
  -> AsyncPhilosopher phil
  phil.run
  oclear phil
;
  
: asyncDiningLoop
  p[ "let the asynchronous feast begin!\n" %s ]p
  ms@ -> int feastStart
  AsyncPhilosopher phil
  
  asyncPhilosophers.count -> int numPhilosophers
  do(numPhilosophers 0)
    asyncPhilosophers.get(i) ->o phil
    phil.init(createAsyncThread(lit asyncPhilosopherLoop 1000 1000) i asyncForks.get(i) asyncForks.get(i 1+ numPhilosophers mod))
    //p[ "philosopher " %s i %d %bl phil.eatingThread.__thread %x %nl ]p
  loop
  
  do(numPhilosophers 0)
    asyncPhilosophers.get(i) ->o phil
    phil.eatingThread.startWithArgs(r[ phil ]r) drop
  loop
  
  do(numPhilosophers 0)
    asyncPhilosophers.get(i) ->o phil
    phil.eatingThread.join
  loop
  p[ "all philosophers stuffed!\n" %s ]p
  p[ ms@ feastStart - %d " milliseconds elapsed\n\n\n" %s ]p
  
  asyncPhilosophers.clear
  asyncForks.clear
;

: asyncDiningPhilosophers
  -> int numPhilosophers
  AsyncPhilosopher phil
  asyncPhilosophers.clear
  asyncForks.clear
  system.createAsyncLock -> printLock
  
  do(numPhilosophers 0)
    new AsyncPhilosopher -> phil
    i -> phil.id
    asyncPhilosophers.push(phil)
    oclear phil
    
    system.createAsyncLock -> AsyncLock fork
    i -> fork.id
    asyncForks.push(fork)
    oclear fork
  loop
  
  asyncDiningLoop
  oclear printLock
;

: goAsync
  defaultNumPhilosophers asyncDiningPhilosophers
;


loaddone

