
lf notedeck.txt

NoteDeck helpDeck
NoteSchema opHelpSchema
NoteDef stackParamDef

: createHelpDeck
  new NoteDeck -> helpDeck
  helpDeck.init("help")
  
  helpDeck.addSchema("opDef" "operator definition") -> opHelpSchema
  helpDeck.addParamDef("stack" "stack behavior") -> stackParamDef
  opHelpSchema.addOptionalParam(stackParamDef)
;

createHelpDeck

helpDeck -> _currentNoteDeck

: mkf
  mko String flagName
  mko String displayName
  mko String flagDescription

  flagName.set(blword)
  displayName.set($word('|'))
  flagDescription.set($word(0))
  _currentNoteDeck.addFlagDef(flagName.get displayName.get flagDescription.get) 2drop
  
  //flagName.get %s %nl
  //flagDescription.get %s %nl
  
  oclear flagName
  oclear displayName
  oclear flagDescription
;

mkf op Operator|An executable forth operation
mkf control Control|Ops which change the flow of execution
mkf immediate Immediate|Ops which are executed at compile time
mkf class Class defining|Ops which are used to define classes or class instances
mkf struct Structure defining|Ops which are used to define structures
mkf stack Parameter stack manipulation|Ops which manipulate the parameter stack
mkf logic Logical|Ops which do logic operations
mkf math Arithmetic|Ops which do math

mkf int 32-bit integer|Ops for 32-bit integers
mkf float Single-precision floating-point|Ops for single-precision floating point numbers
mkf double Double-precision floating-point|Ops for double-precision floating point numbers
mkf long 64-bit integer|Ops for 64-bit integers
mkf string String|Ops for strings

mkf print Printing|Ops which output to the console
mkf format Formatting|Ops which format text
mkf internal Internal|Forth compilation internals
mkf defining Defining words|Ops for defining ops and functions
mkf native Native type defining words|Ops for defining variables or fields of native types - int, float, double, etc.
mkf builtin Builtin classes|Convenience classes - arrays, lists, maps, strings, threads, etc.
mkf compare Comparison|Compare numeric values
mkf convert Conversion|Conversion between numeric types
mkf memory Memory|Memory fetch and store
mkf file File|Ops for files
mkf dir Directory|Ops for directories
mkf system System|System ops
mkf if If|Part of if statement
mkf case Case|Part of case statement
mkf loop Loop|Part of do or begin loops

// add string compile if loop case except
// ? short byte unsigned

long _curFlags

//  gets next token from input stream, returns:
//  DELIM ... false                 if token is empty or end of line
//  DELIM ... TOKEN_PTR true        if token found
: getToken
  if($word dup strlen)
    true
  else
    drop false
  endif
;
  
: flags:
  ptrTo byte flagName
  NoteFlagDef flagDef
  
  0L -> _curFlags
  begin
  while(getToken('\ '))
    -> flagName
    _currentNoteDeck.flagMap.get(flagName) -> flagDef
    if(objNotNull(flagDef))
      flagDef.mask ->+ _curFlags  // note: this assumes no duplicate flag values
    else
      // TODO: report error, flag not found
    endif
  repeat
  oclear flagDef
;


//addOp opName|stack behavior|description|extra flags

: addOp
  Note newNote
  _curFlags -> long flags
  ptrTo byte opName
  ptrTo byte flagName

  if(getToken('|'))
    -> opName
    //opName %s %nl
    helpDeck.addNote(opName "") -> newNote
    
    // look for stack behavior
    if(getToken('|'))
      mko NoteParam newParam
      new String -> newParam.sval
      newParam.sval.set
      newNote.params.set(newParam stackParamDef.id)
      oclear newParam
    endif
    
    // look for description
    if(getToken('|'))
      newNote.body.set
    endif
    
    // look for extra flags
    begin
    while(getToken('\ '))
      -> flagName
      if(helpDeck.getFlag(flagName))
        <NoteFlagDef>.mask ->+ flags  // note: this assumes no duplicate flag values
      else
        error("addOp - extra flag not found")
      endif
      
    repeat
    
    flags -> newNote.flags
  else
    error("addOp - opname missing")
  endif

  oclear newNote  
;

: help
  Note foundNote
  NoteParam stackBehavior
  
  if(getToken('\ '))
    -> ptrTo byte opName
    if(helpDeck.getNote(opName))
      ->o foundNote
      opName %s " - " %s foundNote.body.get %s %nl
      if(foundNote.getParam(stackParamDef.id))
        ->o stackBehavior
        stackBehavior.sval.get %s %nl
      endif
    else
      "help - " %s opName %s " not found\n" %s
    endif
  else
    helpDeck.notes.headIter -> ArrayIter iter
    begin
    while(iter.next)
      ->o foundNote
      foundNote.name.get %s " - " %s foundNote.body.get %s %nl
    repeat
    oclear iter
  endif
;

flags: op control
addOp if|BOOL ...|start if statement|if
addOp andif|BOOL ...|add andif clause|if
addOp orif|BOOL ...|add orif clause|if
addOp else||start else branch of if statement|if
addOp endif||end if statement|if
addOp begin||begin loop statement|loop
addOp until|BOOL ...|loop back to "begin" if BOOL is false|loop
addOp while|BOOL ...|exit loop after "repeat" if BOOL is false|loop
addOp repeat||end loop statement|loop
addOp again||loop back to "begin"|loop
addOp do|ENDVAL STARTVAL ...|start do loop, ends at ENDVAL-1|loop
addOp loop||end do loop|loop
addOp +loop|INCREMENT ...|end do loop, add INCREMENT to index each time|loop
addOp case|TESTVAL ... |begin case statement|case
addOp of|CASEVAL ... |begin one case branch|case
addOp endof||end case branch|case
addOp endcase|TESTVAL ...|end all cases - drops TESTVAL|case
addOp abort||terminate execution with fatal error

flags: op stack
addOp drop|VAL ...|drop top element of param stack
addOp dup|A ... A A|duplicate top of stack
addOp ?dup|VARIABLE|duplicate TOS if non 0
addOp swap|A B ... B A|swap top two elements of stack
addOp over|A B ... A B A|copy second stack element to top of stack
addOp rot|A B C ... B C A|rotate third stack element to top of stack
addOp -rot|A B C ... C A B|
addOp nip|A B C ... A C|
addOp tuck|A B C ... A C B C|
addOp pick|A ... PS(A)|
addOp roll|N ...|rolls Nth item to top of params stack
addOp sp|... PARAM_STACK_PTR|
addOp s0|... EMPTY_PARAM_STACK_PTR|
addOp fp|... LOCAL_VAR_FRAME_PTR|
addOp 2dup|DA ... DA DA|
addOp 2swap|DA DB ... DB DA|
addOp 2drop|DA ...|
addOp 2over|DA DB ... DA DB DA|
addOp 2rot|DA DB DC ... DB DC DA|
addOp r[||push SP on rstack, used with ]r to count a variable number of arguments
addOp ]r||remove old SP from rstack, push count of elements since r[ on TOS

flags: op internal
addOp _doDoes||compiled at start of "does" section of words created by a builds...does word
addOp _doVariable||compiled at start of words defined by "variable"
addOp _doConstant||compiled at start of words defined by "constant"
addOp _doDConstant||compiled at start of words defined by "dconstant"
addOp _endBuilds||compiled at end of "builds" section
addOp done||makes inner interpreter return - used by outer interpreter
addOp _doByte||compiled at start of byte global vars
addOp _doShort||compiled at start of short global vars
addOp _doInt||compiled at start of int global vars
addOp _doFloat||compiled at start of float global vars
addOp _doDouble||compiled at start of double global vars
addOp _doString||compiled at start of string global vars
addOp _doOp||compiled at start of opcode global vars
addOp _doLong||compiled at start of long global vars
addOp _doObject||compiled at start of object global vars
addOp _doUByte||compiled at start of unsigned byte global vars
addOp _doUShort||compiled at start of unsigned short global vars
addOp _exit||compiled at end of user definitions which have no local vars
addOp _exitL||compiled at end of user definitions which have local vars
addOp _exitM||compiled at end of method definitions which have no local vars
addOp _exitML||compiled at end of method definitions which have local vars
addOp _doVocab||compiled at start of vocabularies
addOp _doByteArray||compiled at start of byte global arrays
addOp _doShortArray||compiled at start of short global arrays
addOp _doIntArray||compiled at start of int global arrays
addOp _doFloatArray||compiled at start of float global arrays
addOp _doDoubleArray||compiled at start of double global arrays
addOp _doStringArray||compiled at start of string global arrays
addOp _doOpArray||compiled at start of opcode global arrays
addOp _doLongArray||compiled at start of 64-bit global arrays
addOp _doObjectArray||compiled at start of object global arrays
addOp _doUByteArray||compiled at start of opcode global arrays
addOp _doUShortArray||compiled at start of opcode global arrays
addOp initString||compiled when a local string variable is declared
addOp initStringArray||compiled when a local string array is declared
addOp badOp||set bad opcode error
addOp _doStruct||compiled at start of opcode global arrays
addOp _doStructArray||compiled at start of global structure array instances, next word is padded element length
addOp _doStructType||compiled at the start of each user-defined structure defining word 
addOp _doClassType||compiled at the start of each user-defined class defining word 
addOp _doEnum||compiled at start of enum defining word, acts just like 'int'
addOp _do||compiled at start of do loop
addOp _loop||compiled at end of do loop
addOp _+loop||compiled at end of do +loop
addOp _doNew||compiled by 'new', immediately following word is class vocab ptr, executes class 'new' operator
addOp _allocObject||default class 'new' operator, mallocs spaces for a new object instance and pushes new object
addOp vocabToClass||varop setter, putting this before a vocab op makes it return vocabs class object

flags: op int math
addOp +|A B ... (A+B)|add top two items
addOp -|A B ... (A-B)|subtract top two items
addOp *|A B ... (A*B)|mutliply top two items
addOp 2*|A ... (A*2)|multiply top item by 2
addOp 4*|A ... (A*4)|multiply top item by 4
addOp 8*|A ... (A*8)|multiply top item by 8
addOp /|A B ... (A/B)|divide top two items
addOp 2/|A ... (A/2)|divide top item by 2
addOp 4/|A ... (A/4)|divide top item by 4
addOp 8/|A ... (A/8)|divide top item by 4
addOp /mod|A B ... (A/B) (A mod B)|divide top two items, return quotient & remainder
addOp mod|A B ... (A mod B)|take modulus of top two items
addOp negate|A ... (-A)|negate top item

flags: op int compare
addOp =|A B ... A=B|
addOp <>|A B ... A<>B|
addOp >|A B ... A>B|
addOp >=|A B ... A>=B|
addOp <|A B ... A<B|
addOp <=|A B ... A<=B|
addOp 0=|A ... A=0|
addOp 0<>|A ... A<>0|
addOp 0>|A ... A>0|
addOp 0>=|A ... A>=0|
addOp 0<|A ... A<0|
addOp 0<=|A ... A<=0|
addOp u>|A B ... A>B|unsigned comparison
addOp u<|A B ... A<B|unsigned comparison
addOp within|VAL LO HI ... (LO<=VAL<HI)|
addOp min|A B ... min(A,B)|
addOp max|A B ... max(A,B)|

flags: op float math
addOp f+|FA FB ... (FA+FB)|add top two floating point items
addOp f-|FA FB ... (FA-FB)|subtract top two floating point items
addOp f*|FA FB ... (FA*FB)|multiply top two floating point items
addOp f/|FA FB ... (FA/FB)|divide top two floating point items
addOp fsin|FA ... sin(FA)|float sine
addOp farcsin|FA ... arcsin(FA)|float arcsine
addOp fcos|FA ... cos(FA)|float cosine
addOp farccos|FA ... arccos(FA)|float arccosine
addOp ftan|FA ... tan(FA)|float tan
addOp farctan|FA ... arctan(FA)|float arctan
addOp farctan2|FA FB ... arctan(FA/FB)|float arctan of ratio
addOp fexp|FA ... exp(FA)|
addOp fln|FA ... ln(FA)|
addOp flog10|FA ... log10(FA)|
addOp fpow|FA FB ... FA**FB|
addOp fsqrt|FA ... sqrt(FA)|
addOp fceil|FA ... ceil(FA)|
addOp ffloor|FA ... floor(FA)|
addOp fabs|FA ... abs(FA)|
addOp fldexp|FA B ... ldexp(FA,B)|
addOp ffrexp|FA ... frac(FA) exponent(FA)|
addOp fmodf|FA ... frac(FA) whole(FA)|
addOp ffmod|FA FB ... fmod(FA,FB)|

flags: op float compare
addOp f=|FA FB ... FA=FB|
addOp f<>|FA FB ... FA<>FB|
addOp f>|FA FB ... FA>FB|
addOp f>=|FA FB ... FA>=FB|
addOp f<|FA FB ... FA<FB|
addOp f<=|FA FB ... FA<=FB|
addOp f0=|FA ... FA=0|
addOp f0<>|FA ... FA<>0|
addOp f0>|FA ... FA>0|
addOp f0>=|FA ... FA>=0|
addOp f0<|FA ... FA<0|
addOp f0<=|FA ... FA<=0|
addOp fwithin|FVAL FLO FHI ... (FLO<=FVAL<FHI)|
addOp fmin|FA FB... min(FA,FB)|
addOp fmax|FA FB... max(FA,FB)|

flags: op float block
addOp fAddBlock|SRCA SRCB DST NUM ...|add blocks of NUM floats at SRCA and SRCB and store results in DST
addOp fSubBlock|SRCA SRCB DST NUM ...|subtract blocks of NUM floats at SRCA and SRCB and store results in DST
addOp fMulBlock|SRCA SRCB DST NUM ...|multiply blocks of NUM floats at SRCA and SRCB and store results in DST
addOp fDivBlock|SRCA SRCB DST NUM ...|divide blocks of NUM floats at SRCA and SRCB and store results in DST
addOp fScaleBlock|SRC DST SCALE NUM ...|multiply block of NUM floats at SRC by SCALE and store results in DST
addOp fOffsetBlock|SRC DST OFFSET NUM ...|add OFFSET to block of NUM floats at SRC and store results in DST
addOp fMixBlock|SRC DST SCALE NUM ...|multiply block of NUM floats at SRC by SCALE and add results into DST

flags: op double math
addOp d+|DA DB ... (DA+DB)|add top two double floating point items
addOp d-|DA DB ... (DA-DB)|subtract top two double floating point items
addOp d*|DA DB ... (DA*DB)|multiply top two double floating point items
addOp d/|DA DB ... (DA/DB)|divide top two double floating point items
addOp dsin|DA ... sin(DA)|double sine
addOp darcsin|DA ... arcsin(DA)|double arcsine
addOp dcos|DA ... cos(DA)|double cosine
addOp darccos|DA ... arccos(DA)|double arccosine
addOp dtan|DA ... tan(DA)|double tan
addOp darctan|DA ... arctan(DA)|double arctan
addOp darctan2|DA DB ... arctan(DA/DB)|double arctan of ratio
addOp dexp|DA ... exp(DA)|
addOp dln|DA ... ln(DA)|
addOp dlog10|DA ... log10(DA)|
addOp dpow|DA DB ... DA**DB|
addOp dsqrt|DA ... sqrt(DA)|
addOp dceil|DA ... ceil(DA)|
addOp dfloor|DA ... floor(DA)|
addOp dabs|DA ... abs(DA)|
addOp dldexp|DA B ... ldexp(DA,B)|
addOp dfrexp|DA ... frac(DA) exponent(DA)|
addOp dmodf|DA ... frac(DA) whole(DA)|
addOp dfmod|DA DB ... fmod(DA,DB)|

flags: op double compare
addOp d=|DA DB ... DA=DB|double
addOp d<>|DA DB ... DA<>DB|
addOp d>|DA DB ... DA>DB|
addOp d>=|DA DB ... DA>=DB|
addOp d<|DA DB ... DA<DB|
addOp d<=|DA DB ... DA<=DB|
addOp d0=|DA ... DA=0|
addOp d0<>|DA ... DA<>0|
addOp d0>|DA ... DA>0|
addOp d0>=|DA ... DA>=0|
addOp d0<|DA ... DA<0|
addOp d0<=|DA ... DA<=0|
addOp dwithin|DVAL DLO DHI ... (DLO<=DVAL<DHI)|
addOp dmin|DA DB ... min(DA,DB)|
addOp dmax|DA DB ... max(DA,DB)|

flags: op double block
addOp dAddBlock|SRCA SRCB DST NUM ...|add blocks of NUM doubles at SRCA and SRCB and store results in DST
addOp dSubBlock|SRCA SRCB DST NUM ...|subtract blocks of NUM doubles at SRCA and SRCB and store results in DST
addOp dMulBlock|SRCA SRCB DST NUM ...|multiply blocks of NUM doubles at SRCA and SRCB and store results in DST
addOp dDivBlock|SRCA SRCB DST NUM ...|divide blocks of NUM doubles at SRCA and SRCB and store results in DST
addOp dScaleBlock|SRC DST SCALE NUM ...|multiply block of NUM doubles at SRC by SCALE and store results in DST
addOp dOffsetBlock|SRC DST OFFSET NUM ...|add OFFSET to block of NUM doubles at SRC and store results in DST
addOp dMixBlock|SRC DST SCALE NUM ...|multiply block of NUM doubles at SRC by SCALE and add results into DST

flags: op convert
addOp i2f|A ... float(A)|convert int to float|int float
addOp i2d|A ... double(A)|convert int to double|int double
addOp f2i|A ... int(A)|convert float to int|int float
addOp f2d|A ... double(A)|convert float to double|float double
addOp d2i|A ... int(A)|convert double to int|int double
addOp d2f|A ... float(A)|confert double to float|double float
addOp i2l|INTA ... LONGA|convert signed 32-bit int to signed 64-bit int|int long
addOp l2f|LONGA ... FLOATA|convert signed 64-bit int to 32-bit float|long float
addOp l2d|LONGA ... DOUBLEA|convert signed 64-bit int to 64-bit float|long double
addOp f2l|FLOATA ... LONGA|convert 32-bit float to signed 64-bit int|float long
addOp d2l|DOUBLEA ... LONGA|convert 64-bit float to signed 64-bit int|double long

flags: op logic
addOp or|A B ... or(A,B)|
addOp and|A B ... and(A,B)|
addOp xor|A B ... xor(A,B)|
addOp invert|A ... ~A|
addOp lshift|A B ... A<<B|
addOp rshift|A B ... A>>B|
addOp urshift|A B ... A>>B|unsigned right shift
addOp not|A ... not(A)|true iff A is 0, else false
addOp true|... -1|
addOp false|... 0|
addOp null|... 0|

flags: op rstack
addOp >r|A ...|pushes top of param stack on top of return stack
addOp r>|... A|pops top of return stack to top of param stack
addOp rdrop||drops top of return stack
addOp rp|... RETURN_STACK_PTR|return pointer to top of return stack
addOp r0|... EMPTY_RETURN_STACK_PTR|return pointer to bottom of return stack (top if empty)

flags: op memory
addOp @|PTR ... A|fetches longword from address PTR
addOp 2@|PTR ... DA|fetch double from address PTR
addOp ref|ref VAR ... PTR|return address of VAR
addOp !|A PTR ...|stores longword A at address PTR
addOp c!|A PTR ...|stores byte A at address PTR
addOp c@|PTR ... A|fetches unsigned byte from address PTR
addOp sc@|PTR ... A|fetches signed byte from address PTR
addOp c2i|A ... LA|sign extends byte to long
addOp w!|A PTR ...|stores word A at address PTR
addOp w@|PTR ... A|fetches unsigned word from address PTR
addOp sw@|PTR ... A|fetches signed word from address PTR
addOp w2i|WA ... LA|sign extends word to long
addOp 2!|DA PTR ...|store double at address PTR
addOp move|SRC DST N ...|copy N bytes from SRC to DST
addOp fill|DST N A ...|fill N bytes at DST with byte value A
addOp varAction!|A varAction! ...|set varAction to A (use not recommended)
addOp varAction@|varAction@ ... A|fetch varAction (use not recommended)

flags: op string
addOp strcpy|STRA STRB ...|copies string from STRB to STRA
addOp strncpy|STRA STRB N ...|copies up to N chars from STRB to STRA
addOp strlen|STR ... LEN|returns length of string at STR
addOp strcat|STRA STRB ...|appends STRB to string at STRA
addOp strncat|STRA STRB N ...|appends up to N chars from STRB to STRA
addOp strchr|STR CHAR ... PTR|returns ptr to first occurence of CHAR in string STR
addOp strrchr|STR CHAR ... PTR|returns ptr to last occurence of CHAR is string STR
addOp strcmp|STRA STRB ... V|returns 0 iff STRA = STRB, else result of last char comparison
addOp stricmp|STRA STRB ... V|returns 0 iff STRA = STRB ignoring case, else result of last char comparison
addOp strncmp|STRA STRB N ... V|returns 0 iff STRA = STRB ignoring case, else result of last char comparison, for first N chars
addOp strstr|STRA STRB ... PTR|returns ptr to first occurence of STRB in string STRA
addOp strtok|STRA STRB ... PTR|returns ptr to next token in STRA, delimited by a char in STRB, modifies STRA, pass 0 for STRA after first call

flags: op file
addOp fopen|PATH_STR ATTRIB_STR ... FILE|open file
addOp fclose|FILE ... RESULT|close file
addOp fseek|FILE OFFSET CTRL ... RESULT|seek in file, CTRL: 0 from start, 1 from current, 2 from end 
addOp fread|NITEMS ITEMSIZE FILE ... RESULT|read items from file
addOp fwrite|NITEMS ITEMSIZE FILE ... RESULT|write items to file
addOp fgetc|FILE ... CHARVAL|read a character from file
addOp fputc|CHARVAL FILE ... RESULT|write a character to file
addOp feof|FILE ... RESULT|check if file is at end-of-file
addOp fexists|PATH_STR ... RESULT|check if file exists
addOp ftell|FILE ... OFFSET|return current read/write position in file
addOp flen|FILE ... FILE_LENGTH|return length of file
addOp fgets|BUFFER MAXCHARS FILE ... NUMCHARS|read a line of up to MAXCHARS from FILE into BUFFER
addOp fputs|BUFFER FILE ...|write null-terminated string from BUFFER to FILE
addOp stdin|... FILE|get standard in file
addOp stdout|... FILE|get standard out file
addOp stderr|... FILE|get standard error file

flags: op long math
addOp l+|LA LB ... (LA+LB)|
addOp l-|LA LB ... (LA-LB)|
addOp l*|LA LB ... (LA*LB)|
addOp l/|LA LB ... (LA/LB)|
addOp lmod|LA LB ... (LA mod LB)|
addOp l/mod|A B ... (LA/LB) (LA mod LB)|divide top two items, return quotient & remainder
addOp lnegate|A ... (-LA)|negate top item

flags: op long compare
addOp l=|LA LB ... LA=LB|
addOp l<>|LA LB ... LA<>LB|
addOp l>|LA LB ... LA>LB|
addOp l>=|LA LB ... LA>=LB|
addOp l<|LA LB ... LA<LB|
addOp l<=|LA LB ... LA<=LB|
addOp l0=|LA ... LA=0|
addOp l0<>|LA ... LA<>0|
addOp l0>|LA ... LA>0|
addOp l0>=|LA ... LA>=0|
addOp l0<|LA ... LA<0|
addOp l0<=|LA ... LA<=0|
addOp lwithin|LVAL LLO LHI ... (LLO<=LVAL<LHI)|
addOp lmin|LA LB ... min(LA,LB)|
addOp lmax|LA LB ... max(LA,LB)|

flags: op except
addOp try||start of code section protected by exception handler
addOp except||start of exception handler code
addOp finally||defines code run after exception handler
addOp endtry||end of exception handler
addOp raise|EXCEPTION_NUM ...|raise an exception

flags: op defining
addOp builds||starts a builds...does definition
addOp does||starts the runtime part of a builds...does definition
addOp exit||exit current hi-level op
addOp ;||ends a colon definition
addOp :||starts a colon definition
addOp f:||starts a function definition
addOp ;f||ends a function definition, leaves function opcode on stack
addOp code||starts an assembler definition
addOp create||starts a 
addOp variable|variable NAME|creates a variable op which pushes its address when executed
addOp constant|A constant NAME|creates a constant op which pushes A when executed
addOp 2constant|DA 2constant NAME|creates a double constant op which pushes DA when executed
addOp byte|byte VAR|declare a 8-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp ubyte|ubyte VAR|declare a unsigned 8-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp short|short VAR|declare a 16-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp ushort|ushort VAR|declare a unsigned 16-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp int|int VAR|declare a 32-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp uint|uint VAR|declare a unsigned 32-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp long|long VAR|declare a 64-bit int variable or field, may be preceeded with initializer "VAL ->"
addOp ulong|ulong VAR|declare a 64-bit unsigned int variable or field, may be preceeded with initializer "VAL ->"
addOp float|float VAR|declare a 32-bit floating point variable or field, may be preceeded with initializer "VAL ->"
addOp double|double VAR|declare a 64-bit floating point variable or field, may be preceeded with initializer "VAL ->"
addOp string|MAXLEN string NAME declare a string variable or field with a specified maximum length
addOp op|op VAR|declare a forthop variable or field
addOp void|returns void declare that a method returns nothing ?does this work?
addOp arrayOf|NUM arrayOf TYPE declare an array variable or field with NUM elements of specified TYPE
addOp ptrTo|ptrTo TYPE declare a pointer variable or field of specified TYPE
addOp struct:|struct: NAME|start a structure type definition
addOp ;struct||end a structure type definition
addOp class:|class: NAME|start a class type definition
addOp ;class||end a class definition
addOp m:|m: NAME|start a class method definition
addOp ;m ||end a class method definition
addOp returns|returns TYPE|specify the return type of a method, can only occur in a class method definition
addOp doMethod|OBJECT METHOD# doMethod|execute specified method on OBJECT
addOp implements:|implements: NAME|start an interface definition within a class definition
addOp ;implements||ends an interface definition
addOp union||within a structure definition, resets the field offset to 0
addOp extends|extends NAME|within a class/struct definition, declares the parent class/struct
addOp sizeOf|sizeOf STRUCT_NAME ... STRUCT_SIZE_IN_BYTES|
addOp offsetOf|offsetOf STRUCT_NAME FIELD_NAME ... OFFSET_OF_FIELD_IN_BYTES|
addOp new|new TYPE ... OBJECT|creates an object of specified type
addOp initMemberString|initMemberString NAME|used inside a method, sets the current and max len fields of named member string
addOp enum:|enum: NAME|starts an enumerated type definition
addOp ;enum||ends an enumerated type definition
addOp recursize||used inside a colon definition, allows it to invoke itself recursively
addOp precedence||used inside a colon definition, makes it have precedence (execute in compile mode)
addOp load|load PATH|start loading a forth source file whose name immediately follows "load"
addOp $load|PATH $load ...|start loading a forth source file whose name is on TOS
addOp loaddone||terminate loading a forth source file before the end of file
addOp requires|requires NAME|if forthop NAME exists do nothing, if not load NAME.txt
addOp $evaluate|STR $evaluate|interpret string on TOS
addOp ]||sets state to compile
addOp [||sets state to interpret
addOp state|... @STATE_ADDR|leaves address of "state" var on TOS
addOp '|' NAME|push opcode of NAME on TOS (does not have precedence)
addOp postpone|postpone NAME|compile opcode of NAME, including ops which have precedence
addOp compile|compile OPCODE|compile immediately following opcode (opcode must not have precedence)
addOp [']|['] NAME|push opcode of NAME (has precedence)

flags: op print
addOp .|NUM ...|prints number in current base followed by space
addOp .2|LNUM ...|prints 64-bit number in current base followed by space
addOp %d|NUM ...|prints number in decimal
addOp %x|NUM ...|prints number in hex
addOp %2d|LNUM ...|prints 64-bit number in decimal
addOp %2x|LNUM ...|prints 64-bit number in hex
addOp %s|STRING ...|prints string
addOp %c|CHARVAL ...|prints character
addOp %nc|NUM CHARVAL ...|prints character NUM times
addOp spaces|NUM ...|prints NUM spaces
addOp type|STRING NCHARS ...|print a block of NCHARS characters of text
addOp %4c|NUM ...|prints 32-bit int as 4 characters
addOp %8c|LNUM ...|prints 64-bit int as 8 characters
addOp %bl||prints a space
addOp %nl||prints a newline
addOp %f|FPNUM ...|prints a single-precision floating point number with %f format
addOp %2f|DOUBLE_FPNUM ...|prints a double-precision floating point number with %f format
addOp %g|FPNUM ...|prints a single-precision floating point number with %g format
addOp %2g|DOUBLE_FPNUM ...|prints a double-precision floating point number with %g format
addOp format|ARG FORMAT_STRING ... STRING_ADDR|format a 32-bit numeric value
addOp 2format|ARG64 FORMAT_STRING ... STRING_ADDR|format a 64-bit numeric value
addOp addTempString|STRING NUM ... TSTRING|allocate a temporary string - STRING may be null or NUM may be 0
addOp atoi|STRING ... NUM|convert string to integer
addOp atof|STRING ... DOUBLE|convert string to double-precision floating point
addOp fprintf|FILE FORMAT_STRING (ARGS) NUM_ARGS ... RESULT|print formatted string to file
addOp snprintf|BUFFER BUFFER_SIZE FORMAT_STRING (ARGS) NUM_ARGS ... RESULT|print formatted string to BUFFER
addOp fscanf|FILE FORMAT_STRING (ARGS) NUM_ARGS ... RESULT|read formatted string from file
addOp sscanf|BUFFER FORMAT_STRING (ARGS) NUM_ARGS ... RESULT|read formatted string from BUFFER
addOp base|leaves address of "base" var on TOS
addOp octal|sets current base to 8
addOp decimal|sets current base to 10
addOp hex|sets current base to 16
addOp printDecimalSigned|makes all decimal printing signed, printing in any other base is unsigned 
addOp printAllSigned|makes printing in any base signed
addOp printAllUnsigned|makes printing in any base unsigned

flags: op dll
addOp DLLVocabulary|DLLVocabulary VOCAB_NAME DLL_FILEPATH|creates a new DLL vocabulary, also loads the dll
addOp addDLLEntry|NUM_ARGS "ENTRY_NAME" ...|adds a new entry point to current definitions DLL vocabulary
addOp addDLLEntryEx|NUM_ARGS "OP_NAME" "ENTRY_NAME" ...|adds a new entry point to current definitions DLL vocabulary
addOp DLLVoid||when used prior to dll_0...dll_15, newly defined word will return nothing on TOS

addOp lit|... IVAL|pushes longword which is compiled immediately after it
addOp flit|... FVAL|pushes float which is compiled immediately after it
addOp dlit|... DVAL|pushes double which is compiled immediately after it

addOp ->|V -> VAR|store V in VAR
addOp ->+|N ->+ VAR ...|add N to VAR, append for strings
addOp ->-|N ->- VAR ...|subtract N from VAR

addOp this|... OBJECT|get value of THIS object
addOp thisData|... OBJECT_DATA|get THIS object data pointer
addOp thisMethods|... OBJECT_METHODS|get THIS object data methods

addOp execute|OP ...|execute op which is on TOS
addOp call|IP ...|rpushes current IP and sets IP to that on TOS
addOp goto|IP ...|sets IP to that on TOS
addOp i|... LOOPINDEX_I|pushes innermost doloop index
addOp j|... LOOPINDEX_J|pushes next innermost doloop index
addOp unloop||remove do-loop info from rstack, use this before an 'exit' inside a do-loop
addOp leave||exit a do-loop continuing just after the 'loop'
addOp here|... DP|returns DP

addOp forth||overwrites the top of the vocabulary stack with forth vocabulary
addOp definitions||makes the top of the vocabulary stack be the destination of newly defined words
addOp vocabulary|vocabulary|VOCAB create a new vocabulary
addOp also||duplicates top of vocabulary stack, use "also vocab1" to add vocab1 to the stack above current vocab
addOp previous||drops top of vocabulary stack
addOp only||sets the vocabulary stack to just one element, forth, use "only vocab1" to make vocab1 the only vocab in stack
addOp forget|forget WORDNAME|forget named word and all newer definitions
addOp autoforget|autoforget WORDNAME|forget named word and all newer definitions, don't report error if WORDNAME is not defined yet
addOp vlist||display current search vocabulary
addOp find||

addOp align||aligns DP to a lonword boundary
addOp allot|A ...|adds A to DP, allocating A bytes
addOp ,|A ...|compiles longword A
addOp c,|A ...|compiles byte A
addOp malloc|A ... PTR|allocates a block of memory with A bytes
addOp realloc|IPTR A ... OPTR|resizes block at IPTR to be A bytes long, leaves new address OPTR
addOp free|PTR ...|frees a block of memory

addOp getConsoleOut|... OBJECT|get console output stream
addOp getDefaultConsoleOut|... OBJECT|get default console output stream
addOp setConsoleOut|OBJECT ...|set console output stream
addOp resetConsoleOut||set console output stream to default

addOp toupper|CHAR ... UCHAR|change character to upper case
addOp isupper|CHAR ... RESULT|test if character is upper case
addOp isspace|CHAR ... RESULT|test if character is whitespace
addOp isalpha|CHAR ... RESULT|test if character is alphabetic
addOp isgraph|CHAR ... RESULT|test if character is graphic
addOp tolower|CHAR ... LCHAR|change character to lower case
addOp islower|CHAR ... RESULT|test if character is lower case

addOp outToFile|FILE ...|redirect output to file
addOp outToScreen||set output to screen (standard out)
addOp outToString|STRING ...|redirect output to string
addOp outToOp|OP ...|redirect output to forth op (op takes a single string argument, returns nothing)
addOp getConOutFile|... FILE|returns redirected output file

addOp blword|... STRING_ADDR|fetch next whitespace-delimited token from input stream, return its address
addOp $word|CHARVAL ... STRING_ADDR|fetch next token delimited by CHARVAL from input stream, return its address
addOp /*|/* COMMENT TEXT */|inline comment, ends at '*/' or end of line
addOp (|( COMMENT TEXT )|inline comment, ends at ')' or end of line, only works if kFFParenIsComment feature is enabled
addOp features|... FEATURES|variable that allows you to enable and disable language features
addOp .features||displays what features are currently enabled
addOp source|... INPUT_BUFFER_ADDR LENGTH|return address of base of input buffer and its length
addOp >in|... INPUT_OFFSET_ADDR|return pointer to input buffer offset variable
addOp fillInBuffer|PROMPT_STRING ... INPUT_BUFFER_ADDR|display prompt, fill input buffer & return input buffer address

addOp time|... TIME_AS_INT64|
addOp strftime|BUFFADDR BUFFLEN FORMAT_STRING TIME_AS_INT64 ...|puts formatted string in buffer
addOp ms@|... TIME_AS_INT32|returns milliseconds since forth started running
addOp ms|MILLISECONDS ...|sleep for specified number of milliseconds

addOp rand|... VAL|returns pseudo-random number
addOp srand|VAL ...|sets pseudo-random number seed
addOp hash|PTR LEN HASHIN ... HASHOUT|generate a 32-bit hashcode for LEN bytes at PTR starting with initial hashcode HASHIN
addOp qsort|ARRAY_ADDR NUM_ELEMENTS ELEMENT_SIZE COMPARE_TYPE COMPARE_OFFSET ...|for strings, set COMPARE_TYPE to kBTString + (256 * maxLen)
addOp bsearch|KEY_ADDR ARRAY_ADDR NUM_ELEMENTS ELEMENT_SIZE COMPARE_TYPE COMPARE_OFFSET ... INDEX|(-1 if not found)

addOp dstack||display parameter stack
addOp drstack||display return stack
addOp system|STRING ... RESULT|pass DOS command line to system, returns exit code (0 means success)
addOp chdir|STRING ... RESULT|change current working directory, returns exit code (0 means success)
addOp remove|STRING ... RESULT|remove named file, returns exit code (0 means success)
addOp bye||exit forth
addOp argv|INDEX ... STRING_ADDR|return arguments from command line that started forth
addOp argc|... NUM_ARGUMENTS|return number of arguments from command line that started forth (not counting "forth" itself)
addOp turbo||switches between slow and fast mode
addOp stats||displays forth engine statistics
addOp describe|describe OPNAME|displays info on op, disassembles userops
addOp error|ERRORCODE ...|set the error code
addOp addErrorText|TEXT ...|add error text
addOp setTrace|FLAGS ...|turn tracing output on/off

addOp #if|BOOLVAL #if ... beginning of conditional compilation section
addOp #ifdef|#ifdef SYMBOL|beginning of conditional compilation section
addOp #ifndef|#ifndef SYMBOL|beginning of conditional compilation section
addOp #else|#else|begin else part of conditional compilation section
addOp #endif|#endif|end of conditional compilation sections

addOp CreateEvent|MANUALRESET INITIALSTATE NAMESTR ... HANDLE|
addOp CloseHandle|HANDLE ... RESULT|
addOp SetEvent|HANDLE ... RESULT|
addOp ResetEvent|HANDLE ... RESULT|
addOp PulseEvent|HANDLE ... RESULT|
addOp GetLastError|... LASTERROR|
addOp WaitForSingleObject|HANDLE TIMEOUT ... RESULT|
addOp WaitForMultipleObject|NUMHANDLES HANDLESPTR WAITALL TIMEOUT ... RESULT|
addOp InitializeCriticalSection|CRITSECTIONPTR ...|
addOp DeleteCriticalSection|CRITSECTIONPTR ...|
addOp EnterCriticalSection|CRITSECTIONPTR ...|
addOp LeaveCriticalSection|CRITSECTIONPTR ...|
addOp createThread|PSTACK_SIZE RSTACK_SIZE THREAD_OPCODE ... THREADPTR|
addOp destroyThread|THREADPTR ...|
addOp startThread|THREADPTR ... RESULT|
addOp exitThread||
addOp FindFirstFile|PATHSTR FINDDATA_PTR ... SEARCH_HANDLE|
addOp FindNextFile|SEARCH_HANDLE FINDDATA_PTR ... RESULT|
addOp FindClose|SEARCH_HANDLE ... RESULT|
addOp windowsConstants|... PTR_TO_CONSTANTS|
addOp dumpProfile|... dump opcode execution counts. start profiling with setTrace(1024)|
addOp resetProfile|... reset opcode execution counts.|

loaddone
