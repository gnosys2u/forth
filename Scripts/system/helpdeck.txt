
lf notedeck.txt

autoforget HELPDECK
: HELPDECK ;

class: HelpDeck extends NoteDeck

  NoteSchema opSchema
  NoteDef stackParamDef
  NoteSchema classSchema
  NoteSchema methodSchema
  Note opsNote
  Note classesNote
  Note newestClassNote
  long curFlags

  long kHFOp
  long kHFMethod
  long kHFClass

  m: init
    super.init("help")
  
    addParamDef("stack" "stack behavior") -> stackParamDef
  
    addSchema("opDef" "operator definition") -> opSchema
    opSchema.addOptionalParam(stackParamDef)

    addSchema("classDef" "class definition") -> classSchema

    addSchema("methodDef" "method definition") -> methodSchema
    methodSchema.addOptionalParam(stackParamDef)
    
    1L -> kHFOp
    2L -> kHFMethod
    4L -> kHFClass
    
    addNote("ops" "forth operators") -> opsNote
    addNote("classes" "builtin classes") -> classesNote
  ;m
  
  m: delete
    oclear opSchema
    oclear stackParamDef
    oclear classSchema
    oclear methodSchema
    oclear newestClassNote
    oclear opsNote
    oclear classesNote
  ;m
  
  m: setFlags
    ptrTo byte flagName
    NoteFlagDef flagDef
    
    0l -> curFlags
    begin
    while(blword?)
      -> flagName
      if(flagMap.grab(flagName))
        ->o flagDef
        flagDef.mask ->+ curFlags  // note: this assumes no duplicate flag values
        //flagName %s %bl flagDef.mask %2x %bl
      else
        // TODO: report error, flag not found
      endif
    repeat
    //"flags set to " %s curFlags %x %nl
  ;m
  
  m: getOpNote            // NAME ...   false   OR   NOTE_OBJ true
    opsNote.getChild
  ;m
  
  m: getClassNote            // NAME ...   false   OR   NOTE_OBJ true
    classesNote.getChild
  ;m
  
  // addOp opName|stack behavior|description|extra flags
  m: addOp
    Note newNote
    curFlags kHFOp l+ -> long flags
    ptrTo byte opName
    ptrTo byte flagName
  
    if(word?('|'))
      -> opName
      //opName %s %nl
      addChild(opName "" opsNote) -> newNote
      
      // look for stack behavior
      if(word?('|'))
        mko NoteParam newParam
        new String -> newParam.sval
        newParam.sval.set
        newNote.params.set(newParam stackParamDef.id)
        oclear newParam
      endif
      
      // look for description
      if(word?('|'))
        newNote.body.set
      endif
      
      // look for extra flags
      begin
      while(blword?)
        -> flagName
        if(getFlag(flagName))
          <NoteFlagDef>.mask ->+ flags  // note: this assumes no duplicate flag values
        else
          error("addOp - extra flag not found")
        endif
        
      repeat
      
      flags -> newNote.flags
    else
      error("addOp - op name missing")
    endif
  
    oclear newNote  
  ;m
  
  // addClass className|baseClass|description|flags
  m: addClass
    kHFClass -> long flags
    ptrTo byte className
    ptrTo byte flagName
  
    if(word?('|'))
      -> className
      //className %s %nl
      addChild(className "" classesNote) -> newestClassNote
      
      // look for baseClass
      if(word?('|'))
        // TODO!
        drop
      endif
      
      // look for description
      if(word?('|'))
        newestClassNote.body.set
      endif
      
      // look for flags
      begin
      while(blword?)
        -> flagName
        if(getFlag(flagName))
          <NoteFlagDef>.mask ->+ flags  // note: this assumes no duplicate flag values
        else
          error("addOp - extra flag not found")
        endif
        
      repeat
      
      flags -> newestClassNote.flags
    else
      error("addClass - class name missing")
    endif
  ;m
  
  // addMethod methodName|stack behavior|description|extra flags
  m: addMethod
    Note newMethodNote
    curFlags kHFOp l+ -> long flags
    ptrTo byte methodName
    ptrTo byte flagName
  
    if(word?('|'))
      -> methodName
      //methodName %s %nl
      addChild(methodName "" newestClassNote) -> newMethodNote
      newestClassNote.id -> newMethodNote.parent
      
      // look for stack behavior
      if(word?('|'))
        mko NoteParam newParam
        new String -> newParam.sval
        newParam.sval.set
        newMethodNote.params.set(newParam stackParamDef.id)
        oclear newParam
      endif
      
      // look for description
      if(word?('|'))
        newMethodNote.body.set
      endif
      
      // look for extra flags
      begin
      while(blword?)
        -> flagName
        if(getFlag(flagName))
          <NoteFlagDef>.mask ->+ flags  // note: this assumes no duplicate flag values
        else
          error("addOp - extra flag not found")
        endif
        
      repeat
      
      flags -> newMethodNote.flags
    else
      error("addMethod - method name missing")
    endif
  
    oclear newMethodNote  
  ;m
  
  m: listOperators
    Note foundNote
    notes.headIter -> ArrayIter iter
    
    begin
    while(iter.next)
      ->o foundNote
      if(foundNote.flags kHFOp land l0<>)
        foundNote.name.get %s " - " %s foundNote.body.get %s %nl
        //foundNote.name.get %s %bl foundNote.flags %2x " - " %s foundNote.body.get %s %nl
      endif
    repeat
    oclear iter
  ;m  

  m: listClasses
    Note foundNote
    notes.headIter -> ArrayIter iter
    
    begin
    while(iter.next)
      ->o foundNote
      if(foundNote.flags kHFClass land l0<>)
        foundNote.name.get %s " - " %s foundNote.body.get %s %nl
      endif
    repeat
    oclear iter
  ;m
  
  m: help
    Note foundNote
    NoteParam stackBehavior
    
    if(blword?)
      -> ptrTo byte helpTarget
      if(strcmp(helpTarget "classes") 0=)
      
        listClasses
        
      else
      
        if(classesNote.getChild(helpTarget))
          ->o foundNote
          helpTarget %s " - " %s foundNote.body.get %s %nl
         
          foundNote.children.headIter -> StringMapIter mapIter
          begin
          while(mapIter.next)
            ->o Note methodNote
            "   " %s methodNote.name.get %s " - " %s methodNote.body.get %s %nl
            if(methodNote.getParam(stackParamDef.id))
              ->o stackBehavior
              "      " %s stackBehavior.sval.get %s %nl
            endif
          repeat
        else
          if(opsNote.getChild(helpTarget))
            ->o foundNote
            helpTarget %s " - " %s foundNote.body.get %s %nl
            if(foundNote.getParam(stackParamDef.id))
              ->o stackBehavior
              stackBehavior.sval.get %s %nl
            endif
          else
            "help - " %s helpTarget %s " not found\n" %s
          endif
        endif
      endif
    else
      "=========== Operators ===========\n" %s
      listOperators
      "=========== Classes ===========\n" %s
      listClasses
    endif
  ;m
;class

mko HelpDeck helpDeck
helpDeck.init

: cleanupHelp
  oclear helpDeck
;


: mkf
  helpDeck.addFlagDef(blword $word('|') $word(0)) 2drop
;

// op, method and class must be first three flags to match with kHFOp, kHFMethod and kHFClass
mkf op Operator|An executable forth operation
mkf method Methods|Class methods
mkf class Builtin classes|Convenience classes - arrays, lists, maps, strings, threads, etc.

mkf control Control|Ops which change the flow of execution
mkf immediate Immediate|Ops which are executed at compile time
mkf classdef Class defining|Ops which are used to define classes or class instances
mkf method Methods|Class methods
mkf struct Structure defining|Ops which are used to define structures
mkf stack Parameter stack manipulation|Ops which manipulate the parameter stack
mkf logic Logical|Ops which do logic operations
mkf math Arithmetic|Ops which do math

mkf int 32-bit integer|Ops for 32-bit integers
mkf float Single-precision floating-point|Ops for single-precision floating point numbers
mkf double Double-precision floating-point|Ops for double-precision floating point numbers
mkf long 64-bit integer|Ops for 64-bit integers
mkf string String|Ops for strings

mkf print Printing|Ops which output to the console
mkf format Formatting|Ops which format text
mkf internal Internal|Forth compilation internals
mkf defining Defining words|Ops for defining ops and functions
mkf native Native type defining words|Ops for defining variables or fields of native types - int, float, double, etc.
mkf compare Comparison|Compare numeric values
mkf convert Conversion|Conversion between numeric types
mkf memory Memory|Memory fetch and store
mkf file File|Ops for files
mkf dir Directory|Ops for directories
mkf system System|System ops
mkf if If|Part of if statement
mkf case Case|Part of case statement
mkf loop Loop|Part of do or begin loops

// add string compile if loop case except
// ? short byte unsigned

: flags:
  helpDeck.setFlags
;

: addOp
  helpDeck.addOp
;

: addClass
  helpDeck.addClass
;

: addMethod
  helpDeck.addMethod
;

: help
  helpDeck.help
;

flags: control
addOp if|BOOL ...|start if statement|if
addOp andif|BOOL ...|add andif clause|if
addOp orif|BOOL ...|add orif clause|if
addOp else||start else branch of if statement|if
addOp endif||end if statement|if
addOp begin||begin loop statement|loop
addOp until|BOOL ...|loop back to "begin" if BOOL is false|loop
addOp while|BOOL ...|exit loop after "repeat" if BOOL is false|loop
addOp repeat||end loop statement|loop
addOp again||loop back to "begin"|loop
addOp do|ENDVAL STARTVAL ...|start do loop, ends at ENDVAL-1|loop
addOp loop||end do loop|loop
addOp +loop|INCREMENT ...|end do loop, add INCREMENT to index each time|loop
addOp case|TESTVAL ... |begin case statement|case
addOp of|CASEVAL ... |begin one case branch|case
addOp endof||end case branch|case
addOp endcase|TESTVAL ...|end all cases - drops TESTVAL|case
addOp abort||terminate execution with fatal error

flags: stack
addOp drop|VAL ...|drop top element of param stack
addOp dup|A ... A A|duplicate top of stack
addOp ?dup|VARIABLE|duplicate TOS if non 0
addOp swap|A B ... B A|swap top two elements of stack
addOp over|A B ... A B A|copy second stack element to top of stack
addOp rot|A B C ... B C A|rotate third stack element to top of stack
addOp -rot|A B C ... C A B|
addOp nip|A B C ... A C|
addOp tuck|A B C ... A C B C|
addOp pick|A ... PS(A)|
addOp roll|N ...|rolls Nth item to top of params stack
addOp sp|... PARAM_STACK_PTR|
addOp s0|... EMPTY_PARAM_STACK_PTR|
addOp fp|... LOCAL_VAR_FRAME_PTR|
addOp 2dup|DA ... DA DA|
addOp 2swap|DA DB ... DB DA|
addOp 2drop|DA ...|
addOp 2over|DA DB ... DA DB DA|
addOp 2rot|DA DB DC ... DB DC DA|
addOp r[||push SP on rstack, used with ]r to count a variable number of arguments
addOp ]r||remove old SP from rstack, push count of elements since r[ on TOS

flags: internal
addOp _doDoes||compiled at start of "does" section of words created by a builds...does word
addOp _doVariable||compiled at start of words defined by "variable"
addOp _doConstant||compiled at start of words defined by "constant"
addOp _doDConstant||compiled at start of words defined by "dconstant"
addOp _endBuilds||compiled at end of "builds" section
addOp done||makes inner interpreter return - used by outer interpreter
addOp _doByte||compiled at start of byte global vars
addOp _doShort||compiled at start of short global vars
addOp _doInt||compiled at start of int global vars
addOp _doFloat||compiled at start of float global vars
addOp _doDouble||compiled at start of double global vars
addOp _doString||compiled at start of string global vars
addOp _doOp||compiled at start of opcode global vars
addOp _doLong||compiled at start of long global vars
addOp _doObject||compiled at start of object global vars
addOp _doUByte||compiled at start of unsigned byte global vars
addOp _doUShort||compiled at start of unsigned short global vars
addOp _exit||compiled at end of user definitions which have no local vars
addOp _exitL||compiled at end of user definitions which have local vars
addOp _exitM||compiled at end of method definitions which have no local vars
addOp _exitML||compiled at end of method definitions which have local vars
addOp _doVocab||compiled at start of vocabularies
addOp _doByteArray||compiled at start of byte global arrays
addOp _doShortArray||compiled at start of short global arrays
addOp _doIntArray||compiled at start of int global arrays
addOp _doFloatArray||compiled at start of float global arrays
addOp _doDoubleArray||compiled at start of double global arrays
addOp _doStringArray||compiled at start of string global arrays
addOp _doOpArray||compiled at start of opcode global arrays
addOp _doLongArray||compiled at start of 64-bit global arrays
addOp _doObjectArray||compiled at start of object global arrays
addOp _doUByteArray||compiled at start of opcode global arrays
addOp _doUShortArray||compiled at start of opcode global arrays
addOp initString||compiled when a local string variable is declared
addOp initStringArray||compiled when a local string array is declared
addOp badOp||set bad opcode error
addOp _doStruct||compiled at start of opcode global arrays
addOp _doStructArray||compiled at start of global structure array instances, next word is padded element length
addOp _doStructType||compiled at the start of each user-defined structure defining word 
addOp _doClassType||compiled at the start of each user-defined class defining word 
addOp _doEnum||compiled at start of enum defining word, acts just like 'int'
addOp _do||compiled at start of do loop
addOp _loop||compiled at end of do loop
addOp _+loop||compiled at end of do +loop
addOp _doNew|CLASS_TYPE_INDEX ... NEW_OBJECT|compiled by 'new', takes class type index, executes class 'new' operator|classdef
addOp _allocObject|CLASS_VOCAB_PTR...NEW_OBJECT|default class 'new' operator, mallocs spaces for a new object instance and pushes new object|classdef
addOp vocabToClass||varop setter, putting this before a vocab op makes it return vocabs class object

flags: int math
addOp +|A B ... (A+B)|add top two items
addOp -|A B ... (A-B)|subtract top two items
addOp *|A B ... (A*B)|mutliply top two items
addOp 2*|A ... (A*2)|multiply top item by 2
addOp 4*|A ... (A*4)|multiply top item by 4
addOp 8*|A ... (A*8)|multiply top item by 8
addOp /|A B ... (A/B)|divide top two items
addOp 2/|A ... (A/2)|divide top item by 2
addOp 4/|A ... (A/4)|divide top item by 4
addOp 8/|A ... (A/8)|divide top item by 4
addOp /mod|A B ... (A/B) (A mod B)|divide top two items, return quotient & remainder
addOp mod|A B ... (A mod B)|take modulus of top two items
addOp negate|A ... (-A)|negate top item

flags: int compare
addOp =|A B ... A=B|
addOp <>|A B ... A<>B|
addOp >|A B ... A>B|
addOp >=|A B ... A>=B|
addOp <|A B ... A<B|
addOp <=|A B ... A<=B|
addOp 0=|A ... A=0|
addOp 0<>|A ... A<>0|
addOp 0>|A ... A>0|
addOp 0>=|A ... A>=0|
addOp 0<|A ... A<0|
addOp 0<=|A ... A<=0|
addOp u>|A B ... A>B|unsigned comparison
addOp u<|A B ... A<B|unsigned comparison
addOp within|VAL LO HI ... (LO<=VAL<HI)|
addOp min|A B ... min(A,B)|
addOp max|A B ... max(A,B)|

flags: float math
addOp f+|FA FB ... (FA+FB)|add top two floating point items
addOp f-|FA FB ... (FA-FB)|subtract top two floating point items
addOp f*|FA FB ... (FA*FB)|multiply top two floating point items
addOp f/|FA FB ... (FA/FB)|divide top two floating point items
addOp fsin|FA ... sin(FA)|float sine
addOp farcsin|FA ... arcsin(FA)|float arcsine
addOp fcos|FA ... cos(FA)|float cosine
addOp farccos|FA ... arccos(FA)|float arccosine
addOp ftan|FA ... tan(FA)|float tan
addOp farctan|FA ... arctan(FA)|float arctan
addOp farctan2|FA FB ... arctan(FA/FB)|float arctan of ratio
addOp fexp|FA ... exp(FA)|
addOp fln|FA ... ln(FA)|
addOp flog10|FA ... log10(FA)|
addOp fpow|FA FB ... FA**FB|
addOp fsqrt|FA ... sqrt(FA)|
addOp fceil|FA ... ceil(FA)|
addOp ffloor|FA ... floor(FA)|
addOp fabs|FA ... abs(FA)|
addOp fldexp|FA B ... ldexp(FA,B)|
addOp ffrexp|FA ... frac(FA) exponent(FA)|
addOp fmodf|FA ... frac(FA) whole(FA)|
addOp ffmod|FA FB ... fmod(FA,FB)|

flags: float compare
addOp f=|FA FB ... FA=FB|
addOp f<>|FA FB ... FA<>FB|
addOp f>|FA FB ... FA>FB|
addOp f>=|FA FB ... FA>=FB|
addOp f<|FA FB ... FA<FB|
addOp f<=|FA FB ... FA<=FB|
addOp f0=|FA ... FA=0|
addOp f0<>|FA ... FA<>0|
addOp f0>|FA ... FA>0|
addOp f0>=|FA ... FA>=0|
addOp f0<|FA ... FA<0|
addOp f0<=|FA ... FA<=0|
addOp fwithin|FVAL FLO FHI ... (FLO<=FVAL<FHI)|
addOp fmin|FA FB... min(FA,FB)|
addOp fmax|FA FB... max(FA,FB)|

flags: float block
addOp fAddBlock|SRCA SRCB DST NUM ...|add blocks of NUM floats at SRCA and SRCB and store results in DST
addOp fSubBlock|SRCA SRCB DST NUM ...|subtract blocks of NUM floats at SRCA and SRCB and store results in DST
addOp fMulBlock|SRCA SRCB DST NUM ...|multiply blocks of NUM floats at SRCA and SRCB and store results in DST
addOp fDivBlock|SRCA SRCB DST NUM ...|divide blocks of NUM floats at SRCA and SRCB and store results in DST
addOp fScaleBlock|SRC DST SCALE NUM ...|multiply block of NUM floats at SRC by SCALE and store results in DST
addOp fOffsetBlock|SRC DST OFFSET NUM ...|add OFFSET to block of NUM floats at SRC and store results in DST
addOp fMixBlock|SRC DST SCALE NUM ...|multiply block of NUM floats at SRC by SCALE and add results into DST

flags: double math
addOp d+|DA DB ... (DA+DB)|add top two double floating point items
addOp d-|DA DB ... (DA-DB)|subtract top two double floating point items
addOp d*|DA DB ... (DA*DB)|multiply top two double floating point items
addOp d/|DA DB ... (DA/DB)|divide top two double floating point items
addOp dsin|DA ... sin(DA)|double sine
addOp darcsin|DA ... arcsin(DA)|double arcsine
addOp dcos|DA ... cos(DA)|double cosine
addOp darccos|DA ... arccos(DA)|double arccosine
addOp dtan|DA ... tan(DA)|double tan
addOp darctan|DA ... arctan(DA)|double arctan
addOp darctan2|DA DB ... arctan(DA/DB)|double arctan of ratio
addOp dexp|DA ... exp(DA)|
addOp dln|DA ... ln(DA)|
addOp dlog10|DA ... log10(DA)|
addOp dpow|DA DB ... DA**DB|
addOp dsqrt|DA ... sqrt(DA)|
addOp dceil|DA ... ceil(DA)|
addOp dfloor|DA ... floor(DA)|
addOp dabs|DA ... abs(DA)|
addOp dldexp|DA B ... ldexp(DA,B)|
addOp dfrexp|DA ... frac(DA) exponent(DA)|
addOp dmodf|DA ... frac(DA) whole(DA)|
addOp dfmod|DA DB ... fmod(DA,DB)|

flags: double compare
addOp d=|DA DB ... DA=DB|double
addOp d<>|DA DB ... DA<>DB|
addOp d>|DA DB ... DA>DB|
addOp d>=|DA DB ... DA>=DB|
addOp d<|DA DB ... DA<DB|
addOp d<=|DA DB ... DA<=DB|
addOp d0=|DA ... DA=0|
addOp d0<>|DA ... DA<>0|
addOp d0>|DA ... DA>0|
addOp d0>=|DA ... DA>=0|
addOp d0<|DA ... DA<0|
addOp d0<=|DA ... DA<=0|
addOp dwithin|DVAL DLO DHI ... (DLO<=DVAL<DHI)|
addOp dmin|DA DB ... min(DA,DB)|
addOp dmax|DA DB ... max(DA,DB)|

flags: double block
addOp dAddBlock|SRCA SRCB DST NUM ...|add blocks of NUM doubles at SRCA and SRCB and store results in DST
addOp dSubBlock|SRCA SRCB DST NUM ...|subtract blocks of NUM doubles at SRCA and SRCB and store results in DST
addOp dMulBlock|SRCA SRCB DST NUM ...|multiply blocks of NUM doubles at SRCA and SRCB and store results in DST
addOp dDivBlock|SRCA SRCB DST NUM ...|divide blocks of NUM doubles at SRCA and SRCB and store results in DST
addOp dScaleBlock|SRC DST SCALE NUM ...|multiply block of NUM doubles at SRC by SCALE and store results in DST
addOp dOffsetBlock|SRC DST OFFSET NUM ...|add OFFSET to block of NUM doubles at SRC and store results in DST
addOp dMixBlock|SRC DST SCALE NUM ...|multiply block of NUM doubles at SRC by SCALE and add results into DST

flags: convert
addOp i2f|A ... float(A)|convert int to float|int float
addOp i2d|A ... double(A)|convert int to double|int double
addOp f2i|A ... int(A)|convert float to int|int float
addOp f2d|A ... double(A)|convert float to double|float double
addOp d2i|A ... int(A)|convert double to int|int double
addOp d2f|A ... float(A)|confert double to float|double float
addOp i2l|INTA ... LONGA|convert signed 32-bit int to signed 64-bit int|int long
addOp l2f|LONGA ... FLOATA|convert signed 64-bit int to 32-bit float|long float
addOp l2d|LONGA ... DOUBLEA|convert signed 64-bit int to 64-bit float|long double
addOp f2l|FLOATA ... LONGA|convert 32-bit float to signed 64-bit int|float long
addOp d2l|DOUBLEA ... LONGA|convert 64-bit float to signed 64-bit int|double long

flags: logic
addOp or|A B ... or(A,B)|
addOp and|A B ... and(A,B)|
addOp xor|A B ... xor(A,B)|
addOp invert|A ... ~A|
addOp lshift|A B ... A<<B|
addOp rshift|A B ... A>>B|
addOp urshift|A B ... A>>B|unsigned right shift
addOp not|A ... not(A)|true iff A is 0, else false
addOp true|... -1|
addOp false|... 0|
addOp null|... 0|

flags: rstack
addOp >r|A ...|pushes top of param stack on top of return stack
addOp r>|... A|pops top of return stack to top of param stack
addOp rdrop||drops top of return stack
addOp rp|... RETURN_STACK_PTR|return pointer to top of return stack
addOp r0|... EMPTY_RETURN_STACK_PTR|return pointer to bottom of return stack (top if empty)

flags: memory
addOp @|PTR ... A|fetches longword from address PTR
addOp 2@|PTR ... DA|fetch double from address PTR
addOp ref|ref VAR ... PTR|return address of VAR
addOp !|A PTR ...|stores longword A at address PTR
addOp c!|A PTR ...|stores byte A at address PTR
addOp c@|PTR ... A|fetches unsigned byte from address PTR
addOp sc@|PTR ... A|fetches signed byte from address PTR
addOp c2i|A ... LA|sign extends byte to long
addOp w!|A PTR ...|stores word A at address PTR
addOp w@|PTR ... A|fetches unsigned word from address PTR
addOp sw@|PTR ... A|fetches signed word from address PTR
addOp w2i|WA ... LA|sign extends word to long
addOp 2!|DA PTR ...|store double at address PTR
addOp move|SRC DST N ...|copy N bytes from SRC to DST
addOp fill|DST N A ...|fill N bytes at DST with byte value A
addOp varAction!|A varAction! ...|set varAction to A (use not recommended)
addOp varAction@|varAction@ ... A|fetch varAction (use not recommended)

flags: string
addOp strcpy|STRA STRB ...|copies string from STRB to STRA
addOp strncpy|STRA STRB N ...|copies up to N chars from STRB to STRA
addOp strlen|STR ... LEN|returns length of string at STR
addOp strcat|STRA STRB ...|appends STRB to string at STRA
addOp strncat|STRA STRB N ...|appends up to N chars from STRB to STRA
addOp strchr|STR CHAR ... PTR|returns ptr to first occurence of CHAR in string STR
addOp strrchr|STR CHAR ... PTR|returns ptr to last occurence of CHAR is string STR
addOp strcmp|STRA STRB ... V|returns 0 iff STRA = STRB, else result of last char comparison
addOp stricmp|STRA STRB ... V|returns 0 iff STRA = STRB ignoring case, else result of last char comparison
addOp strncmp|STRA STRB N ... V|returns 0 iff STRA = STRB ignoring case, else result of last char comparison, for first N chars
addOp strstr|STRA STRB ... PTR|returns ptr to first occurence of STRB in string STRA
addOp strtok|STRA STRB ... PTR|returns ptr to next token in STRA, delimited by a char in STRB, modifies STRA, pass 0 for STRA after first call

flags: file
addOp fopen|PATH_STR ATTRIB_STR ... FILE|open file
addOp fclose|FILE ... RESULT|close file
addOp fseek|FILE OFFSET CTRL ... RESULT|seek in file, CTRL: 0 from start, 1 from current, 2 from end 
addOp fread|NITEMS ITEMSIZE FILE ... RESULT|read items from file
addOp fwrite|NITEMS ITEMSIZE FILE ... RESULT|write items to file
addOp fgetc|FILE ... CHARVAL|read a character from file
addOp fputc|CHARVAL FILE ... RESULT|write a character to file
addOp feof|FILE ... RESULT|check if file is at end-of-file
addOp fexists|PATH_STR ... RESULT|check if file exists
addOp ftell|FILE ... OFFSET|return current read/write position in file
addOp flen|FILE ... FILE_LENGTH|return length of file
addOp fgets|BUFFER MAXCHARS FILE ... NUMCHARS|read a line of up to MAXCHARS from FILE into BUFFER
addOp fputs|BUFFER FILE ...|write null-terminated string from BUFFER to FILE
addOp stdin|... FILE|get standard in file
addOp stdout|... FILE|get standard out file
addOp stderr|... FILE|get standard error file

flags: long math
addOp l+|LA LB ... (LA+LB)|
addOp l-|LA LB ... (LA-LB)|
addOp l*|LA LB ... (LA*LB)|
addOp l/|LA LB ... (LA/LB)|
addOp lmod|LA LB ... (LA mod LB)|
addOp l/mod|A B ... (LA/LB) (LA mod LB)|divide top two items, return quotient & remainder
addOp lnegate|A ... (-LA)|negate top item

flags: long compare
addOp l=|LA LB ... LA=LB|
addOp l<>|LA LB ... LA<>LB|
addOp l>|LA LB ... LA>LB|
addOp l>=|LA LB ... LA>=LB|
addOp l<|LA LB ... LA<LB|
addOp l<=|LA LB ... LA<=LB|
addOp l0=|LA ... LA=0|
addOp l0<>|LA ... LA<>0|
addOp l0>|LA ... LA>0|
addOp l0>=|LA ... LA>=0|
addOp l0<|LA ... LA<0|
addOp l0<=|LA ... LA<=0|
addOp lwithin|LVAL LLO LHI ... (LLO<=LVAL<LHI)|
addOp lmin|LA LB ... min(LA,LB)|
addOp lmax|LA LB ... max(LA,LB)|

flags: except
addOp try||start of code section protected by exception handler
addOp except||start of exception handler code
addOp finally||defines code run after exception handler
addOp endtry||end of exception handler
addOp raise|EXCEPTION_NUM ...|raise an exception

flags: defining
addOp builds||starts a builds...does definition
addOp does||starts the runtime part of a builds...does definition
addOp exit||exit current hi-level op
addOp ;||ends a colon definition
addOp :||starts a colon definition
addOp f:||starts a function definition
addOp ;f||ends a function definition, leaves function opcode on stack
addOp code||starts an assembler definition
addOp create||starts a 
addOp variable|variable NAME|creates a variable op which pushes its address when executed
addOp constant|A constant NAME|creates a constant op which pushes A when executed
addOp 2constant|DA 2constant NAME|creates a double constant op which pushes DA when executed
addOp byte|byte VAR|declare a 8-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp ubyte|ubyte VAR|declare a unsigned 8-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp short|short VAR|declare a 16-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp ushort|ushort VAR|declare a unsigned 16-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp int|int VAR|declare a 32-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp uint|uint VAR|declare a unsigned 32-bit integer variable or field, may be preceeded with initializer "VAL ->"
addOp long|long VAR|declare a 64-bit int variable or field, may be preceeded with initializer "VAL ->"
addOp ulong|ulong VAR|declare a 64-bit unsigned int variable or field, may be preceeded with initializer "VAL ->"
addOp float|float VAR|declare a 32-bit floating point variable or field, may be preceeded with initializer "VAL ->"
addOp double|double VAR|declare a 64-bit floating point variable or field, may be preceeded with initializer "VAL ->"
addOp string|MAXLEN string NAME declare a string variable or field with a specified maximum length
addOp op|op VAR|declare a forthop variable or field
addOp void|returns void declare that a method returns nothing ?does this work?
addOp arrayOf|NUM arrayOf TYPE declare an array variable or field with NUM elements of specified TYPE
addOp ptrTo|ptrTo TYPE declare a pointer variable or field of specified TYPE
addOp struct:|struct: NAME|start a structure type definition
addOp ;struct||end a structure type definition
addOp union||within a structure definition, resets the field offset to 0
addOp sizeOf|sizeOf STRUCT_NAME ... STRUCT_SIZE_IN_BYTES|
addOp offsetOf|offsetOf STRUCT_NAME FIELD_NAME ... OFFSET_OF_FIELD_IN_BYTES|

addOp class:|class: NAME|start a class type definition|classdef
addOp ;class||end a class definition|classdef
addOp m:|m: NAME|start a class method definition|classdef
addOp ;m ||end a class method definition|classdef
addOp returns|returns TYPE|specify the return type of a method, can only occur in a class method definition|classdef
addOp doMethod|OBJECT METHOD# doMethod|execute specified method on OBJECT
addOp implements:|implements: NAME|start an interface definition within a class definition|classdef
addOp ;implements||ends an interface definition|classdef

addOp extends|extends NAME|within a class/struct definition, declares the parent class/struct|classdef
addOp new|new TYPE ... OBJECT|creates an object of specified type
addOp initMemberString|initMemberString NAME|used inside a method, sets the current and max len fields of named member string
addOp enum:|enum: NAME|starts an enumerated type definition
addOp ;enum||ends an enumerated type definition
addOp recursize||used inside a colon definition, allows it to invoke itself recursively
addOp precedence||used inside a colon definition, makes it have precedence (execute in compile mode)
addOp load|load PATH|start loading a forth source file whose name immediately follows "load"
addOp $load|PATH $load ...|start loading a forth source file whose name is on TOS
addOp loaddone||terminate loading a forth source file before the end of file
addOp requires|requires NAME|if forthop NAME exists do nothing, if not load NAME.txt
addOp $evaluate|STR $evaluate|interpret string on TOS
addOp ]||sets state to compile
addOp [||sets state to interpret
addOp state|... @STATE_ADDR|leaves address of "state" var on TOS
addOp '|' NAME|push opcode of NAME on TOS (does not have precedence)
addOp postpone|postpone NAME|compile opcode of NAME, including ops which have precedence
addOp compile|compile OPCODE|compile immediately following opcode (opcode must not have precedence)
addOp [']|['] NAME|push opcode of NAME (has precedence)

flags: print
addOp .|NUM ...|prints number in current base followed by space
addOp .2|LNUM ...|prints 64-bit number in current base followed by space
addOp %d|NUM ...|prints number in decimal
addOp %x|NUM ...|prints number in hex
addOp %2d|LNUM ...|prints 64-bit number in decimal
addOp %2x|LNUM ...|prints 64-bit number in hex
addOp %s|STRING ...|prints string
addOp %c|CHARVAL ...|prints character
addOp %nc|NUM CHARVAL ...|prints character NUM times
addOp spaces|NUM ...|prints NUM spaces
addOp type|STRING NCHARS ...|print a block of NCHARS characters of text
addOp %4c|NUM ...|prints 32-bit int as 4 characters
addOp %8c|LNUM ...|prints 64-bit int as 8 characters
addOp %bl||prints a space
addOp %nl||prints a newline
addOp %f|FPNUM ...|prints a single-precision floating point number with %f format
addOp %2f|DOUBLE_FPNUM ...|prints a double-precision floating point number with %f format
addOp %g|FPNUM ...|prints a single-precision floating point number with %g format
addOp %2g|DOUBLE_FPNUM ...|prints a double-precision floating point number with %g format
addOp format|ARG FORMAT_STRING ... STRING_ADDR|format a 32-bit numeric value
addOp 2format|ARG64 FORMAT_STRING ... STRING_ADDR|format a 64-bit numeric value
addOp addTempString|STRING NUM ... TSTRING|allocate a temporary string - STRING may be null or NUM may be 0
addOp atoi|STRING ... NUM|convert string to integer
addOp atof|STRING ... DOUBLE|convert string to double-precision floating point
addOp fprintf|FILE FORMAT_STRING (ARGS) NUM_ARGS ... RESULT|print formatted string to file
addOp snprintf|BUFFER BUFFER_SIZE FORMAT_STRING (ARGS) NUM_ARGS ... RESULT|print formatted string to BUFFER
addOp fscanf|FILE FORMAT_STRING (ARGS) NUM_ARGS ... RESULT|read formatted string from file
addOp sscanf|BUFFER FORMAT_STRING (ARGS) NUM_ARGS ... RESULT|read formatted string from BUFFER
addOp base|leaves address of "base" var on TOS
addOp octal|sets current base to 8
addOp decimal|sets current base to 10
addOp hex|sets current base to 16
addOp printDecimalSigned|makes all decimal printing signed, printing in any other base is unsigned 
addOp printAllSigned|makes printing in any base signed
addOp printAllUnsigned|makes printing in any base unsigned

flags: dll
addOp DLLVocabulary|DLLVocabulary VOCAB_NAME DLL_FILEPATH|creates a new DLL vocabulary, also loads the dll
addOp addDLLEntry|NUM_ARGS "ENTRY_NAME" ...|adds a new entry point to current definitions DLL vocabulary
addOp addDLLEntryEx|NUM_ARGS "OP_NAME" "ENTRY_NAME" ...|adds a new entry point to current definitions DLL vocabulary
addOp DLLVoid||when used prior to dll_0...dll_15, newly defined word will return nothing on TOS

addOp lit|... IVAL|pushes longword which is compiled immediately after it
addOp flit|... FVAL|pushes float which is compiled immediately after it
addOp dlit|... DVAL|pushes double which is compiled immediately after it

addOp ->|V -> VAR|store V in VAR
addOp ->+|N ->+ VAR ...|add N to VAR, append for strings
addOp ->-|N ->- VAR ...|subtract N from VAR

addOp this|... OBJECT|get value of THIS object
addOp thisData|... OBJECT_DATA|get THIS object data pointer
addOp thisMethods|... OBJECT_METHODS|get THIS object data methods

addOp execute|OP ...|execute op which is on TOS
addOp call|IP ...|rpushes current IP and sets IP to that on TOS
addOp goto|IP ...|sets IP to that on TOS
addOp i|... LOOPINDEX_I|pushes innermost doloop index
addOp j|... LOOPINDEX_J|pushes next innermost doloop index
addOp unloop||remove do-loop info from rstack, use this before an 'exit' inside a do-loop
addOp leave||exit a do-loop continuing just after the 'loop'
addOp here|... DP|returns DP

addOp forth||overwrites the top of the vocabulary stack with forth vocabulary
addOp definitions||makes the top of the vocabulary stack be the destination of newly defined words
addOp vocabulary|vocabulary|VOCAB create a new vocabulary
addOp also||duplicates top of vocabulary stack, use "also vocab1" to add vocab1 to the stack above current vocab
addOp previous||drops top of vocabulary stack
addOp only||sets the vocabulary stack to just one element, forth, use "only vocab1" to make vocab1 the only vocab in stack
addOp forget|forget WORDNAME|forget named word and all newer definitions
addOp autoforget|autoforget WORDNAME|forget named word and all newer definitions, don't report error if WORDNAME is not defined yet
addOp vlist||display current search vocabulary
addOp find||

addOp align||aligns DP to a lonword boundary
addOp allot|A ...|adds A to DP, allocating A bytes
addOp ,|A ...|compiles longword A
addOp c,|A ...|compiles byte A
addOp malloc|A ... PTR|allocates a block of memory with A bytes
addOp realloc|IPTR A ... OPTR|resizes block at IPTR to be A bytes long, leaves new address OPTR
addOp free|PTR ...|frees a block of memory

addOp getConsoleOut|... OBJECT|get console output stream
addOp getDefaultConsoleOut|... OBJECT|get default console output stream
addOp setConsoleOut|OBJECT ...|set console output stream
addOp resetConsoleOut||set console output stream to default

addOp toupper|CHAR ... UCHAR|change character to upper case
addOp isupper|CHAR ... RESULT|test if character is upper case
addOp isspace|CHAR ... RESULT|test if character is whitespace
addOp isalpha|CHAR ... RESULT|test if character is alphabetic
addOp isgraph|CHAR ... RESULT|test if character is graphic
addOp tolower|CHAR ... LCHAR|change character to lower case
addOp islower|CHAR ... RESULT|test if character is lower case

addOp outToFile|FILE ...|redirect output to file
addOp outToScreen||set output to screen (standard out)
addOp outToString|STRING ...|redirect output to string
addOp outToOp|OP ...|redirect output to forth op (op takes a single string argument, returns nothing)
addOp getConOutFile|... FILE|returns redirected output file

addOp blword|... STRING_ADDR|fetch next whitespace-delimited token from input stream, return its address
addOp $word|CHARVAL ... STRING_ADDR|fetch next token delimited by CHARVAL from input stream, return its address
addOp /*|/* COMMENT TEXT */|inline comment, ends at '*/' or end of line
addOp (|( COMMENT TEXT )|inline comment, ends at ')' or end of line, only works if kFFParenIsComment feature is enabled
addOp features|... FEATURES|variable that allows you to enable and disable language features
addOp .features||displays what features are currently enabled
addOp source|... INPUT_BUFFER_ADDR LENGTH|return address of base of input buffer and its length
addOp >in|... INPUT_OFFSET_ADDR|return pointer to input buffer offset variable
addOp fillInBuffer|PROMPT_STRING ... INPUT_BUFFER_ADDR|display prompt, fill input buffer & return input buffer address

addOp time|... TIME_AS_INT64|
addOp strftime|BUFFADDR BUFFLEN FORMAT_STRING TIME_AS_INT64 ...|puts formatted string in buffer
addOp ms@|... TIME_AS_INT32|returns milliseconds since forth started running
addOp ms|MILLISECONDS ...|sleep for specified number of milliseconds

addOp rand|... VAL|returns pseudo-random number
addOp srand|VAL ...|sets pseudo-random number seed
addOp hash|PTR LEN HASHIN ... HASHOUT|generate a 32-bit hashcode for LEN bytes at PTR starting with initial hashcode HASHIN
addOp qsort|ARRAY_ADDR NUM_ELEMENTS ELEMENT_SIZE COMPARE_TYPE COMPARE_OFFSET ...|for strings, set COMPARE_TYPE to kBTString + (256 * maxLen)
addOp bsearch|KEY_ADDR ARRAY_ADDR NUM_ELEMENTS ELEMENT_SIZE COMPARE_TYPE COMPARE_OFFSET ... INDEX|(-1 if not found)

addOp dstack||display parameter stack
addOp drstack||display return stack
addOp system|STRING ... RESULT|pass DOS command line to system, returns exit code (0 means success)
addOp chdir|STRING ... RESULT|change current working directory, returns exit code (0 means success)
addOp remove|STRING ... RESULT|remove named file, returns exit code (0 means success)
addOp bye||exit forth
addOp argv|INDEX ... STRING_ADDR|return arguments from command line that started forth
addOp argc|... NUM_ARGUMENTS|return number of arguments from command line that started forth (not counting "forth" itself)
addOp turbo||switches between slow and fast mode
addOp stats||displays forth engine statistics
addOp describe|describe OPNAME|displays info on op, disassembles userops
addOp error|ERRORCODE ...|set the error code
addOp addErrorText|TEXT ...|add error text
addOp setTrace|FLAGS ...|turn tracing output on/off

addOp #if|BOOLVAL #if ... beginning of conditional compilation section
addOp #ifdef|#ifdef SYMBOL|beginning of conditional compilation section
addOp #ifndef|#ifndef SYMBOL|beginning of conditional compilation section
addOp #else|#else|begin else part of conditional compilation section
addOp #endif|#endif|end of conditional compilation sections

addOp CreateEvent|MANUALRESET INITIALSTATE NAMESTR ... HANDLE|
addOp CloseHandle|HANDLE ... RESULT|
addOp SetEvent|HANDLE ... RESULT|
addOp ResetEvent|HANDLE ... RESULT|
addOp PulseEvent|HANDLE ... RESULT|
addOp GetLastError|... LASTERROR|
addOp WaitForSingleObject|HANDLE TIMEOUT ... RESULT|
addOp WaitForMultipleObject|NUMHANDLES HANDLESPTR WAITALL TIMEOUT ... RESULT|
addOp InitializeCriticalSection|CRITSECTIONPTR ...|
addOp DeleteCriticalSection|CRITSECTIONPTR ...|
addOp EnterCriticalSection|CRITSECTIONPTR ...|
addOp LeaveCriticalSection|CRITSECTIONPTR ...|
addOp createThread|PSTACK_SIZE RSTACK_SIZE THREAD_OPCODE ... THREADPTR|
addOp destroyThread|THREADPTR ...|
addOp startThread|THREADPTR ... RESULT|
addOp exitThread||
addOp FindFirstFile|PATHSTR FINDDATA_PTR ... SEARCH_HANDLE|
addOp FindNextFile|SEARCH_HANDLE FINDDATA_PTR ... RESULT|
addOp FindClose|SEARCH_HANDLE ... RESULT|
addOp windowsConstants|... PTR_TO_CONSTANTS|
addOp dumpProfile|... dump opcode execution counts. start profiling with setTrace(1024)|
addOp resetProfile|...|reset opcode execution counts.

//=============================================================================================

addClass Object||base object class
addMethod delete|...|delete the object - do not invoke this
addMethod show|...|show object contacts in json-like format
addMethod showInner|...|shows innards of object|internal
addMethod getClass|... CLASS_OBJECT|return the Class object this object is an instance of
addMethod compare|OBJECT ... -1/0/1|compare this object to OBJECT, used for Array sort method
addMethod keep|...|add 1 to this objects reference count
addMethod release|...|subtract 1 from this objects reference count

addClass Class|Object|Class object
addMethod create|... OBJECT|create a new instance of this class
addMethod getParent|... SUPERCLASS_OBJECT|get the class object for the parent of this class
addMethod getName|... CLASSNAME|get the class name string
addMethod getVocabulary|... VOCAB_PTR|get the class vocabulary pointer
addMethod getInterface|INTERFACE_NAME ... OBJECT|get named interface methods
addMethod setNew|OP ...|set 'new' operator for this class

addClass Iter|Object|Abstract iterator
addMethod seekNext|...|move iterator to next element
addMethod seekPrev|...|move iterator to previous element
addMethod seekHead|...|move iterator to first element
addMethod seekTail|...|move iterator to last element
addMethod next|... OBJECT true   OR   false|return item at iterator cursor and true, return false if already at last element, advance to next element
addMethod prev|... OBJECT true   OR   false|return item at iterator cursor and true, return false if already at first element, advance to previous element
addMethod current|... OBJECT true   OR   false|return item at iterator cursor and true, return false if already at last element
addMethod remove|...|remove the object in the associated collection at the iterator position
addMethod unref|... OBJECT|return the object in the associated collection at the iterator position and stick a null object in its place in collection
addMethod clone|... THIS_ITER|return a copy of this iterator

addClass Iterable|Object|Abstract iterable container class
addMethod headIter|... ITER_OBJECT|return an iterator positioned at start of this container
addMethod tailIter|... ITER_OBJECT|return an iterator positioned at end of this container
addMethod find|SOUGHT_THING ... ITER_OBJECT true   OR   false|return iterator positioned at SOUGHT_THING
addMethod clone|... CLONE_OBJECT|return a copy of this container including its contents
addMethod count|... count|return number of objects in this container
addMethod clear|...|empty container

addClass Array|Iterable|array of objects
addMethod get|INDEX ... OBJECT|get array object at specified index
addMethod set|OBJECT INDEX ...|set array object at specified index
addMethod ref|INDEX ... OBJECT_PTR|return address of object at INDEX
addMethod swap|INDEX_I INDEX_J ...|swap objects at specified indices
addMethod resize|NEW_SIZE ...|set array size to NEW_SIZE objects
addMethod insert|OBJECT INDEX ...|insert OBJECT at INDEX
addMethod remove|INDEX ... OBJECT|remove OBJECT at specified index
addMethod push|OBJECT ...|add OBJECT to end of array
addMethod pop|... OBJECT|remove last OBJECT in array
addMethod base|... OBJECT_PTR|return address of first object in array
addMethod load|<N OBJECTS> N ...|set array to contain N objects on stack
addMethod fromMemory|OBJECT_PTR N OFFSET ...|copy N objects from memory at OBJECT_PTR into array starting at index OFFSET
addMethod find|OBJECT ... ITER_OBJECT true   OR   false|return iterator positioned at OBJECT plus true, or just false if not found in array
addMethod findValue|OBJECT ... INDEX|return INDEX of object in array, return -1 if object not found
addMethod reverse|...|reverse order of elements in array
addMethod sort|...|sort array objects using their compare method - objects must have same type
addMethod toList|... NEW_LIST_OBJECT|create a List object with the same elements in the array

addClass ArrayIter|Iter|array iterator
addMethod seek|INDEX ...|set iterator to position specified by INDEX
addMethod findNext|SOUGHT_OBJECT ... BOOL|return true if found, iterator is positioned at SOUGHT_OBJECT
addMethod insert|OBJECT ...|insert OBJECT in collection just before current iterator position

addClass Bag|Iterable|bag of objects
addMethod get|INDEX ... OBJECT LONG_TAG|get object,tag pair at specified index
addMethod geto|INDEX ... OBJECT|get object at specified index
addMethod gett|INDEX ... LONG_TAG|get tag at specified index
addMethod set|OBJECT LONG_TAG INDEX ...|set object,tag pair into position specified by index
addMethod ref|INDEX ... PAIR_PTR|get address of object,tag pair specified by index
addMethod swap|INDEX_I INDEX_J ...|swap pairs at specified indices
addMethod resize|NEW_SIZE ...|set bag size to NEW_SIZE pairs
addMethod insert|OBJECT LONG_TAG INDEX ...|insert pair at INDEX
addMethod remove|INDEX ... OBJECT LONG_TAG|remove pair at specified index
addMethod push|OBJECT LONG_TAG...|add pair to end of bag
addMethod pop|... OBJECT LONG_TAG|remove last pair in bar
addMethod base|... PAIR_PTR|return address of first pair in bag
addMethod load|<N PAIRS> N ...|set bag to contain N pairs on stack
addMethod fromMemory|PAIR_PTR N OFFSET ...|copy N pairs from memory at PAIR_PTR into bag starting at index OFFSET
addMethod find|LONG_TAG ... ITER_OBJECT true   OR   false|return iterator positioned at pair with tag plus true, or just false if not found in bag
addMethod findValue|LONG_TAG ... INDEX|return INDEX of pair with tag in array, return -1 if tag not found
addMethod grab|LONG_TAG ... OBJECT true   OR   false|return object with tag plus true, or just false if not found
addMethod toLongMap|... NEW_LMAP_OBJECT|create a LongMap object with same elements as bag
addMethod unref|INDEX ... OBJECT LONG_TAG|remove object from bag and unref, old position holds null object

addClass BagIter|Iter|bag iterator
addMethod seek|INDEX ...|set iterator to position specified by INDEX
addMethod findNext|LONG_TAG ... BOOL|return true if found, iterator is positioned at pair matching LONG_TAG
addMethod insert|OBJECT LONG_TAG ...|insert OBJECT in collection just before current iterator position

addClass ByteArray|Iterable|array of bytes
addMethod get|INDEX ... BYTE_VALUE|get byte value at specified index
addMethod set|BYTE_VALUE INDEX ...|set byte value at specified index
addMethod ref|INDEX ... BYTE_PTR|return address of byte at INDEX
addMethod swap|INDEX_I INDEX_J ...|swap bytes at specified indices
addMethod resize|NEW_SIZE ...|set array size to NEW_SIZE bytes
addMethod insert|BYTE_VALUE INDEX ...|insert BYTE_VALUE at INDEX
addMethod remove|INDEX ... BYTE_VALUE|remove BYTE_VALUE at specified index
addMethod push|BYTE_VALUE ...|add BYTE_VALUE to end of array
addMethod pop|... BYTE_VALUE|remove last BYTE_VALUE in array
addMethod base|... BYTE_PTR|return address of first byte in array
addMethod load|<N BYTE_VALUEs> N ...|set array to contain N BYTE_VALUEs on stack
addMethod fromMemory|BYTE_PTR N OFFSET ...|copy N bytes from memory at BYTE_PTR into array starting at index OFFSET
addMethod find|BYTE_VALUE ... ITER_OBJECT true   OR   false|return iterator positioned at BYTE_VALUE plus true, or just false if not found in array
addMethod findValue|BYTE_VALUE ... INDEX|return INDEX of byte in array, return -1 if byte not found
addMethod reverse|...|reverse order of bytes in array
addMethod sort|...|sort array bytes
addMethod usort|...|sort array unsigned bytes
addMethod setFromString|STRING_PTR ...|resize array to hold string at STRING_PTR and copy it there

addClass ByteArrayIter|Iter|byte array iterator
addMethod seek|INDEX ...|set iterator to position specified by INDEX
addMethod tell|... INDEX|return position of iterator
addMethod findNext|BYTE_VALUE ... BOOL|return true if found, iterator is positioned at matching byte

addClass ShortArray|Iterable|array of short (16-bit integer)
addMethod get|INDEX ... SHORT_VALUE|get short value at specified index
addMethod set|SHORT_VALUE INDEX ...|set short value at specified index
addMethod ref|INDEX ... SHORT_PTR|return address of short at INDEX
addMethod swap|INDEX_I INDEX_J ...|swap shorts at specified indices
addMethod resize|NEW_SIZE ...|set array size to NEW_SIZE shorts
addMethod insert|SHORT_VALUE INDEX ...|insert SHORT_VALUE at INDEX
addMethod remove|INDEX ... SHORT_VALUE|remove SHORT_VALUE at specified index
addMethod push|SHORT_VALUE ...|add SHORT_VALUE to end of array
addMethod pop|... SHORT_VALUE|remove last SHORT_VALUE in array
addMethod base|... SHORT_PTR|return address of first short in array
addMethod load|<N SHORT_VALUEs> N ...|set array to contain N SHORT_VALUEs on stack
addMethod fromMemory|SHORT_PTR N OFFSET ...|copy N shorts from memory at SHORT_PTR into array starting at index OFFSET
addMethod find|SHORT_VALUE ... ITER_OBJECT true   OR   false|return iterator positioned at SHORT_VALUE plus true, or just false if not found in array
addMethod findValue|SHORT_VALUE ... INDEX|return INDEX of short in array, return -1 if short not found
addMethod reverse|...|reverse order of shorts in array
addMethod sort|...|sort array shorts
addMethod usort|...|sort array unsigned shorts
addMethod setFromString|STRING_PTR ...|resize array to hold string at STRING_PTR and copy it there

addClass ShortArrayIter|Iter|short array iterator
addMethod seek|INDEX ...|set iterator to position specified by INDEX
addMethod tell|... INDEX|return position of iterator
addMethod findNext|SHORT_VALUE ... BOOL|return true if found, iterator is positioned at matching short

addClass IntArray|Iterable|array of ints
addMethod get|INDEX ... INT_VALUE|get int value at specified index
addMethod set|INT_VALUE INDEX ...|set int value at specified index
addMethod ref|INDEX ... INT_PTR|return address of int at INDEX
addMethod swap|INDEX_I INDEX_J ...|swap ints at specified indices
addMethod resize|NEW_SIZE ...|set array size to NEW_SIZE ints
addMethod insert|INT_VALUE INDEX ...|insert INT_VALUE at INDEX
addMethod remove|INDEX ... INT_VALUE|remove INT_VALUE at specified index
addMethod push|INT_VALUE ...|add INT_VALUE to end of array
addMethod pop|... INT_VALUE|remove last INT_VALUE in array
addMethod base|... INT_PTR|return address of first int in array
addMethod load|<N INT_VALUEs> N ...|set array to contain N INT_VALUEs on stack
addMethod fromMemory|INT_PTR N OFFSET ...|copy N ints from memory at INT_PTR into array starting at index OFFSET
addMethod find|INT_VALUE ... ITER_OBJECT true   OR   false|return iterator positioned at INT_VALUE plus true, or just false if not found in array
addMethod findValue|INT_VALUE ... INDEX|return INDEX of int in array, return -1 if int not found
addMethod reverse|...|reverse order of ints in array
addMethod sort|...|sort array ints
addMethod usort|...|sort array unsigned ints
addMethod setFromString|STRING_PTR ...|resize array to hold string at STRING_PTR and copy it there

addClass IntArrayIter|Iter|int array iterator
addMethod seek|INDEX ...|set iterator to position specified by INDEX
addMethod tell|... INDEX|return position of iterator
addMethod findNext|INT_VALUE ... BOOL|return true if found, iterator is positioned at matching int

addClass FloatArray|Iterable|array of floats
addMethod get|INDEX ... FLOAT_VALUE|get float value at specified index
addMethod set|FLOAT_VALUE INDEX ...|set float value at specified index
addMethod ref|INDEX ... FLOAT_PTR|return address of float at INDEX
addMethod swap|INDEX_I INDEX_J ...|swap floats at specified indices
addMethod resize|NEW_SIZE ...|set array size to NEW_SIZE floats
addMethod insert|FLOAT_VALUE INDEX ...|insert FLOAT_VALUE at INDEX
addMethod remove|INDEX ... FLOAT_VALUE|remove FLOAT_VALUE at specified index
addMethod push|FLOAT_VALUE ...|add FLOAT_VALUE to end of array
addMethod pop|... FLOAT_VALUE|remove last FLOAT_VALUE in array
addMethod base|... FLOAT_PTR|return address of first float in array
addMethod load|<N FLOAT_VALUEs> N ...|set array to contain N FLOAT_VALUEs on stack
addMethod fromMemory|FLOAT_PTR N OFFSET ...|copy N floats from memory at FLOAT_PTR into array starting at index OFFSET
addMethod find|FLOAT_VALUE ... ITER_OBJECT true   OR   false|return iterator positioned at FLOAT_VALUE plus true, or just false if not found in array
addMethod findValue|FLOAT_VALUE ... INDEX|return INDEX of float in array, return -1 if float not found
addMethod reverse|...|reverse order of floats in array
addMethod sort|...|sort array of floats

addClass FloatArrayIter|Iter|float array iterator
addMethod seek|INDEX ...|set iterator to position specified by INDEX
addMethod tell|... INDEX|return position of iterator
addMethod findNext|FLOAT_VALUE ... BOOL|return true if found, iterator is positioned at matching float

addClass LongArray|Iterable|array of longs
addMethod get|INDEX ... LONG_VALUE|get long value at specified index
addMethod set|LONG_VALUE INDEX ...|set long value at specified index
addMethod ref|INDEX ... LONG_PTR|return address of long at INDEX
addMethod swap|INDEX_I INDEX_J ...|swap longs at specified indices
addMethod resize|NEW_SIZE ...|set array size to NEW_SIZE longs
addMethod insert|LONG_VALUE INDEX ...|insert LONG_VALUE at INDEX
addMethod remove|INDEX ... LONG_VALUE|remove LONG_VALUE at specified index
addMethod push|LONG_VALUE ...|add LONG_VALUE to end of array
addMethod pop|... LONG_VALUE|remove last LONG_VALUE in array
addMethod base|... LONG_PTR|return address of first long in array
addMethod load|<N LONG_VALUEs> N ...|set array to contain N LONG_VALUEs on stack
addMethod fromMemory|LONG_PTR N OFFSET ...|copy N longs from memory at LONG_PTR into array starting at index OFFSET
addMethod find|LONG_VALUE ... ITER_OBJECT true   OR   false|return iterator positioned at LONG_VALUE plus true, or just false if not found in array
addMethod findValue|LONG_VALUE ... INDEX|return INDEX of long in array, return -1 if long not found
addMethod reverse|...|reverse order of long in array
addMethod sort|...|sort array longs
addMethod usort|...|sort array unsigned longs
addMethod setFromString|STRING_PTR ...|resize array to hold string at STRING_PTR and copy it there

addClass LongArrayIter|Iter|long array iterator
addMethod seek|INDEX ...|set iterator to position specified by INDEX
addMethod tell|... INDEX|return position of iterator
addMethod findNext|LONG_VALUE ... BOOL|return true if found, iterator is positioned at matching long

addClass DoubleArray|Iterable|array of doubles
addMethod get|INDEX ... DOUBLE_VALUE|get double value at specified index
addMethod set|DOUBLE_VALUE INDEX ...|set double value at specified index
addMethod ref|INDEX ... DOUBLE_PTR|return address of double at INDEX
addMethod swap|INDEX_I INDEX_J ...|swap doubles at specified indices
addMethod resize|NEW_SIZE ...|set array size to NEW_SIZE doubles
addMethod insert|DOUBLE_VALUE INDEX ...|insert DOUBLE_VALUE at INDEX
addMethod remove|INDEX ... DOUBLE_VALUE|remove DOUBLE_VALUE at specified index
addMethod push|DOUBLE_VALUE ...|add DOUBLE_VALUE to end of array
addMethod pop|... DOUBLE_VALUE|remove last DOUBLE_VALUE in array
addMethod base|... DOUBLE_PTR|return address of first double in array
addMethod load|<N DOUBLE_VALUEs> N ...|set array to contain N DOUBLE_VALUEs on stack
addMethod fromMemory|DOUBLE_PTR N OFFSET ...|copy N doubles from memory at DOUBLE_PTR into array starting at index OFFSET
addMethod find|DOUBLE_VALUE ... ITER_OBJECT true   OR   false|return iterator positioned at DOUBLE_VALUE plus true, or just false if not found in array
addMethod findValue|DOUBLE_VALUE ... INDEX|return INDEX of double in array, return -1 if double not found
addMethod reverse|...|reverse order of double in array
addMethod sort|...|sort array doubles
addMethod usort|...|sort array unsigned doubles
addMethod setFromString|STRING_PTR ...|resize array to hold string at STRING_PTR and copy it there

addClass DoubleArrayIter|Iter|double array iterator
addMethod seek|INDEX ...|set iterator to position specified by INDEX
addMethod tell|... INDEX|return position of iterator
addMethod findNext|DOUBLE_VALUE ... BOOL|return true if found, iterator is positioned at matching double

addClass StructArray|Iterable|array of structs
addMethod get|DEST_PTR INDEX ...|copy struct at specified index to memory at DEST_PTR
addMethod set|SRC_PTR INDEX ...|copy struct at SRC_PTR to specified index
addMethod ref|INDEX ... STRUCT_PTR|return address of struct at INDEX
addMethod swap|INDEX_I INDEX_J ...|swap structs at specified indices
addMethod resize|NEW_SIZE ...|set array size to NEW_SIZE structs
addMethod insert|SRC_PTR INDEX ...|insert struct at SRC_PTR at INDEX
addMethod remove|DST_PTR INDEX ... STRUCT_VALUE|copy struct at INDEX to memory at DST_PTR and remove from array
addMethod push|SRC_PTR ...|add struct at SRC_PTR to end of array
addMethod pop|DST_PTR ... DUMMY_INT|copy last struct in array to DST_PTR and remove
addMethod base|... STRUCT_PTR|return address of first struct in array
addMethod setType|STRUCT_VOCAB_PTR ...|set type of structs in array - this sets element size

addClass StructArrayIter|Iter|struct array iterator
addMethod next|... STRUCT_PTR true   OR   false|return struct at iterator cursor and true, return false if already at last element, advance to next element
addMethod prev|... STRUCT_PTR true   OR   false|return struct at iterator cursor and true, return false if already at first element, advance to previous element
addMethod current|... STRUCT_PTR true   OR   false|return struct at iterator cursor and true, return false if already at last element
addMethod remove|...|remove the struct at iterator cursor

addClass Pair|Iterable|pair of objects - much like a 2 element Array
addMethod getA|... OBJECT_A|get object A
addMethod setA|OBJECT_A ...|set object A
addMethod getB|... OBJECT_B|get object B
addMethod setB|OBJECT_B ...|set object B

addClass PairIter|Iter|pair iterator
addMethod next|... OBJECT true   OR   false|return item at iterator cursor and true, return false if already at last element, advance to next element
addMethod prev|... OBJECT true   OR   false|return item at iterator cursor and true, return false if already at first element, advance to previous element
addMethod current|... OBJECT true   OR   false|return item at iterator cursor and true, return false if already at last element

addClass Triple|Iterable|triplet of objects - much like a 3 element Array
addMethod getA|... OBJECT_A|get object A
addMethod setA|OBJECT_A ...|set object A
addMethod getB|... OBJECT_B|get object B
addMethod setB|OBJECT_B ...|set object B
addMethod getC|... OBJECT_C|get object C
addMethod setC|OBJECT_C ...|set object C

addClass TripleIter|Iter|triplet iterator
addMethod next|... OBJECT true   OR   false|return item at iterator cursor and true, return false if already at last element, advance to next element
addMethod prev|... OBJECT true   OR   false|return item at iterator cursor and true, return false if already at first element, advance to previous element
addMethod current|... OBJECT true   OR   false|return item at iterator cursor and true, return false if already at last element

addClass List|Iterable|linked list of objects
addMethod isEmpty|... BOOL|return true if list is empty
addMethod head|... OBJECT|get object at head of list
addMethod tail|... OBJECT|get object at tail of list
addMethod addHead|OBJECT ...|add object to head of list
addMethod addTail|OBJECT ...|add object to tail of list
addMethod removeHead|...|discard object at head of list
addMethod removeTail|...|discard object at tail of list
addMethod unrefHead|... OBJECT|remove object from head of list
addMethod unrefTail|... OBJECT|remove object from tail of list
addMethod find|OBJECT ... ITER true   OR   false|return list iterator at position of found object
addMethod load|<N OBJECTS> N ...|set list to contain N objects on stack
addMethod toArray|... ARRAY_OBJECT|create an array with the same objects as this list
addMethod remove|OBJECT ...|if object is found in list, it will be removed (only first occurence)

addClass ListIter|Iter|list iterator
addMethod swapNext|...|swap the order of the object at iterator position and next in list
addMethod swapPrev|...|swap the order of the object at iterator position and previous in list
addMethod split|... NEW_LIST|split this list at the cursor position and return the new list

addClass Map|Iterable|map with object keys and object values
addMethod get|OBJECT_KEY ... OBJECT_VALUE|return object whose key matches OBJECT_KEY, return null object if not found
addMethod set|OBJECT_VALUE OBJECT_KEY ...|add a key/value pair to the map
addMethod load|<N PAIRS> N ...|set map to contain N value/key pairs on stack
addMethod findValue|OBJECT_VALUE ... OBJECT_KEY true   OR   false|return key object given value object
addMethod remove|OBJECT_KEY ...|remove object,key pair from map
addMethod unref|OBJECT_KEY ... OBJECT_VALUE|remov object,key pair from map, return value object
addMethod find|OBJECT_KEY ... ITER true   OR   false|return map iterator at position of found object

addClass MapIter|Iter|object map iterator
addMethod findNext|OBJECT_KEY ... false|not implemented, always returns false - why is this here?
addMethod nextPair|... OBJECT_VALUE OBJECT_KEY true   OR   false|return item at iterator cursor and true, return false if already at last element, advance to next element
addMethod prevPair|... OBJECT_VALUE OBJECT_KEY true   OR   false|return item at iterator cursor and true, return false if already at first element, advance to previous element
addMethod currentPair|... OBJECT_VALUE OBJECT_KEY true   OR   false|return item at iterator cursor and true, return false if already at last element

addClass Map|Iterable|map with object keys and object values
addMethod get|OBJECT_KEY ... OBJECT_VALUE|return object whose key matches OBJECT_KEY, return null object if not found
addMethod set|OBJECT_VALUE OBJECT_KEY ...|add a key/value pair to the map
addMethod load|<N PAIRS> N ...|set map to contain N value/key pairs on stack
addMethod findValue|OBJECT_VALUE ... OBJECT_KEY true   OR   false|return key object given value object
addMethod remove|OBJECT_KEY ...|remove object,key pair from map
addMethod unref|OBJECT_KEY ... OBJECT_VALUE|remov object,key pair from map, return value object
addMethod find|OBJECT_KEY ... ITER true   OR   false|return map iterator at position of found object

addClass IntMap|Iterable|map with integer keys and object values
addMethod get|INT_KEY ... OBJECT_VALUE|return object whose key matches INT_KEY, return null object if not found
addMethod set|OBJECT_VALUE INT_KEY ...|add a key/value pair to the map
addMethod load|<N PAIRS> N ...|set map to contain N value/key pairs on stack
addMethod findValue|OBJECT_VALUE ... INT_KEY true   OR   false|return key int given value object
addMethod remove|INT_KEY ...|remove key/value pair from map
addMethod unref|INT_KEY ... OBJECT_VALUE|remove key/value pair from map, return value object
addMethod find|INT_KEY ... ITER true   OR   false|return map iterator at position of found object

loaddone

TODO:
- refactor so that NoteDeck just holds top level Notes, like "ops", "classes"
  - ops has one Note per forth op
  - classes has one Note per builtin class, their children are class methods
