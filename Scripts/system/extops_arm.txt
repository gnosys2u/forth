//
// basic ops not included in the kernel defined in ARM assembler
//
requires asm_arm
requires forth_internals

autoforget extops

: extops ;

code _doDoesCode
  // RTOS is data ptr, RTOS+1 is IP, IP points to asm code for does action
  rip r0 mov,
  rrp ia! { r1 rip } ldm,	// r1 is data ptr
  r0 bx,
  endcode
  
: doescode
  postpone does
  ['] _doDoesCode here 4- !
  also assembler
  0 state !
  postpone recursive
;
precedence doescode

#if( 0 )
// sample usage
: adder
  builds
    ,
  doescode
    // r1 is data ptr
    r1 ] r2 ldr,
    rsp ] r0 ldr,
    r0 r2 r2 add,
    rsp ] r2 str,
    next,

5 adder add5
#endif
    
code abs
  rsp ] r0 ldr,
  r0 r0 r0 orrs,
  lr ge bx,
  r0 r0 neg,
  rsp ] r0 str,
  next,
  
code +!
  rsp ia! { r0 r1 } ldm,	// r0 is ptr to dst ptr, r1 is amount to add
  r0 ] r2 ldr,
  r1 r2 r2 add,
  r0 ] r2 str,
  next,
  
code roll
  // TOS is number of entries to roll (1 means swap, 2 means rot)
  { r0 } ppop,
  r0 r0 r0 orrs,
  lr eq bx,					// early exit if #entries == 0
  //ne if,
  
    gt if,
      // positive roll
      rsp  r0 2 #lsl  r2 add,
      r2 ] r3 ldr,		// r3 = value to move to TOS
      begin,
        r2 db! { r1 } ldm,
        r2 4 #] r1 str,
        r0 1 # r0 subs,
      eq until,
      rsp ] r3 str,
      lr bx,
    endif,
    
    // negative roll
    r0 r0 neg,
    rsp r2 mov,
    r2 ] r3 ldr,	// r3 = value to move to bottom
    begin,
      r2 4 #] r1 ldr,
      r2 ia! { r1 } stm,
      r0 1 # r0 subs,
    eq until,
    r2 ] r3 str,
    
  //endif,
  next,
  
  
code 2dup
  rsp ia { r0 r1 } ldm,
  rsp db! { r0 r1 } stm,
  next,
  
code 2swap
  rsp ia { r0 r1 r2 } ldm,
  rsp ] r2 str,
  rsp 0xC #] r2 ldr,
  rsp 4 #] r2 str,
  rsp 8 #] r0 str,
  rsp 0xC #] r1 str,
  next,
  
code 2drop
  rsp 8 # rsp add,
  next,

code ndrop
  { r0 } ppop,
  rsp  r0 2 #lsl  rsp add,
  next,
  
code ndup
  // TOS is number of entries to dup
  { r0 } ppop,
  r0 r0 r0 orrs,
  lr eq bx,					// early exit if #entries == 0
  rsp  r0 2 #lsl  r2 add,
  begin,
    r2 4 # r2 sub,
    r2 ] r1 ldr,
    { r1 } ppush,
    r0 1 # r0 subs,
  eq until,
  next,
  
code 2over
  rsp 8 #] r0 ldr,
  rsp 0xC #] r1 ldr,
  rsp db! { r0 r1 } stm,
  next,
  
// 5 -> 1 4 -> 0 3 -> 5 2 -> 4 1 -> 3 0 -> 2
code 2rot
  rsp 0x14 #] r0 ldr,
  rsp 0xC #] r1 ldr,
  rsp 0x14 #] r1 str,
  rsp 4 #] r1 ldr,
  rsp 0xC #] r1 str,
  rsp 4 #] r0 str,
  rsp 0x10 #] r0 ldr,
  rsp 8 #] r1 ldr,
  rsp 0x10 #] r1 str,
  rsp ] r1 ldr,
  rsp 8 #] r1 str,
  rsp ] r0 str,
  next,
  
// 5 -> 3 4 -> 2 3 -> 1 2 -> 0 1 -> 5 0 -> 4
code -2rot
  rsp 0x14 #] r0 ldr,
  rsp 4 #] r1 ldr,
  rsp 0x14 #] r1 str,
  rsp 0xC #] r1 ldr,
  rsp 4 #] r1 str,
  rsp 0xC #] r0 str,
  rsp 0x10 #] r0 ldr,
  rsp ] r1 ldr,
  rsp 0x10 #] r1 str,
  rsp 8 #] r1 ldr,
  rsp ] r1 str,
  rsp 8 #] r0 str,
  next,

code 2nip
  rsp ia { r0 r1 } ldm,
  rsp 16 # rsp add,
  rsp db! { r0 r1 } stm,
  next,

code 2tuck
  { r0 r1 r2 r3 } ppop,
  rsp 8 # rsp sub,
  { r0 r1 r2 r3 } ppush,
  rsp 0x10 #] r0 str,
  rsp 0x14 #] r1 str,
  next,
  
code 2pick
  { r0 } ppop,
  rsp r0 3 #lsl r2 add,
  r2 ia { r0 r1 } ldm,
  { r0 r1 } ppush,
  next,
  
code 2roll
  // TOS is number of entries to roll (1 means swap, 2 means rot)
  { r0 } ppop,
  r0 r0 r0 orrs,
  lr eq bx,					// early exit if #entries == 0
  { rip rfp } push,		// we will use rip,rfp as temps
  
    gt if,
    
      // positive roll
      rsp  r0 3 #lsl  r2 add,
      r2 ] r3 ldr,		// r3,rfp = value to move to TOS
      r2 4 #] rfp ldr,
      begin,
        r2 db! { r1 rip } ldm,
        r2 8 #] r1 str,
        r2 0xC #] rip str,
        r0 1 # r0 subs,
      eq until,
      rsp ] r3 str,
      lr bx,
      
    else,
    
    // negative roll
    r0 r0 neg,			// make roll count positive
    
    rsp r2 mov,
    r2 ] r3 ldr,	// r3,rfp = value to move to bottom
    r2 4 #] rfp ldr,
    begin,
      r2 8 #] r1 ldr,
      r2 0xC #] rip ldr,
      r2 ia! { r1 rip } stm,
      r0 1 # r0 subs,
    eq until,
    r2 ] r3 str,
    r2 4 #] rfp str,
    
  { rip rfp } ppop,
  next,
  
code l+
  { r0 r1 r2 r3 } ppop,
  r2 r0 r2 adds,
  r3 r1 r3 adc,
  { r2 r3 } ppush,
  next,
  
code l-
  { r0 r1 r2 r3 } ppop,
  r2 r0 r2 subs,
  r3 r1 r3 sbc,
  { r2 r3 } ppush,
  next,
  
code lnegate
  rsp ia { r0 r1 } ldm,
  r2 r2 r2 eor,
  r2 r0 r0 subs,
  r2 r1 r1 sbc,
  rsp ia { r0 r1 } stm,
  next,
  
code labs
  rsp ia { r0 r1 } ldm,
  r1 r1 r1 orrs,
  lr ge bx,				// bail if not negative
  r2 r2 r2 eor,
  r2 r0 r0 subs,
  r2 r1 r1 sbc,
  rsp ia { r0 r1 } stm,
  next,

loaddone
  
// http://stackoverflow.com/questions/1131833/how-do-you-multiply-two-64-bit-numbers-in-x86-assembler
// http://www.plantation-productions.com/Webster/www.artofasm.com/Windows/HTML/AdvancedArithmetica2.html#1007619

code l*
  edi push,
  ecx push,
  // edx always holds hi 32 bits of mul result
  edx ebx mov,			// so we will use ebx for the forth stack ptr
  
  // TOS: blo ebx   bhi ebx+4   alo ebx+8   ahi ebx+12
  
  ecx ecx xor,			// ecx holds sign flag
  
  4 ebx d] eax mov,
  eax eax or,
  0<, if,
  	// b is negative
    ecx not,
    ebx ] esi mov,
    esi not,
    eax not,
    1 # esi add,
    0 # eax adc,
    esi ebx ] mov,
    eax 4 ebx d] mov,
  endif,
  
  12 ebx d] eax mov,
  8 ebx d] esi mov,
  eax eax or,
  0<, if,
  	// a is negative
    ecx not,
    esi not,
    eax not,
    1 # esi add,
    0 # eax adc,
    esi 8 ebx d] mov,
    eax 12 ebx d] mov,
  endif,
  
  // alo(esi) * blo
  ebx ] eax mov,
  esi mul,				// edx is hipart, eax is final lopart
  edx edi mov,			// edi is hipart accumulator
  
  8 ebx d] esi mov,		// esi = alo
  eax 8 ebx d] mov,

  // alo * bhi
  4 ebx d] eax mov,		// eax = bhi
  esi mul,
  eax edi add,
  
  // ahi * blo
  12 ebx d] esi mov,
  ebx ] eax mov,
  esi mul,
  eax edi add,			// edi = hiResult
  
  // invert result if needed
  ecx ecx or,
  0<, if,
    8 ebx d] eax mov,		// eax = loResult
    eax not,
    edi not,
    1 # eax add,
    0 # edi adc,
    eax 8 ebx d] mov,
  endif,
  
  edi 12 ebx d] mov,
  
  8 # ebx add,
  ebx edx mov,
  ecx pop,
  edi pop,
  next,

  
// .fl for 64-bit, .fs for 32-bit

code dpi
  fldpi,
  8 # edx sub,
  .fl edx ] fstp,
  next,
  
code dsq
  edx ] .fl fld,
  fsqrt,
  edx ] .fl fstp,
  next,
  
loaddone

// eax ebx ecx edx edi esi ebp
// r and d need to be 64-bit
// n and q could be as small as a byte

code l/
  // TOS: dlo edx   dhi edx+4   nlo edx+8   nhi edx+12
  
  ebx ebx xor,			// ebx holds sign flag
  
  // negate denominator if needed
  4 edx d] eax mov,
  eax eax or,
  0<, if,
    ebx not,
    edx ] esi mov,
    esi not,
    eax not,
    1 # esi add,
    0 # eax adc,
    esi edx ] mov,
    eax 4 edx d] mov,
  else,
    // bail if denominator is zero
    0=, if,
      edx ] eax mov,
      eax eax or,
      0=, if,
        // TODO: set divide-by-zero status
        16 # edx add,
        next,
      endif,
  endif,
  
  // negate numerator if needed
  12 edx d] eax mov,
  eax eax or,
  0<, if,
    ebx not,
    8 edx d] esi mov,
    esi not,
    eax not,
    1 # esi add,
    0 # eax adc,
    esi 8 edx d] mov,
    eax 12 edx d] mov,
  endif,
  
  edi push,
  ecx push,
  ebx push,			// sign flag is top of regular stack
  
  // N  edx[12]  edx[8]
  // D  edx[4]   edx[0]
  // R  ebx:eax  rhi:rlo
  // Q
  
  // Q := 0                 initialize quotient and remainder to zero
  // R := 0                     
  // for i = n-1...0 do     where n is number of bits
  //   R := R << 1          left-shift R by 1 bit    
  //   R(0) := N(i)         set the least-significant bit of R equal to bit i of the numerator
  //   if R >= D then
  //     R = R - D               
  //     Q(i) := 1
  //   end
  // loop  

  
  // alo(esi) * blo
  ebx ] eax mov,
  esi mul,				// edx is hipart, eax is final lopart
  edx edi mov,			// edi is hipart accumulator
  
  8 ebx d] esi mov,		// esi = alo
  eax 8 ebx d] mov,

  // alo * bhi
  4 ebx d] eax mov,		// eax = bhi
  esi mul,
  eax edi add,
  
  // ahi * blo
  12 ebx d] esi mov,
  ebx ] eax mov,
  esi mul,
  eax edi add,			// edi = hiResult
  
  // invert result if needed
  ebx pop,
  ebx ebx or,
  0<, if,
    8 ebx d] eax mov,		// eax = loResult
    eax not,
    edi not,
    1 # eax add,
    0 # edi adc,
    eax 8 ebx d] mov,
  endif,
  
  edi 12 ebx d] mov,
  
  8 # ebx add,
  ebx edx mov,
  ecx pop,
  edi pop,
  next,
  

code goo
  _TDPtr ebp d] eax mov,		// eax = this ptr
  4 eax d] ebx mov,			// ebx = first word of object data
  4 # edx sub,
  ebx edx ] mov,
  next,
  
class: boo

  int aa
  method: getaa
    goo
  ;method
  
  method: setaa
    -> aa
  ;method
  
;class

  