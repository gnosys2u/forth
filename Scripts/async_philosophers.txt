
autoforget ASYNC_PHILOSOPHERS
: ASYNC_PHILOSOPHERS ;

mko Array philosophers
mko Array forks

10 -> int helpingsToEat
20 -> int eatingTime
20 -> int digestionTime
5 -> int defaultNumPhilosophers
true -> bool useForks

true -> bool usePrintLocks
AsyncLock printLock
: p[
  if(usePrintLocks)
    printLock.grab
  endif
;

: ]p
  if(usePrintLocks)
    printLock.ungrab
  endif
;

class: AsyncPhilosopher
  AsyncThread eatingThread
  AsyncLock firstFork
  AsyncLock secondFork
  int id
  int timesFed
  int timesHungry
  
  m: delete
    oclear eatingThread
    oclear firstFork
    oclear secondFork
  ;m

  m: isHungry
    eatingThread.getRunState kFTRSExited <>
  ;m
  
  m: run
    begin
    while(timesFed helpingsToEat <)
      if(useForks)
        d[ p[ "philosopher " %s id %d " grabbing first fork(" %s firstFork.id %d ")\n" %s ]p ]d
        firstFork.grab
        d[ p[ "philosopher " %s id %d " grabbing second fork(" %s secondFork.id %d ")\n" %s ]p ]d
        secondFork.grab
      endif
      1 ->+ timesFed
      d[ p[ "philosopher " %s id %d " ate " %s timesFed %d " time, going to sleep\n" %s ]p ]d

      ms(eatingTime)
      
      if(useForks)
        d[ p[ "philosopher " %s id %d " ungrabbing first fork(" %s firstFork.id %d ")\n" %s ]p ]d
        firstFork.ungrab
        d[ p[ "philosopher " %s id %d " ungrabbing second fork(" %s secondFork.id %d ")\n" %s ]p ]d
        secondFork.ungrab
      endif
      
      ms(digestionTime)
      
    repeat
    p[ "philosopher " %s id %d " done\n" %s ]p
    exitAsyncThread
  ;m

  m: init
    -> secondFork
    -> firstFork
    -> id
    -> eatingThread
    id -> eatingThread.id
  ;m
  
;class

: asyncPhilosopherLoop
  -> AsyncPhilosopher phil
  phil.run
  oclear phil
;
  
: asyncDiningLoop
  p[ "let the feast begin!\n" %s ]p
  ms@ -> int feastStart

  philosophers.count -> int numPhilosophers
  do(numPhilosophers 0)
    philosophers.get(i) ->o AsyncPhilosopher phil
    phil.init(createAsyncThread(lit asyncPhilosopherLoop 1000 1000) i forks.get(i) forks.get(i 1+ numPhilosophers mod))
    //p[ "philosopher " %s i %d %bl phil.eatingThread.__thread %x %nl ]p
  loop
  
  do(numPhilosophers 0)
    philosophers.get(i) ->o AsyncPhilosopher phil
    phil.eatingThread.startWithArgs(r[ phil ]r) drop
  loop
  
  begin
    0 -> int numHungryPhilosophers
    do(numPhilosophers 0)
      philosophers.get(i) ->o phil
      if(phil.isHungry)
        1 ->+ numHungryPhilosophers
      endif
    loop
    ms(50)
  until(numHungryPhilosophers 0=)
  p[ "all philosophers stuffed!\n" %s ]p
  p[ ms@ feastStart - %d " milliseconds elapsed\n\n\n" %s ]p
  
  philosophers.clear
  forks.clear
;

: asyncDiningPhilosophers
  -> int numPhilosophers
  philosophers.clear
  forks.clear
  system.createAsyncLock -> printLock
  
  do(numPhilosophers 0)
    new AsyncPhilosopher -> AsyncPhilosopher phil
    i -> phil.id
    philosophers.push(phil)
    oclear phil
    
    system.createAsyncLock -> AsyncLock fork
    i -> fork.id
    forks.push(fork)
    oclear fork
  loop
  
  asyncDiningLoop
  oclear printLock
;

: go
  defaultNumPhilosophers asyncDiningPhilosophers
;

loaddone
