autoforget BUILTIN_CLASS_TEST

: BUILTIN_CLASS_TEST ;

// Object: delete show getClass compare(OBJ) keep release refCount
// Class: delete create getParent getName getVocabulary getInterface("INTERFACE_NAME") setNew(OP)

// Iterable: headIter tailIter find clone count clear
// Iter: seekNext seekPrev seekHead seekTail next prev current remove unref findNext(OBJ) clone

// Array: resize(N) ref(N) unref(N) get(N) set(OBJ N) findIndex(OBJ) push(OBJ) popUnref load(N_OBJECTS N)
// ArrayIter:
// List: head tail addHead(OBJ) addTail(OBJ) removeHead removeTail unrefHead unrefTail load(N_OBJECTS N)
// ListIter: swapNext swapPrev split
// IntMap: get(KEY) set(OBJ KEY) findKey(OBJ) remove(KEY)
// IntMapIter: nextPair prevPair

// String: size length get set(STR) append(STR) resize(N) startsWith(STR) endsWith(STR) contains(STR) clear hash appendChar(CHAR)

// Pair: setA(OBJ) getA setB(OBJ) getB   (no find, clone, count, clear)
// PairIter: (no remove, findNext, clone)
// Triple: setA(OBJ) getA setB(OBJ) getB setC(OBJ) getC   (no find, clone, count, clear)
// TripleIter: (no remove, findNext, clone)

// ByteArray: resize ref(N) get(N) set(OBJ N) findIndex(OBJ) push(BYTE) pop base
// ByteArrayIter: 
// ShortArray: resize ref(N) get(N) set(OBJ N) findIndex(OBJ) push(BYTE) pop base
// ShortArrayIter: 
// IntArray: resize ref(N) get(N) set(OBJ N) findIndex(OBJ) push(BYTE) pop base
// IntArrayIter: 
// LongArray: resize ref(N) get(N) set(OBJ N) findIndex(OBJ) push(BYTE) pop base
// LongArrayIter: 

// Int Long Float Double: get set(N) show compare(N)

// Thread: init(PSTACK_SIZE RSTACK_SIZE OP) start push(N) pop rpush(N) rpop getState step reset


int nextObjId

class: tobj    extends Object
  int objId

  m: setObjId
    -> objId
  ;m
    
  new:
    _allocObject
    2dup nextObjId -rot -> <tobj>.objId
    "|+" %s nextObjId %d
    1 ->+ nextObjId
  ;

  // m: show    objId %d %bl  ;m
  
  m: delete
    "|-" %s objId %d
    super.delete
  ;m
  
;class


mko tobj valA
mko tobj valB
mko tobj valC
mko tobj valD
mko tobj valE

// Array:   clear   resize(N)   count   get(I)   set(O I)   findIndex(O)   push(O)   pop   headIter   tailIter   clone
// List:   head   tail   addHead(O)   addTail(O)   removeHead   removeTail   headIter   tailIter   count   find(O)   clone
// IntMap:   clear   count   get(KEY)   set(O KEY)   findIndex(O)   remove(KEY)   headIter   tailIter   

//"(vb=" %s tb <tobj>.refCount %d " before adding to map)" %s
mko IntMap imapA
imapA.set( valA 'a' )  imapA.set( valB 'b' )  imapA.set( valC 'c' )  imapA.set( valD 'd' )  imapA.set( valE 'e' )
%nl imapA.show %nl

mko LongMap lmapA
lmapA.set( valA 1l )  lmapA.set( valB '22'l )  lmapA.set( valC 1000000000l )  lmapA.set( valD -15l )  lmapA.set( valE 66l )
%nl lmapA.show %nl

mko FloatMap fmapA
fmapA.set( valA 1.7 )  fmapA.set( valB 2.3 )  fmapA.set( valC 33.0 )  fmapA.set( valD 1.234 )  fmapA.set( valE 5.789 )
%nl fmapA.show %nl

mko DoubleMap dmapA
dmapA.set( valA 1.7d )  dmapA.set( valB 2.3d )  dmapA.set( valC 33.0d )  dmapA.set( valD 1.234d )  dmapA.set( valE 5.789d )
%nl dmapA.show %nl

mko StringMap smapA
smapA.set( valA "aa" )  smapA.set( valB "bb" )  smapA.set( valC "cc" )  smapA.set( valD "dd" )  smapA.set( valE "ee" )
smapA.get("aa").show smapA.get("bb").show smapA.get("cc").show smapA.get("dd").show smapA.get("ee").show  smapA.get("foo") %2x %nl
%nl smapA.show %nl

mko List listA
listA.addHead(imapA.get( 'b' ))  listA.addHead(imapA.get( 'c' ))  listA.addHead(imapA.get( 'd' ))
%nl listA.show %nl

mko Array arrayA
arrayA.push(imapA.get( 'a' ))  arrayA.push(valB)  arrayA.push(imapA.get( 'c' ))
%nl arrayA.show %nl

: showArray
  -> Array a
  a.headIter -> ArrayIter iter
  a.show %nl
  begin
  while( iter.next )
    <Object>.show
  repeat
  begin
  while( iter.prev )
    <Object>.show
  repeat
  oclear a
  oclear iter
  %nl
;
arrayA showArray

"toList\n" %s
arrayA.toList -> List listFromArrayA
"toList 2\n" %s
listFromArrayA.show
"toList 3\n" %s
listFromArrayA.toArray -> Array arrayFromListA
arrayFromListA.show

oclear listFromArrayA  oclear arrayFromListA

//"{clearing map}" %s
oclear imapA  oclear lmapA  oclear fmapA  oclear dmapA  oclear smapA

//"{clearing list}" %s
oclear listA

//"{clearing array}" %s
oclear arrayA

oclear valA  oclear valB  oclear valC  oclear valD  oclear valE

mko List zz
mko String za
mko String zb
mko String zc
mko String zd
mko String zr
za.set( "a" )
zb.set( "b" )
zc.set( "c" )
zd.set( "d" )
zr.set( "r" )
zz.addTail( za ) zz.addTail( zb ) zz.addTail( zr ) zz.addTail( za ) 
zz.addTail( zc ) zz.addTail( za ) zz.addTail( zd ) 
zz.addTail( za ) zz.addTail( zb ) zz.addTail( zr ) zz.addTail( za ) 

zz.clone -> List zz2

: so
  drop dup %x %bl @ %d %bl
;

// abra cad abra
: ff
  -> Iterable oi
  "list " %s oi so %nl
  oi.headIter -> Iter iter
  begin
  while( iter.next )
    -> String ss
    ss.show
    oclear ss
  repeat
  %nl
  oclear oi
;

// Iterable: headIter tailIter find clone count clear
// Iter: seekNext seekPrev seekHead seekTail next prev current remove findNext(OBJ) clone

// Array: resize(N) ref(N) get(N) set(OBJ N) findIndex(OBJ) push(OBJ) pop
// ArrayIter:

: testArray
  mko Array aa
  r[ 1 17 42 53 89 ]r
  -> int nItems
  do( nItems 0 )
  loop
  oclear aa
;

: test
  mko Array aa
  mko List la
  do( 15 0 )
    mko Int bob
    bob.set( i )
    aa.push( bob )
    la.addTail( bob )
    oclear bob
  loop
  oclear aa
  oclear la
;

test
"run cleanup to free objects" %s %nl

: cleanup
  oclear zz
  oclear zz2
  oclear za  oclear zb  oclear zc  oclear zd  oclear zr
;

loaddone

+	Object
-	Class
+	Array
+	ArrayIter
+	List
-	ListIter
-	Map
-	MapIter
-	IntMap
-	IntMapIter
-	LongMap
-	LongMapIter
-	FloatMap
?	FloatMapIter
-	DoubleMap
?	DoubleMapIter
-	StringMap
-	StringMapIter
+	String
+	Pair
-	PairIter
+	Triple
-	TripleIter
+	ByteArray
+	ByteArrayIter
+	ShortArray
+	ShortArrayIter
+	IntArray
+	IntArrayIter
+	LongArray
+	LongArrayIter
+	FloatArray
?	FloatArrayIter
+	DoubleArray
?	DoubleArrayIter
+	Int
+	Long
+	Float
+	Double
-	Thread
-	InStream
-	FileInStream
-	ConsoleInStream
-	OutStream
-	FileOutStream
-	StringOutStream
-	ConsoleOutStream
-	FunctionOutStream
